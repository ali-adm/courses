# Directus
# [Руководство по быстрому запуску](https://docs.directus.io/getting-started/quickstart.html)
Это краткое руководство поможет вам запустить **проект Directus** за несколько минут. По ходу дела вы лучше поймёте, что такое Directus, настроите свой проект Directus локально или с помощью Directus Cloud и получите практическое представление о приложении и API.

<a id="back"></a>
### Оглавление:
#### [1. Создайте проект](#1_create_proj)
#### [Быстрый запуск для самостоятельного размещения](#self_hosting_docker)
#### [Параметры конфигурации](#conf_opt)
#### [2. Создайте коллекцию](#2_create_collect)
#### [Коллекции (Collections)](#collections)
##### [Элементы](#elements)
##### [Поля](#fields)
##### [Разрешения (Permissions)](#permissions)
#### [Модель данных (Data model)](#data_model)
##### [Таблицы данных](#data_table)
##### [Столбцы](#rows)
##### [Типы взаимосвязей](#relation_types)
##### [Избегайте дублирования данных](#data_undouble)
##### [Модели данных в Directus](#data_mod_directus)
#### [Модуль содержимого (Content module)](#content_module)
#### [Макеты (layouts)](#layouts)
#### [Страница коллекции](#collection_page)
#### [3. Создайте поле](#3_field_create)
#### [4. Создайте элемент](#4_el_create)
#### [5. Настройка ролей и разрешений](#5_access_setup)
#### [6. Подключение к API](#6_api_connect)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)

### [Назад к оглавлению](#back)



<a id=""></a>
### 


<a id="1_create_proj"></a>
## 1. Создайте проект
### Directus Cloud
1. Создайте свою учетную запись [Directus Cloud](https://directus.cloud/) и войдите в нее

При первом входе в учётную запись Directus Cloud вам будет предложено создать команду. Каждый проект Directus Cloud существует в рамках одной команды. Они позволяют организовывать работу участников команды, проектов и выставление счетов за проекты по желанию.

2. Создайте новый проект

После запуска создание облачного проекта займёт около 90 секунд. В течение этого времени на адрес электронной почты, связанный с вашей учётной записью Cloud, будет отправлена ссылка. В электронном письме будет указан URL вашего проекта, а также адрес электронной почты и пароль для входа. Если вы использовали GitHub для создания учётной записи, это будет ваш адрес электронной почты GitHub.

3. Получите доступ к вашему новому проекту

Войдите в свой новый проект, используя URL-адрес в папке «Входящие» вашего почтового ящика или на панели управления Directus Cloud.

Узнайте больше о проектах Directus Cloud в нашем [Руководстве пользователя](https://docs.directus.io/user-guide/cloud/projects.html).

### Установка Docker
1. Инициализируйте и запустите новый проект Directus

На вашем компьютере должен быть установлен и запущен Docker. Откройте свой терминал и выполните следующую команду:
```bash
docker run \
-p 8055:8055 \
-e SECRET=replace-with-secure-random-value \
directus/directus
```

2. Получите доступ к вашему новому проекту

Первоначальный адрес электронной почты администратора и пароль будут показаны в терминале. Теперь Directus должен быть доступен по адресу [http://localhost:8055](http://localhost:8055/) или http://127.0.0.1:8055.

Узнайте больше о самостоятельном хостинге Directus в нашей инструкции [по самостоятельному хостингу](#self_hosting_docker).

### Установка NPM
1. Инициализируйте новый проект Directus с помощью командной строки

Замените `<project-name>` именем, которое вы хотите использовать для каталога проекта.
```bash
npm init directus-project@latest <project-name>
```

Следуйте инструкциям, чтобы настроить базу данных и создать первого пользователя-администратора.

2. Начните свой новый проект

Выполните следующие команды, чтобы запустить новый проект локально:
```bash
cd <project-name>
npx directus start
```
Узнайте больше о самостоятельном хостинге Directus в нашем руководстве по [самостоятельному хостингу](https://docs.directus.io/self-hosted/cli.html).

> **Рекомендуется использовать Docker**
> 
> Хотя этот метод работает и поддерживается, он не рекомендуется. Docker устраняет особенности среды, которые могут привести к некорректной работе Directus в некоторых контекстах.
> 
> При запуске Directus без Docker могут возникать ошибки из-за особенностей среды. В таком случае убедитесь, что у вас установлены необходимые системные зависимости для `isolated-vm`, `sharp`, и `argon2`.

### [Назад к оглавлению](#back)


<a id="self_hosting_docker"></a>
## Быстрый запуск для самостоятельного размещения
### Установить Docker
На вашем компьютере должен быть установлен и запущен Docker. Вы можете [скачать его здесь](https://docs.docker.com/get-docker/).

> **Что такое Docker?**
> 
> Docker — это инструмент для разработчиков, который позволяет создателям программного обеспечения распространять свои разработки вместе со всеми зависимостями и необходимыми настройками среды. Это означает, что приложения могут работать надёжно и стабильно, что делает Docker идеальным способом использования Directus как локально, так и в рабочей среде.
> 
> Как только появляются новые версии Directus, мы публикуем их на [Docker Hub](https://hub.docker.com/r/directus/directus).

### Создайте файл Docker Compose
Создайте на рабочем столе новую пустую папку под названием `directus`. Внутри этой новой папки создайте три пустые папки `database`, `uploads`, и `extensions`.

Откройте текстовый редактор, например Visual Studio Code, nano, Vim, TextEdit или Блокнот.

Скопируйте и вставьте следующее и сохраните файл как **docker-compose.yml**:
```yaml
version: "3"
services:
  directus:
    image: directus/directus:11.1.1
    ports:
      - 8055:8055
    volumes:
      - ./database:/directus/database
      - ./uploads:/directus/uploads
      - ./extensions:/directus/extensions
    environment:
      SECRET: "replace-with-secure-random-value"
      ADMIN_EMAIL: "admin@example.com"
      ADMIN_PASSWORD: "d1r3ctu5"
      DB_CLIENT: "sqlite3"
      DB_FILENAME: "/directus/database/data.db"
      WEBSOCKETS_ENABLED: "true"
```

Сохраните файл. Давайте пройдемся по нему пошагово:

- Этот файл определяет один контейнер Docker, который будет использовать указанную версию образа `directus/directus`.
- Список `ports` сопоставляет внутренний порт `8055` с нашим компьютером, используя тот же номер порта, то есть мы можем получить к нему доступ из браузера нашего компьютера.
- Раздел `volumes` сопоставляет внутренние данные `database`, `uploads` и `extensions` с нашей локальной файловой системой, а также с `docker-compose.yml` — то есть данные хранятся и сохраняются за пределами контейнеров Docker.
- В `environment` разделе содержатся любые [переменные конфигурации (configuration variables)](#conf_opt), которые мы хотим установить.
  - `SECRET` требуется и должно быть безопасным случайным значением, которое используется для подписи токенов.
  - `ADMIN_EMAIL` и `ADMIN_PASSWORD` - это исходные учетные данные администратора при первом запуске.
  - `DB_CLIENT` и `DB_FILENAME` определяют подключение к вашей базе данных.
  - `WEBSOCKETS_ENABLED` не требуется, но включает [Directus Realtime](https://docs.directus.io/guides/real-time/getting-started/).

Раздел «Тома» не является обязательным, но без него наша база данных и загруженные файлы будут удалены, когда контейнер Docker перестанет работать. Базой данных по умолчанию является SQLite — автономная бессерверная база данных, которая сохраняет данные в файл.

### Запустите Directus
Откройте терминал и выполните следующие команды по одной строке за раз:
```bash
cd Desktop/directus
docker compose up -d
```
Directus теперь должен быть доступен по адресу http://localhost:8055 или http://127.0.0.1:8055.

### [Назад к оглавлению](#back)


<a id="conf_opt"></a>
## Параметры конфигурации
**Переменные среды** используются для всех настроек в проекте Directus. Эти переменные можно задать несколькими способами, которые мы рассмотрим ниже.

### Файлы конфигурации
По умолчанию Directus будет считывать файл `.env` конфигурации, расположенный рядом с `package.json` вашего проекта (обычно в корневой папке вашего проекта). Вы можете изменить этот путь и имя файла, задав переменную среды `CONFIG_PATH` перед запуском Directus. Например:
```bash
CONFIG_PATH="/path/to/config.js" npx directus start
```

Если вы предпочитаете использовать файл конфигурации вместо переменных среды, вы также можете использовать переменную среды `CONFIG_PATH` для указания Directus использовать локальный файл конфигурации вместо переменных среды. Файл конфигурации может быть в одном из следующих форматов:
- [.env](#env)
- [config.json](#json)
- [config.yaml](#yaml)
- [config.js](#config_js)

<a id="env"></a>
### .env
Если путь к конфигурации не имеет расширения файла или расширение файла не относится к одному из других поддерживаемых форматов, Directus попытается прочитать путь к конфигурации в виде переменных среды `.env`. Структура выглядит следующим образом:
```js
HOST="0.0.0.0"
PORT=8055

DB_CLIENT="pg"
DB_HOST="localhost"
DB_PORT=5432

etc
```

<a id="json"></a>
### config.json
Если вы предпочитаете использовать для конфигурации один файл JSON, создайте файл JSON с переменными среды в качестве ключей, например:
```bash
CONFIG_PATH="/path/to/config.json"
```
```json
{
  "HOST": "0.0.0.0",
  "PORT": 8055,

  "DB_CLIENT": "pg",
  "DB_HOST": "localhost",
  "DB_PORT": 5432

  // etc
}
```

<a id="yaml"></a>
### config.yaml
Как и в случае с JSON, вы можете использовать файл `.yaml` (или `.yml`) для своей конфигурации:
```bash
CONFIG_PATH="/path/to/config.yaml"
```
```yaml
HOST: 0.0.0.0
PORT: 8055

DB_CLIENT: pg
DB_HOST: localhost
DB_PORT: 5432
#
# etc
```

<a id="config_js"></a>
### config.js
Использование файла JavaScript для конфигурации позволяет динамически генерировать конфигурацию проекта во время запуска.

По умолчанию ожидается, что файл будет **ESM**, но также поддерживается **CommonJS** с использованием `.cjs` в качестве расширения файла.

Конфигурация JavaScript поддерживает два разных формата: **структуру объекта**, где ключом является имя переменной среды, или

config.js
```js
export default {
  HOST: '0.0.0.0',
  PORT: 8055,

  DB_CLIENT: 'pg',
  DB_HOST: 'localhost',
  DB_PORT: 5432,

  // etc
};
```

config.cjs
```js
module.exports = {
  HOST: '0.0.0.0',
  PORT: 8055,

  DB_CLIENT: 'pg',
  DB_HOST: 'localhost',
  DB_PORT: 5432,

  // etc
};
```

Или **структура функции**, которая возвращает тот же формат объекта, что и выше. Функция получает `process.env` в качестве параметра.

config.js
```js
export default function (env) {
  return {
    HOST: '0.0.0.0',
    PORT: 8055,

    DB_CLIENT: 'pg',
    DB_HOST: 'localhost',
    DB_PORT: 5432,

    // etc
  };
}
```

config.cjs
```js
module.exports = function (env) {
  return {
    HOST: '0.0.0.0',
    PORT: 8055,

    DB_CLIENT: 'pg',
    DB_HOST: 'localhost',
    DB_PORT: 5432,

    // etc
  };
};
```

### Файлы переменных среды
Любое значение переменной среды можно импортировать из файла, добавив `_FILE` к имени переменной среды. Это особенно полезно при использовании в сочетании с Docker Secrets, чтобы конфиденциальные данные не попадали в файлы compose. Например:
```js
DB_PASSWORD_FILE="/run/secrets/db_password"
```

### Приведение типов и вложенность
Переменные среды автоматически преобразуются в зависимости от структуры переменной, например:
```js
PUBLIC_URL="https://example.com"
// "https://example.com"

DB_HOST="3306"
// 3306

CORS_ENABLED="false"
// false

STORAGE_LOCATIONS="s3,local,example"
// ["s3", "local", "example"]
```

В случаях, когда переменные среды преобразуются в объект конфигурации для использования сторонних библиотек, например в `DB_*` или `REDIS_*`, переменная среды преобразуется в **camelCase**. Для вложенных объектов можно использовать двойное подчёркивание (`__`):
```js
DB_CLIENT="pg"
DB_CONNECTION_STRING="postgresql://postgres:example@127.0.0.1"
DB_SSL__REJECT_UNAUTHORIZED="false"

{
  client: "pg",
  connectionString: "postgresql://postgres:example@127.0.0.1",
  ssl: {
    rejectUnauthorized: false
  }
}
```

### Синтаксический префикс среды
Directus попытается автоматически преобразовать переменные среды в нужный тип на основе контекстных подсказок. Если вам нужен конкретный тип, вы можете указать Directus, какой тип использовать для данного значения, добавив к значению префикс `{type}:`. Доступны следующие типы:

|Синтаксический префикс	|Пример	|Вывод
|-----------------------|-------|-----
|string	|string:value	|"value"
|number	|number:3306	|3306
|regex	|regex:\.example\.com$	|/\.example\.com$/
|array	|array:https://example.com,https://example2.com array:string:https://example.com,regex:\.example3\.com$	|["https://example.com", "https://example2.com"] ["https://example.com", /\.example3\.com$/]
|json	|json:{"items": ["example1", "example2"]}	|{"items": ["example1", "example2"]}

Явное приведение типов также доступно при чтении из файла с суффиксом `_FILE`.

### Общая информация

|Переменная	|Описание	|Значение по умолчанию
|-----------|---------|-------------------
|CONFIG_PATH	|Где находится ваш конфигурационный файл. Смотрите [Файлы конфигурации](#conf_opt)	|.env
|HOST	|IP или хост, к которому подключается API.	|0.0.0.0
|PORT	|Под каким портом запускать API.	|8055
|UNIX_SOCKET_PATH	|Сокет Unix, который прослушивает API, PORT и HOST будут проигнорированы, если они указаны.	|--
|PUBLIC_URL[1]	|URL, по которому можно получить доступ к вашему API в Интернете.	|/
|LOG_LEVEL	|Какой уровень детализации использовать в журнале. Один из fatal, error, warn, info, debug, trace или silent.	|info
|LOG_STYLE	|Отображайте журналы в удобном для чтения человеком (красивом) виде или в формате JSON. Один из вариантов: pretty, raw.	|pretty
|LOG_HTTP_IGNORE_PATHS	|Список путей HTTP-запросов, которые не должны отображаться в журнале, например /server/ping.	|--
|MAX_PAYLOAD_SIZE	|Контролирует максимальный размер тела запроса. Принимает количество байт или удобочитаемую человеком строку.	|1mb
|ROOT_REDIRECT	|Перенаправляет корень приложения / на определенный маршрут. Принимает относительный путь, абсолютный URL или false для отключения.	|./admin
|SERVE_APP	|Обслуживать Data Studio или нет	|true
|GRAPHQL_INTROSPECTION	|Включать или нет самоанализ GraphQL	|true
|GRAPHQL_SCHEMA_CACHE_CAPACITY	|Сколько пользовательских схем GraphQL хранить в памяти	|100
|MAX_BATCH_MUTATION	|Максимальное количество элементов для пакетных изменений при создании, обновлении и удалении.	|Infinity
|MAX_RELATIONAL_DEPTH	|Максимальная глубина при фильтрации / запросе реляционных полей с минимальным значением 2.	|10
|QUERY_LIMIT_DEFAULT	|Ограничение запроса по умолчанию используется, если оно не определено в запросе API.	|100
|QUERY_LIMIT_MAX	|Максимальное ограничение запроса, принимаемое для запросов API.	|-1
|ROBOTS_TXT	|Что должна возвращать /robots.txt конечная точка	|User-agent: *\nDisallow: /
|TEMP_PATH	|Где следует управлять временными файлами Directus	|./node_modules/.directus
|MIGRATIONS_PATH	|Где находятся пользовательские миграции	|./migrations

[1] Значение PUBLIC_URL используется для таких вещей, как перенаправление OAuth, отправка писем с запросом пароля и логотипы, которые должны быть общедоступными в интернете.

> Дополнительные переменные регистратора
> 
> Все LOGGER_* переменные среды передаются в options конфигурацию [Pino экземпляра](https://github.com/pinojs/pino/blob/master/docs/api.md#options). Все LOGGER_HTTP* переменные среды передаются в options конфигурацию [Pino-http экземпляра](https://github.com/pinojs/pino-http#api). В зависимости от потребностей вашего проекта вы можете расширить LOGGER_* переменные среды любой конфигурацией, которую необходимо передать экземпляру регистратора. Если добавлен ключ LOGGER_LEVELS, эти значения будут переданы в заголовок регистратора, как описано, например, [здесь](https://github.com/pinojs/pino/blob/master/docs/help.md#mapping-pino-log-levels-to-google-cloud-logging-stackdriver-severity-levels). Формат для добавления значений LEVELS: `LOGGER_LEVELS="trace:DEBUG,debug:DEBUG,info:INFO,warn:WARNING,error:ERROR,fatal:CRITICAL"`

Подробная информация по **параметрам конфигурации** [находится здесь](https://docs.directus.io/self-hosted/config-options.html).

### [Назад к оглавлению](#back)


<a id="2_create_collect"></a>
## 2. Создайте коллекцию

После входа в систему вам будет предложено создать свою первую [коллекцию](#collections).

1. Перейдите в [модуль содержимого (content module)](#content_module).
2. Нажмите **«Создать коллекцию»**, и появится боковое меню.
3. Введите имя.
Для этой демонстрации мы назовём его `articles`, но вы можете придумать своё!
4. Остальные параметры оставьте по умолчанию. Нажмите значок со стрелочкой и откроется меню **"Дополнительные поля"**.
5. Пока оставьте значения в этом меню по умолчанию, отключив их. Вы сможете изменить их позже.
Нажмите значок галочки (ok) в заголовке меню.

### [Назад к оглавлению](#back)


<a id="collections"></a>
## Коллекции (Collections)
**Коллекции** — это контейнеры для определённых типов элементов, которые содержат любое количество полей. Каждая коллекция представляет собой **таблицу** в вашей **базе данных**. По умолчанию [форматировщик заголовков](https://docs.directus.io/user-guide/overview/glossary.html#title-formatter) используется для отображения любых существующих названий таблиц базы данных в виде удобочитаемых заголовков коллекций. Существуют также «папки»-коллекции, которые [используются исключительно в организационных целях](https://docs.directus.io/app/data-model#sorting-grouping) и сами по себе не содержат никаких данных.

Коллекции могут быть организованы любым способом, подходящим для вашего проекта. Вы можете спроектировать их с учётом конкретной платформы (например, *страницы* веб-сайта) или без привязки к платформе (например, *клиенты* вашей компании). Хотя не существует правильного или неправильного способа структурировать модель данных, мы рекомендуем по возможности сохранять независимость данных, чтобы их было проще использовать в будущем. **Короче говоря, научитесь рассматривать свои данные как самостоятельный актив, а не только через призму текущих потребностей вашего проекта**.

Единственное требование к коллекции заключается в том, что она должна содержать поле [первичного ключа](#permissions). В этом поле хранится уникальное значение, которое используется для ссылки на элементы коллекции в базе данных/на платформе.

Соответствующие руководства
- [Создание коллекции](https://docs.directus.io/app/data-model.html#sorting-grouping)
- [Настройка коллекции]()
- [Удаление коллекции]()
- [Настройка макета коллекции]() 

### [Назад к оглавлению](#back)


<a id="elements"></a>
## Элементы
**Элементы** — это объекты в составе коллекции, которые содержат значения для одного или нескольких [полей](#fields). Каждый элемент представляет собой **запись** в вашей **базе данных**.

Элементы — это основные строительные блоки контента вашего проекта. Подобно «строкам» в электронной таблице, все данные на платформе доступны через эти «атомарные» единицы данных. Сами по себе элементы довольно просты, однако их реальная сила заключается в сложности, которая начинает проявляться, когда элементы связаны друг с другом.

Элементы ссылаются (как индивидуально, так и в совокупности) на свой уникальный [первичный ключ](#permissions).

Соответствующие руководства:
- [Создание элемента]()
- [Архивирование элемента]()
- [Сортировка элементов вручную]()
- [Удаление элемента]()

### [Назад к оглавлению](#back)


<a id="fields"></a>
## Поля
**Поля** — это особый тип значений в коллекции, в которых хранятся данные о содержимом вашего элемента. Каждое поле представляет собой **столбец** в вашей **базе данных**. 

Например, `articles` [коллекция](#collections) может содержать поля `title`, `body`, `author` и `date_published`. Поля отражают характеристики связанного с ними столбца, включая его `name`, `type`, `default`, `length`, `allow_null` и т. д.

Соответствующие руководства
- [Создание поля]()
- [Дублирующие поля]()
- [Корректировка расположения полей]()
- [Удаление полей]()

### [Назад к оглавлению](#back)

<a id="permissions"></a>
## Разрешения (Permissions)
Разрешения привязываются непосредственно к политике и определяют, что пользователь может создавать, читать, обновлять и удалять на платформе. Эти разрешения на основе фильтров обеспечивают очень детальный контроль доступа ко всей системе.

### [Назад к оглавлению](#back)

<a id="data_model"></a>
### Модель данных (Data model)
Студия данных Directus позволяет настраивать и управлять любой базой данных SQL без программирования, без каких-либо ограничений на создание модели данных. Вы получаете контроль над конфигурацией таблиц, столбцов и связей, а также над тем, как пользователи просматривают данные и взаимодействуют с ними в студии данных.

> Узнать больше
> 
> Помните, что у вас будет полный доступ к управлению базой данных с помощью SQL. Directus будет отражать любые изменения. Вы также можете настроить свою модель данных программно с помощью API. Чтобы узнать больше, ознакомьтесь с нашей документацией по API для [коллекций](https://docs.directus.io/reference/system/collections.html), [полей](https://docs.directus.io/reference/system/fields.html) и [связей](https://docs.directus.io/reference/system/relations.html).

Реляционные модели данных
Чтобы понять, как Directus работает с моделями данных, вам нужно знать, что такое реляционные модели данных. В этом разделе представлен краткий обзор основных концепций. Он может быть полезен в качестве обзора или для бизнес-пользователей, работающих в вашей команде, которым нужно простое объяснение того, как работают модели данных. Если вы хорошо разбираетесь в концепциях реляционных моделей данных, таких как базы данных, таблицы данных, столбцы, типы данных, первичные и внешние ключи, строки, связи и схемы, то можете сразу перейти к разделу [«Модели данных в Directus»](#data_mod_directus).

Базы данных
Directus — это оболочка для базы данных SQL. База данных — это набор структурированных данных, хранящихся на компьютере, что делает их организованными, доступными и масштабируемыми. Конкретный способ структурирования данных в базе данных называется моделью данных.

![Схема базы данных](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/database-schema-20220805A.webp)

### База данных против Excel
Для сравнения, с которым может согласиться большинство бизнес-пользователей, хранение данных в базе данных чем-то похоже на хранение данных в таблицах Excel. Вы знаете, как можно создать таблицу на одном листе в Excel, создать другую таблицу на другом листе, а затем связать строки каждой таблицы между собой? Именно так работает реляционная модель данных. Но есть несколько ключевых моментов, в которых Excel и реляционные базы данных отличаются.

![Данные в электронной таблице Excel](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/spreadsheet-20220805A.webp)

Часто мы сохраняем данные в виде таблицы в Excel, но это не всегда так, поскольку программа служит множеству других целей. Excel позволяет стилизовать данные (выделять жирным шрифтом, курсивом, цветом, использовать пользовательские шрифты и т. д.), устанавливать динамические функции в ячейках, добавлять графику, например диаграммы и графики, а также вводить любые данные в любую ячейку без принудительной структуры. Ваша электронная таблица Excel — это чистый холст, предназначенный для хранения десятков тысяч строк информации.

![Таблица данных](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/datatable-20220805A.webp)

В базах данных нет стилизации. Они хранят только необработанные значения данных в структурированном виде. Каждый раз, когда вы хотите стилизовать данные, создать функцию, отобразить данные на графике и т. д., вы должны создать эту функцию в своём приложении или на веб-сайте. Базы данных хранят необработанные, нестилизованные, структурированные данные и предназначены для обработки миллионов а в некоторых случаях *миллиардов и триллионов* строк информации.

<a id="data_table"></a>
### Таблицы данных
![Таблица данных: строки и столбцы](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/rows-and-columns.webp)

Базы данных SQL хранят данные в таблицах. В таблицах данных обычно хранится информация об одном конкретном типе записей, объектов или наблюдений, таких как финансовые операции, публикации в блогах, географические координаты, пользователи, события Интернета вещей или *что-либо ещё*. Таблицы данных далее делятся на столбцы и строки.

<a id="rows"></a>
### Столбцы
![Столбец](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/columns-20220805A.webp)

Столбцы — это категории, в которых хранится один вид информации. Каждый столбец имеет уникальное описательное название и хранит одну единицу информации в каждой из своих ячеек. Столбцы обеспечивают организованность, согласованность и удобный доступ к данным. Столбцы, которые вы решите добавить в таблицу данных, будут полностью зависеть от информации, которую вам нужно хранить.

### Значения ячеек
![Значения ячеек](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/datatable-cell-value-20220805A.webp)

Каждое значение в столбце хранится в отдельной ячейке. Как правило, вы хотите создавать столбцы, в которых сохраняются атомарные значения. Это означает, что вы создаёте столбец для хранения наименьших неделимых единиц. Нет ограничений на типы информации, которые можно включать в столбец, но есть хорошие и плохие практики. Например:
- Неверный столбец: `city_state_zipcode`.
- Подходящие столбцы: отдельные `city`, `state` и `zipcode` столбцы.

### Типы данных
Для дальнейшего поддержания структуры и согласованности при создании столбца необходимо также определить его тип данных. Например, столбцу `age` может быть присвоен тип данных `INTEGER` или `blog_content` столбцу может быть присвоен тип данных `STRING` или `TEXT` . Существует множество несоответствий, неожиданных и потенциально опасных ситуаций, которые могут возникнуть, когда программа пытается обработать данные с неправильным типом.

Чтобы привести пример, если вы введете символ `2`, он может быть сохранен как `INTEGER` или как `STRING`. Если вы сохранили данные `2` как `INTEGER`, то при попытке добавления `2 + 2` компьютер обычно производит вычисления `4`. В некоторых языках, если вы сохранили символ `"2"` как a `STRING`, при попытке добавления `"2" + "2"` компьютер объединит их в `22`, в то время как в других попытка сделать это может привести к сбою программы!

Поэтому при работе с данными важно знать их тип, потому что неправильный тип данных может привести к неожиданным и даже опасным последствиям в вашей программе.

### Строки
![Строки](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/row-20220805A.webp)

В каждой строке хранятся данные, связанные с уникальной записью, событием, объектом, субъектом, наблюдением и т. д. Таблицы данных могут содержать миллионы, даже *миллиарды и триллионы* строк данных.

### Первичные ключи
![Первичный ключ](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/primary-keys-20220805A.webp)

Чтобы однозначно идентифицировать и отслеживать каждую строку, в каждой таблице данных должен быть столбец с первичным ключом. Первичный ключ — это уникальный идентификатор, который идентифицирует конкретную строку. Для создания первичных ключей можно использовать любой шаблон или систему, если они гарантируют уникальность каждого ключа. Пожалуй, наиболее распространённым является инкрементное увеличение целых чисел, при котором первичный ключ каждой новой строки увеличивается следующим образом: `1`, `2`, `3`, `4` и т. д. Столбец с первичным ключом гарантирует, что вы всегда сможете найти строку и отличить её от других строк.

### Внешние ключи
![Внешние ключи](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/foreign-keys-20220805A.webp)

Поскольку первичные ключи однозначно идентифицируют каждую строку в таблице данных, они являются идеальным инструментом для создания связей. Если вы хотите связать строки между двумя таблицами данных, вы создаёте столбец для хранения *внешних ключей*, которые являются просто первичными ключами из внешней таблицы. Такой столбец называется *столбцом внешнего ключа*, так как в нём хранятся ключи из внешней таблицы.

### Родительские таблицы против Связанных
Когда мы говорим о двух связанных таблицах, мы называем их *родительской таблицей* и *связанной таблицей*. Эти два термина основаны исключительно на точке зрения, подобно терминам *этот* и *тот* или *здесь* и *там*, обозначающим точку зрения, с которой вы смотрите на взаимосвязь.

Например, в модели данных **связь «многие ко многим»** — это то же самое, что и связь **«один ко многим»**. Используемый термин зависит от того, какую коллекцию вы считаете родительской.

<a id="relation_types"></a>
### Типы взаимосвязей
Существует несколько способов реляционной связи таблиц:

1. **One to One (1:1):**  
Для каждой строки в родительской таблице может соответствовать максимум одна строка в связанной таблице. Это означает, что существует строго определенная пара между строками двух таблиц.  
**Пример:** Таблица `пользователи` и таблица `профили`. Каждому пользователю может соответствовать только один профиль, и каждый профиль принадлежит только одному пользователю.

2. **Many to One (M:1):**  
Многие строки в родительской таблице могут ссылаться на одну строку в связанной таблице. В таких отношениях родительская таблица содержит внешний ключ, который соответствует первичному ключу в связанной таблице.   
**Пример:** Таблица `заказы` и таблица `клиенты`. Несколько заказов могут относится к одному и тому же клиенту.

3. **One to Many (1:N):**  
Каждая строка в таблице данных может ссылаться на множество строк в другой таблице. Это обратное отношение к **Many to One**.   
**Пример:** Таблица `авторы` и таблица `книги`. Один автор может написать несколько книг.   

**Примечание по 1:N и M:1:**   
**Идентичность:** В модели данных отношения **One to Many** и **Many to One** по своей сути идентичны и различаются только с точки зрения перспективы. Они представляют одну и ту же связь, но с разных точек зрения.

4. **Many to Many (M:M):**   
Строки в родительской таблице могут ссылаться на множество строк в связанной таблице и наоборот. Для реализации таких отношений используется третья, **посредническая таблица** (иногда называется **таблицей связей** или **соединительной таблицей**).   
**Пример:** Таблица `студенты` и таблица `курсы`. Один студент может записаться на несколько курсов, и один курс может быть изучен несколькими студентами. **Посредническая таблица `записи_на_курсы`** будет хранить пары `студент-курс`.

5. **Many to Any: (M:A)**   
Это более сложный вид отношения, в котором многие строки из таблицы данных могут связываться со строками из **любой другой таблицы в базе данных**. Это, по сути, расширение **M2M**, где добавляется колонка для хранения имени связанной таблицы.   
**Пример:** Таблица `теги`, которая используется для связи с различными таблицами (`статьи`, `видео`, `фото`). В **посреднической таблице** будет храниться указание на **идентификатор тега**, **идентификатор элемента** и **тип элемента** (например, статья или видео).

**Many to Any** может усложнять модель данных и доступ к данным, так как требует учета динамики связей и понимания структуры данных. Это часто применяется в системах, где требуется высокая степень гибкости в связи объектов между собой.

Чтобы узнать больше о том, как эти отношения работают концептуально, а также о том, как они обрабатываются в Directus, ознакомьтесь с нашим руководством по [отношениям](https://docs.directus.io/app/data-model/relationships).

### Схемы баз данных
![Преобразование таблицы данных в схему](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/datatable-to-schema-20220805A.webp)

В приведённых выше примерах мы рассмотрели и описали реальные [таблицы данных](#data_table). При разработке модели реляционных данных вам потребуется создать схему, чтобы отслеживать её сложность.

**Схема** — это план вашей модели данных, который определяет таблицы данных, столбцы в каждой таблице, сведения о каждом столбце и связи между таблицами. Она не включает в себя фактические данные, которые хранятся. Вот простая схема двух связанных таблиц:
```sql
table_one
- column1 (primary key)
- column2 (data type, тип данных, при необходимости объясните, что хранит столбец)
- column3 (...)
```
```sql
table_two
- column1 (primary key)
- column2 (...)
- column3 (...)
- table_one_id (foreign key, внешний ключ, реляционно связывает строки через table_one.column1)
```
В приведённой выше схеме мы определили две таблицы с явно общими именами `table_one`, `table_two` и `column1`, `column2` и т. д. Имена, которые вы выбираете для таблиц и столбцов, зависят от вас. В идеале следует выбирать уникальные, запоминающиеся имена, которые идентифицируют хранящиеся в них данные.

В этой документации мы отступаем от правил традиционных схем баз данных двумя способами: 
- Во-первых, мы иногда добавляем подробное описание того, что представляет собой столбец. Обратите внимание, что в `table_one.column2` после названия столбца `(data type, при необходимости....` - есть примечание. Обычно в схеме таблицы указывается тип данных столбца, но не его полное описание. 
- Во-вторых, в наших примерах, если в таблице есть столбцы, но их тип данных или другие сведения не имеют отношения к текущему этапу обучения, мы опускаем их, чтобы вы могли сосредоточиться на важных столбцах.

Пожалуйста, обратите внимание, что в более сложных схемах, содержащих десятки *(а может быть, и сотни!)* связанных между собой таблиц данных, вы обычно указываете информацию о типах данных, а также визуализируете взаимосвязь между всеми таблицами.

![Сложная схема](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/complex-schema.webp)

<a id="data_undouble"></a>
### Избегайте дублирования данных
Реляционные базы данных позволяют создавать модели данных, которые позволяют **избежать дублирования данных**, то есть когда одни и те же данные хранятся в нескольких местах в базе данных. Дублирование данных неэффективно и опасно.

Для примера рассмотрим таблицу `blog` . В блоге вы можете захотеть отобразить информацию об авторе, поэтому вы добавляете столбец `author_name`.
```sql
blog
- id
- title
- content
- author_name (string, строка, хранит полное имя автора)
```

В таблице выше имя автора хранится непосредственно в таблице `blog`. Однако давайте представим, что вместе с нашими публикациями в блоге мы хотим отображать больше информации об авторах, например их адреса электронной почты, страницы в социальных сетях и т. д. Мы могли бы поместить эту информацию об авторах в таблицу `blog`.
```sql
blog
- id
- title
- content
- author_name (string, строка, хранит полное имя автора)
- author_email (string, строка, хранит адрес электронной почты автора)
- author_img (string, строка, хранит ссылку на изображение профиля автора)
```
Возможно, вы начинаете замечать, что эта таблица данных больше не представляет собой один объект, а состоит из двух: постов в блоге (title, content) и авторов (author_...). Это почти *всегда* признак того, что данные следует разделить на разные таблицы и связать их отношениями.

Теперь давайте представим, что авторы — это один из типов пользователей. Все сведения о пользователях хранятся в таблице `users`, и эти данные отображаются на странице профиля каждого пользователя, в чате и при других типах транзакций. *Это распространённая ситуация во многих проектах.* В этом случае имя автора и другие сведения также должны храниться в `users` таблице.

![Дублирующиеся данные](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/duplicate-data-20220829A.webp)

Это создает дублирующиеся данные. С этим связаны две большие проблемы:  

Во-первых, становится сложно или невозможно поддерживать точность информации. Если автор решит изменить информацию о себе в социальных сетях, `users` кому-то придётся просмотреть и обновить данные автора в каждой строке, содержащей его публикации в блоге. Если публикаций всего 10 или даже 100, это будет раздражать, но, возможно, не станет серьёзной проблемой. Однако, когда объём данных вырастает до миллионов или миллиардов строк, обновление дублирующихся данных становится серьёзной проблемой.

Кроме того, ошибка в имени автора и его личной информации может быть не такой уж опасной, но неточная информация может привести к катастрофе в таблицах данных, содержащих банковские операции или медицинские записи!

Во-вторых, это приводит к пустой трате места для хранения и снижает производительность. При наличии модели данных, содержащей несколько сотен постов в блоге, дублирующиеся данные могут занимать недостаточно места, чтобы сильно снизить производительность. Но опять же, если одна и та же информация повторяется снова и снова в миллионах или миллиардах строк, место для хранения расходуется впустую в огромных масштабах.

### Почему Мы используем реляционные модели данных
Как показано в предыдущем разделе, вы хотите убедиться, что каждая точка данных уникальна. Именно здесь в игру вступает *реляционная* часть реляционных моделей данных. Чтобы избежать дублирования данных, всегда рекомендуется *нормализовать модель данных*. Это технический термин, используемый для описания проектирования модели данных таким образом, чтобы в ней вообще не было дублирующейся информации. 

Вместо того, чтобы хранить всю информацию, необходимую в конкретной ситуации, в одной таблице, как мы видели выше, когда смешивали информацию о блоге и авторе, **нормализация базы данных — это процесс разделения** этой информации по таблицам и связывания их между собой, чтобы информация никогда не повторялась.

Чтобы освоить нормализацию баз данных, нужно многому научиться, и подробное описание этой практики выходит за рамки данного документа. В интернете есть множество ресурсов, где можно узнать об этом. Однако приведем один простой пример, улучшив таблицу `blog`, приведенную в предыдущем разделе [«Избегайте дублирования данных»](#data_undouble):
```sql
blog
- id
- title
- content
- author_name
- author_email
- author_img
```

Как описано в разделе о [столбцах](#rows), мы хотим, чтобы каждая строка в таблице данных представляла собой одну уникальную запись, событие, объект, сущность, наблюдение и т. д. Для этого мы можем удалить столбец `author_name` из таблицы `blog` и заменить его столбцом `author_id` внешнего ключа, в котором хранятся внешние ключи из таблицы `users`.
```sql
blog
- id
- title
- content
- author_id (хранит внешний ключ из user.id)
```
```sql
users
- id
- name
- email
- role
- email
- twitter
```
Обратите внимание на разницу. Ранее мы помещали имя автора непосредственно в столбец таблицы данных `blog` *(создавая дубликаты данных)*. Здесь мы заменили `author_name`, `author_email` и `author_img` на столбец `author_id`, который содержит внешние ключи из `users`. Теперь мы можем использовать внешний ключ для связи данных между `blog` и `users`.

### Работа с реляционными моделями данных
![База данных, Серверная часть, Интерфейс](https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/database-backend-frontend-20220805A.webp)

После того как вы концептуально разработали свою модель данных, вы обычно создаёте её и взаимодействуете с ней с помощью **SQL**, или языка структурированных запросов. Этот язык используется для создания, чтения и запроса, обновления и удаления любых данных в базе данных.

После того как первоначальные таблицы данных спроектированы и созданы, следующим шагом обычно является создание серверной части с помощью таких инструментов, как Node.js или Flask. В серверной части вы должны написать собственные конечные точки API и логику для создания, чтения, запроса, обновления и удаления данных для вашей конкретной модели данных. Однако, когда серверная часть обращается к данным, они по-прежнему являются необработанными, без стилизации. С необработанными данными легко работать компьютерам, но зачастую довольно сложно людям.

Для тех, кто не знаком с языком SQL, необработанными данными и традиционным жаргоном реляционных баз данных, он может показаться неинтуитивным и слишком техническим.

Возможно, нецелесообразно обучать всех членов команды работе с необработанными данными и мышлению в терминах необработанных данных. В некоторых случаях бизнес-пользователям может быть сложно или практически невозможно работать с необработанными данными. Люди привыкли видеть информацию, отображаемую в цвете, стилизованную, встроенную в карту и т. д. Например, большинству людей в большинстве ситуаций было бы легко работать с точками на карте, но практически невозможно определить местоположение на карте мира по необработанным точкам широты и долготы, сохранённым в формате JSON.
```json
json
{
  "location": {
    "lat": 36.08801,
    "lng": 120.379771
  }
}
```

Поэтому разработчикам необходимо создавать интерфейсные части с продуманными пользовательскими интерфейсами и пользовательской логикой отображения, чтобы сделать работу с данными удобной для человека. Однако даже для разработчиков с хорошими навыками работы с базами данных SQL создание API и пользовательских интерфейсов для построения модели данных и управления ею требует много времени.

<a id="data_mod_directus"></a>
### Модели данных в Directus

<video controls src="https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/data-model-overview-20220805A.mp4" title="Title"></video>

Все концепции реляционной модели данных, перечисленные выше, применимы в Directus. Вы получаете полную, не зависящую от мнения разработчика, реляционную модель данных и её конфигурацию. Разница в том, что Directus обрабатывает все запросы SQL, создаёт API и предоставляет **Data Studio**, которая позволяет бизнес-пользователям работать с данными удобным для человека способом.

**Data Studio** также предлагает функции и возможности для интуитивно понятного отображения данных и взаимодействия с ними. После настройки модели данных они становятся доступными в других [модулях](#layouts1).

Вы можете делать следующее без единой строчки кода или SQL-запроса:
- Просматривайте, настраивайте свою реляционную модель данных и хранилище активов и управляйте ими.
- Настройте способ отображения данных в D**ata Studio**.
- Настройте способ взаимодействия пользователей с данными в **Data Studio**.
- Переводите любой текст в **Data Studio** на любой язык.  

Directus заменяет традиционный жаргон реляционных баз данных более удобными для пользователя терминами и понятиями. Пожалуйста, имейте в виду, что в то время как традиционный жаргон реляционных баз данных строго соответствует понятиям баз данных, некоторые из новых терминов Directus охватывают эти понятия реляционных баз данных плюс логику отображения и взаимодействия. В следующих разделах мы познакомимся с терминами Directus и сопоставим их с классическими понятиями реляционных баз данных.

### Коллекции
<video controls src="https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/collections-20220805A.mp4" title="Title"></video>
Коллекция представляет собой **набор элементов**. Здесь может быть сопоставление 1:1 с таблицей данных в SQL, группой других коллекций или представлением только для чтения.

Вы получаете доступ ко всем коллекциям, включая встроенные системные коллекции, необходимые для работы вашего проекта, в разделе **Настройки> Модель данных**. Оттуда щелкните коллекцию, чтобы открыть страницу ее конфигурации. Чтобы узнать больше, ознакомьтесь с нашим [руководством по коллекциям](https://docs.directus.io/app/data-model/collections).

Поля

<video controls src="https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/fields-20220805A.mp4" title="Title"></video>

Поля - это столбцы базы данных, но с изюминкой.

Помните, что в столбцах базы данных SQL хранятся только необработанные данные. На их основе разработчики создают пользовательскую логику и пользовательские интерфейсы, чтобы определить, как эти данные отображаются и с ними взаимодействуют. В Directus поля включают в себя конфигурации столбцов, а также пользовательские настройки для отображения данных и взаимодействия с ними в Data Studio. В Directus также есть [псевдонимы](https://docs.directus.io/user-guide/overview/glossary.html#alias) полей, которые являются виртуальными и не соответствуют напрямую столбцам. Чтобы узнать больше, ознакомьтесь с нашим [руководством по полям](https://docs.directus.io/app/data-model/fields.html).

### Элементы (Items)

<video controls src="https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/items-20220805A.mp4" title="Title"></video>

Элементы представляют собой строки таблицы данных, но с изюминкой.

Как мы уже говорили выше, идеальная реляционная база данных нормализована. К сожалению, нормализованные данные не всегда легко представить, потому что связанные данные распределены по нескольким таблицам. Поэтому, когда вы обращаетесь к элементу, вы можете получить больше, чем просто данные на уровне строк текущей коллекции. В некоторых случаях элемент может *предоставлять доступ к данным в связанных строках*.

Вы получаете доступ к элементам из других модулей приложения, таких как [«Содержимое» (Content)](#content_module), [«Каталог пользователей»](https://docs.directus.io/user-guide/user-management/user-directory.html) и [«Библиотека файлов»](https://docs.directus.io/user-guide/file-library/files.html).

Надмножество типов данных
Directus абстрагирует различия в типах данных между поставщиками SQL с помощью [расширенного набора типов данных](https://docs.directus.io/user-guide/overview/glossary#data-type-superset).

### Ключи и идентификаторы

<video controls src="https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/keys-and-ids-20220805A.mp4" title="Title"></video>

Первичные ключи в Directus довольно часто называют идентификаторами. При [создании коллекции](https://docs.directus.io/app/data-model/collections.html#create-a-collection) необходимо добавить `id` поле. Directus поддерживает следующие типы идентификаторов:

- Автоматически увеличивающееся целое число — идентификаторы увеличиваются на `1`, `2`, `3` до `2^31-1` или `2,147,483,647`.
- Автоматически увеличивающиеся большие целые числа — идентификаторы увеличиваются на `1`, `2`, `3` до `2^63-1` или `9,223,372,036,854,775,807`. (*доступно только в MySQL и PostgreSQL*)
- Сгенерированный UUID — универсальный уникальный идентификатор. Создает абсолютно уникальный идентификатор. Идентификаторы, сгенерированные с помощью этой системы (не только в вашей базе данных, но и везде, где используется эта система), настолько статистически маловероятны, что с практической точки зрения они уникальны.
- Строка, введённая вручную — вы вручную вводите уникальную строку в качестве идентификатора для каждого элемента.

### Взаимосвязи

<video controls src="https://cdn.directus.io/docs/v9/configuration/data-model/data-model-20220805/relationships-20220805A.mp4" title="Title"></video>

Directus поддерживает все стандартные [типы связей](#relation_types), а также несколько собственных составных типов. Чтобы узнать больше, ознакомьтесь с нашим [руководством по связям](https://docs.directus.io/app/data-model/relationships).



### [Назад к оглавлению](#back)


<a id="content_module"></a>
## Модуль содержимого (Content module)

**Модуль контента** — это основной способ взаимодействия пользователей с элементами в коллекции. Независимо от того, что содержит ваша модель данных *(будь то публикации в блоге, бронирование мероприятий, IoT-устройства, географические координаты, CRM или что-то ещё!)*, модуль контента позволяет просматривать и управлять данными, сортировать и искать их, а также импортировать и экспортировать.

>**Прежде чем вы начнете**
>
>Глубокое понимание [коллекций](#collections), [элементов](#elements) и [полей](#fields) поможет вам эффективно использовать модуль «Контент».

### Страница коллекции
![collect](https://cdn.directus.io/docs/v9/app-guide/content/content/content-20220415A/collection-page-20220415A.webp)

Модуль контента состоит из страниц коллекций и страниц элементов. Для перехода между коллекциями используйте панель навигации слева. 

На каждой странице коллекции отображаются все элементы коллекции, и она содержит настраиваемые [макеты](#layouts) для просмотра, визуализации и управления элементами. В заголовке страницы есть кнопки для сортировки, поиска, фильтрации, создания, редактирования, архивирования и удаления нескольких элементов. Чтобы узнать больше, ознакомьтесь с нашим руководством по [страницам коллекций](#collection_page).

> СОВЕТ
> 
> Модуль «Контент» помогает управлять элементами. Коллекции управляются в меню «Настройки», поскольку эти действия приводят к изменениям в модели данных. Чтобы узнать больше, ознакомьтесь с нашим руководством по [настройке модели данных]().

### Страница товара (item page)
![item](https://cdn.directus.io/docs/v9/app-guide/content/content/content-20220415A/item-page-20220215A.webp)

При нажатии на элемент на странице «Коллекция» откроется страница элемента. Страница элемента — это форма, которая позволяет просматривать, редактировать или удалять элемент и значения его полей. С помощью этой формы вы также можете комментировать, делиться, архивировать или возвращать элемент. Чтобы узнать больше, ознакомьтесь с нашим руководством по [странице элемента](https://docs.directus.io/user-guide/content-module/content/items).

### Общий доступ

В любом проекте некоторые коллекции будут иметь ограниченный доступ. В некоторых случаях вам может потребоваться поделиться одним из элементов коллекции с отдельным пользователем или группой пользователей, у которых еще нет доступа. В этом случае используйте общий доступ. Общий доступ позволяет поделиться элементом коллекции с любым пользователем, независимо от его прав, даже если он не является участником проекта. Чтобы узнать больше, ознакомьтесь с нашим руководством по [обмену данными](https://docs.directus.io/user-guide/content-module/content/shares).

### [Назад к оглавлению](#back)


<a id="layouts"></a>
## Макеты (layouts)
Макет определяет, как вы просматриваете коллекцию или взаимодействуете с ней. В большинстве случаев он позволяет просматривать элементы на основе определенного типа данных, но также может использоваться для визуализации данных или взаимодействия с ними. Directus включает в себя несколько готовых макетов с различными функциями и параметрами конфигурации:
- Таблица — работает с данными любого типа, отображая элементы в виде строк, а их поля — в виде столбцов.
- Карты — идеально подходят для отображения графических данных. В этом макете элементы отображаются в виде сетки из графических карт.
- Календарь — идеально подходит для «временных» данных, отсортированных по дате или времени.
- Карта — идеально подходит для «геопространственных» данных, отображаемых на карте мира.

![alt text](https://marketing.directus.app/assets/75900b67-a908-42fa-9bd3-de259c797cac.png)

<a id="layouts1"></a>
В дополнение к этим базовым макетам пользовательские макеты позволяют создавать более персонализированные или уникальные способы представления данных в приложении, например, диаграммы Ганта, карты рассадки или электронные таблицы.

### [Назад к оглавлению](#back)


<a id="collection_page"></a>
## Страница коллекции
На странице «Коллекция» отображаются все элементы коллекции, а также настраиваемые макеты для просмотра, визуализации и управления этими элементами.

> **Прежде чем вы начнете**
> 
> Чтобы использовать страницу «Коллекции», вам нужно знать о [коллекциях](#collections), [элементах](#elements) и [полях](#fields).

### Переключение скрытых коллекций

В некоторых проектах могут быть десятки или даже сотни коллекций, и разобраться в них может быть непросто. Чтобы упростить эту задачу, администраторы могут скрыть [коллекции по умолчанию](https://docs.directus.io/app/data-model/collections.html#toggle-collection-visibility) на панели навигации. Затем пользователи могут показывать или скрывать скрытые коллекции по своему усмотрению. Чтобы изменить видимость коллекции, выполните следующие действия: 
1. Перейдите к модулю содержимого.
2. Щелкните правой кнопкой мыши на панели навигации.
3. Нажмите Показать / Скрыть скрытые коллекции, чтобы переключить видимость.

> СОВЕТ
> 
> Эта функция носит чисто эстетический характер и предназначена для визуальной очистки панели навигации. Для администраторов, которые хотят заблокировать доступ пользователей, см. [«Пользователи, роли и разрешения»](https://docs.directus.io/user-guide/user-management/users-roles-permissions.html).

### Настройка макета страницы
[ ... ]
---

### [Назад к оглавлению](#back)


<a id="3_field_create"></a>
## 3. Создайте поле

После создания вашей первой коллекции пришло время добавить несколько [полей](#fields).

1. Перейдите в **Модуль настроек (Settings)**> **Модель данных (Data model)**> `Collection-Name`.
2. Нажмите кнопку **«Создать поле» (Create field)** и выберите тип поля **«Ввод» (Input)**.
3. Введите название поля в поле **«Ключ» (Key)**. Мы назовем наше поле `title`.  
Directus предлагает широкие возможности настройки полей, но пока давайте воспользуемся настройками по умолчанию.
1. Выберите **"Сохранить"**.  

### [Назад к оглавлению](#back)


<a id="4_el_create"></a>
## 4. Создайте элемент
Теперь, когда у нас есть коллекция с настроенным **полем**, пришло время добавить **элемент**.

1. Перейдите к **модулю содержимого (Content module)**.
2. Нажмите **значок с плюсом (add)** в заголовке страницы, чтобы открыть страницу элемента.
3. Заполните значения полей по желанию.
4. Нажмите **значок с галочкой (check)** в правом верхнем углу, чтобы сохранить ваш элемент.

### [Назад к оглавлению](#back)


<a id="5_access_setup"></a>
## 5. Настройка ролей и разрешений

Directus поставляется с двумя встроенными ролями: **«Публичный»** и **«Администратор»**. 
- Роль **«Публичный»** определяет, какие данные будут возвращаться пользователям, не прошедшим аутентификацию. В роли «Публичный» все разрешения отключены, и ее можно перенастроить с помощью детального контроля, чтобы показывать только то, что вы хотите, чтобы видели пользователи, не прошедшие аутентификацию. 
- Роль **«Администратор»** имеет полные разрешения, и их нельзя изменить. 

Помимо этих встроенных ролей, можно создать любое количество новых ролей с полностью настраиваемыми, детализированными разрешениями.

По умолчанию контент, загруженный в Directus, считается **конфиденциальным**. Поэтому разрешения по умолчанию всегда устанавливаются на **«Нет доступа»** с возможностью полной настройки по желанию. 

Итак, чтобы **API** возвращало наши [элементы](#elements), давайте добавим некоторые разрешения на чтение. Для простоты мы сделаем это для **общедоступной** роли, а не создадим новую роль.

1. Перейдите в **Модуль настроек** > **Управление доступом** > **Общедоступный (Public)**.
2. Нажмите block под значком visibility нужной коллекции.
3. В нашем случае название коллекции — articles.
4. Нажмите «Полный доступ», чтобы предоставить общедоступной роли полные права на чтение элементов в этой коллекции.

> **Узнайте больше о ролях и разрешениях**
> 
> [Пользователи, роли и разрешения](https://docs.directus.io/user-guide/user-management/users-roles-permissions).

### [Назад к оглавлению](#back)


<a id="6_api_connect"></a>
## 6. Подключение к API
Теперь, когда в вашем проекте есть контент, доступный для общественности, пришло время начать использовать его вне проекта! Доступ к данным можно получить несколькими способами, в том числе с помощью конечных точек REST и GraphQL API. В этом случае мы будем использовать /items/ конечную точку REST API для получения только что созданного элемента.

Откройте http://your-project-url.directus.app/items/articles в своем браузере.

*И вот оно! Только что созданный вами элемент статьи представлен в красивом формате JSON, готовом к использованию где угодно и когда угодно!*
```json
{
  "data": [
    {
      "id": 1,
      "title": "Hello World!"
    }
  ]
}
```
*В этом примере мы отправили очень простой запрос на чтение с помощью API, но это ещё не всё! **API REST** и **GraphQL** предоставляют исчерпывающий набор конечных точек для модели данных, и каждое действие, которое вы можете выполнить в приложении, можно выполнить с помощью API. По сути, приложение — это просто графический интерфейс, работающий на базе API.*

> Узнайте больше об API
> 
> [Введение в API](https://docs.directus.io/reference/introduction)
> 
> [JavaScript SDK](https://docs.directus.io/guides/sdk/getting-started)

### [Назад к оглавлению](#back)


<a id="api_reference"></a>
## Рекомендации по API
Directus предлагает **REST API** и **GraphQL** для управления данными в базе данных. API имеет предсказуемые URL-адреса, ориентированные на ресурсы, использует стандартные коды состояния HTTP и JSON для ввода и вывода данных.

### Динамический API
API платформы использует [зеркалирование базы данных](https://docs.directus.io/getting-started/introduction#database-mirroring) для динамического создания конечных точек **REST** и схемы **GraphQL** на основе архитектуры подключённой базы данных. Поскольку эти конечные точки возвращают данные в соответствии с вашей конкретной схемой и настроенными разрешениями, входные и выходные данные API сильно различаются для отдельных установок.

### REST против GraphQL
Функциональные возможности конечных точек **REST** и **GraphQL** не отличаются. Функциональные возможности обеих конечных точек связаны с одним и тем же набором основных сервисов, а значит, вы не потеряете в производительности или возможностях, выбрав одну из них.

Какой из них вы выберете, в конечном счете, зависит от вас.

### Аутентификация
По умолчанию все данные в системе недоступны для пользователей без аутентификации. Чтобы получить доступ к защищенным данным, вы должны [включать в каждый запрос токен доступа или файл cookie сеанса](https://docs.directus.io/reference/authentication#access-tokens) или [настроить разрешения для общедоступной роли](https://docs.directus.io/getting-started/quickstart#_6-set-role-public-permissions).

Полезные ссылки:
- [Аутентификация в API](https://docs.directus.io/reference/authentication)
- [Ссылка на конечную точку входа](https://docs.directus.io/reference/authentication#login)

### Реляционные данные
По умолчанию Directus извлекает только ссылочное значение реляционного поля в ваших элементах. Чтобы также извлечь вложенные данные реляционного поля, можно использовать [параметр `fields` в REST](https://docs.directus.io/reference/query#fields) или обычные вложенные запросы в GraphQL. Это позволяет, например, получить данные об авторе статьи, включённые в данные статьи, или получить связанные точки входа в журнал для данных аналитики вашего приложения.

### Создание / Обновление / Удаление
Аналогично выборке, реляционный контент также может быть глубоко изменен.

**Соотношение "многие к одному"**  
Взаимоотношения **«многие к одному»** довольно просты в управлении. Вы можете просто отправить нужные вам изменения в виде объекта по ключу взаимосвязи в вашей коллекции. Например, если вы хотите создать новую статью на своей странице, вы можете отправить:
```json
{
  "featured_article": {
    "title": "This is my new article!"
  }
}
```
Это создаст новую запись в связанной коллекции и сохранит её первичный ключ в поле `featured_article` для этого элемента. Чтобы обновить существующий элемент, просто укажите первичный ключ с обновлениями, и Directus обработает его как обновление, а не как создание:
```json
{
  "featured_article": {
    "id": 15,
    "title": "This is an updated title for my article!"
  }
}
```
Поскольку связь «многие к одному» хранит внешний ключ в самом поле, удалить элемент можно, обнулив поле:
```json
{
  "featured_article": null
}
```

**Соотношение "один ко многим"**  
Отношения **«один ко многим»** и, следовательно, **«многие ко многим»** и **«многие к любым»** можно обновить одним из двух способов:

### Базовые модели
API вернёт поля **«один ко многим»** в виде массива вложенных ключей или элементов (в зависимости от параметра `fields`). Вы можете использовать эту же структуру для выбора связанных элементов:
```json
{
  "children": [2, 7, 149]
}
```
Вы также можете указать объект вместо первичного ключа, чтобы создавать новые вложенные элементы на лету, или объект с включённым первичным ключом, чтобы обновить существующий элемент:
```json
{
  "children": [
    2, // назначить существующий элемент 2 дочерним элементом текущего элемента
    {
      "name": "Новый вложенный элемент"
    },
    {
      "id": 149,
      "name": "Assign and update existing item 149"
    }
  ]
}
```

Чтобы удалить элементы из этой связи, просто исключите их из массива:
```json
{
  "children": [2, 149]
}
```

Этот метод обновления связи **«один ко многим»** очень полезен для небольших наборов данных.

### "Подробно"

В качестве альтернативы вы можете предоставить объект с подробным описанием изменений следующим образом:
```json
{
  "children": {
    "create": [{ "name": "Новый вложенный элемент" }],
    "update": [{ "id": 149, "name": "Новый вложенный элемент" }],
    "delete": [7]
  }
}
```
Это полезно, если вам нужно более тщательно контролировать поэтапные изменения или если вы работаете с большим набором реляционных данных.

**"Многие к любым" (типы объединений)**  
Поля **«многие к любым»** работают почти так же, как «обычные» поля **«многие ко многим»**, за исключением того, что связанное поле может получать данные из любой из связанных коллекций, например:
```json
{
  "sections": [
    {
      "collection": "headings",
      "item": {
        /* поля заголовков */
      }
    },
    {
      "collection": "paragraphs",
      "item": {
        /* поля абзацев */
      }
    }
  ]
}
```
### REST API
Чтобы ограничить поля, возвращаемые для каждого типа коллекции, можно использовать синтаксис `<field>:<scope>` в параметре `fields` следующим образом:
```js
GET /items/pages
  ?fields[]=sections.item:headings.id
  &fields[]=sections.item:headings.title
  &fields[]=sections.item:paragraphs.body
  &fields[]=sections.item:paragraphs.background_color
```

### GraphQL
В GraphQL для выбора полей можно использовать вложенные фрагменты в типе Union:
```graphql
query {
  pages {
    sections {
      item {
        ... on headings {
          id
          title
        }

        ... on paragraphs {
          body
          background_color
        }
      }
    }
  }
}
```
> Обновление
> 
> Обновление записей в отношениях «многие ко многим» выполняется так же, как и в других типах отношений.

### ПОИСК по HTTP-методу
При использовании REST API для чтения нескольких элементов с помощью (очень) сложных фильтров вы можете столкнуться с проблемой, когда URL-адрес просто не может содержать достаточно данных для включения полной структуры запроса. В таких случаях вы можете использовать HTTP-метод SEARCH в качестве замены GET, где вы можете поместить запрос в тело запроса следующим образом:

Перед:
```JS
GET /items/articles?filter[title][_eq]=Hello World
```

После:
```js
SEARCH /items/articles

{
  "query": {
    "filter": {
      "title": {
        "_eq": "Hello World"
      }
    }
  }
}
```

Существует множество дискуссий о том, следует ли добавлять тело запроса в GET-запрос, использовать POST-запросы для создания поисковых запросов или полагаться на другой метод. На данный момент мы решили [придерживаться спецификации IETFметода HTTP SEARCH](https://datatracker.ietf.org/doc/draft-ietf-httpbis-safe-method-w-body). Хотя мы понимаем, что это всё ещё черновик спецификации, метод SEARCH уже широко использовался в мире WebDAV ([спецификация](https://tools.ietf.org/html/rfc5323)), и по сравнению с другими доступными вариантами он кажется наиболее «чистым» и правильным для дальнейшего использования. Как и во всём остальном, если у вас есть какие-либо идеи, мнения или опасения, [мы будем рады услышать ваше мнение](https://github.com/directus/directus/discussions/new).

Полезное чтение:

- [Метод HTTP SEARCH (IETF, 2021)](https://datatracker.ietf.org/doc/draft-ietf-httpbis-safe-method-w-body)
- [Определение нового метода HTTP: HTTP SEARCH (Тим Перри, 2021)](https://httptoolkit.tech/blog/http-search-method)
- [HTTP GET с телом запроса (StackOverflow, 2009 и далее)](https://stackoverflow.com/questions/978061/http-get-with-request-body)
- [Эластичный поиск ПОЗВОЛЯЕТ ПОЛУЧИТЬ информацию об использовании тела (elastic, n.d.)](https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html)
- [Dropbox начинает использовать POST, и почему это плохой дизайн API. (Эверт Пот, 2015)](https://evertpot.com/dropbox-post-api)

### Системные данные в GraphQL
Из-за ограничений, присущих самому **GraphQL**, невозможно правильно определить область действия/пространство имен системы при обычном доступе к данным. Чтобы избежать конфликтов в именах между пользовательскими и системными данными, мы разделили доступ к ним на отдельные конечные точки для пользовательских и системных данных соответственно: `/graphql` и `/graphql/system`. 

Обе конечные точки используют одну и ту же базовую схему, поэтому вложенные отношения будут работать должным образом независимо от того, пересекаются ли они с пользовательскими или системными данными. Единственное различие между двумя конечными точками заключается в доступных полях корневого запроса и мутации.

### Коды ошибок
Ниже приведены глобальные коды ошибок, используемые в Directus, и их значения.

|Код |ошибки	|Состояние HTTP	Описание
|----|----------|-----------------------
|FAILED_VALIDATION	|400	|Не удалось выполнить проверку для этого конкретного элемента
|FORBIDDEN	|403	|Вам не разрешено выполнять текущее действие
|INVALID_TOKEN	|403	|Предоставленный токен недействителен
|TOKEN_EXPIRED	|401	|Предоставленный токен действителен, но срок его действия истек
|INVALID_CREDENTIALS	|401	|Имя пользователя / пароль или токен доступа неверны
|INVALID_IP	|401	|Ваш IP-адрес не разрешен для использования с этим пользователем
|INVALID_OTP	|401	|Был предоставлен неверный OTP
|INVALID_PAYLOAD	|400	|Предоставленная полезная нагрузка недопустима
|INVALID_QUERY	|400	|Запрошенные параметры запроса не могут быть использованы
|UNSUPPORTED_MEDIA_TYPE	|415	|Предоставленный формат полезной нагрузки или Content-Type заголовок не поддерживается
|REQUESTS_EXCEEDED	|429	|Превышен лимит скорости
|ROUTE_NOT_FOUND	|404	|Конечная точка не существует
|SERVICE_UNAVAILABLE	|503	|Не удалось использовать внешнюю службу
|UNPROCESSABLE_CONTENT	|422	|Вы пытались сделать что-то незаконное

> Безопасность
> 
> Чтобы предотвратить утечку информации о том, какие элементы существуют, все действия с несуществующими элементами будут возвращать ошибку `FORBIDDEN`



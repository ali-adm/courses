Sololearn CSS.
===

<a id="Содержание:">Содержание:</a>
---

### [Начало работы с CSS](#Начало-работы-с-CSS)

#### [Техники стилизации](#Техники-стилизации)
#### [Анатомия CSS](#Анатомия-CSS)
#### [Наследование стиля](#Наследование-стиля)
#### [ID и Class Selectors](#ID-и-Class-Selectors)
#### [Стандарты и Лучшие Практики](#Стандарты-и-Лучшие-Практики)
#### [Проект страницы профиля Шаг 1](#Проект-страницы-профиля-Шаг-1)
### [Стилизация элементов](#Стилизация-элементов)
#### [Введение в цвет](#Введение-в-цвет)
#### [Размеры](#Размеры)
#### [Стилизация текста](#Стилизация-текста)
#### [Стили шрифтов](#Стили-шрифтов)
#### [Проект страницы профиля Шаг 2](#Проект-страницы-профиля-Шаг-2)
#### [Стилизация ссылок](#Стилизация-ссылок)
#### [Стилизация таблиц](#Стилизация-таблиц)
#### [Стилизация списков](#Стилизация-списков)
#### [Проект Страницы Профиля Шаг 3](#Проект-Страницы-Профиля-Шаг-3)
#### [Стилизация форм](#Стилизация-форм)
#### [Контрольные вопросы к модулю 2](#Контрольные-вопросы-к-модулю-2)
### [Дизайн и макет страницы](#Дизайн-и-макет-страницы)
#### [Box Model](#Box-Model)
#### [Flexbox Layout](#Flexbox-Layout)
#### [Позиционирование](#Позиционирование)
#### [Проект страницы профиля Шаг 4](#Проект-страницы-профиля-Шаг-4)
#### [Фоны](#Фоны)
#### [Контрольные вопросы к модулю 3](#Контрольные-вопросы-к-модулю-3)
### [Переходы и Преобразования](#Переходы-и-Преобразования)
#### [Преобразования](#Преобразования)
#### [Переходы](#Переходы)
#### [Кадры ключевые и Анимации](#Кадры-ключевые-и-Анимации)
#### [Свойства анимации](#Свойства-анимации)
#### [Проект Профильной Страницы Шаг 5](#Проект-Профильной-Страницы-Шаг-5)
#### [Контрольные вопросы к модулю 4](#Контрольные-вопросы-к-модулю-4)

Наш курс CSS научит вас, как управлять стилем и версткой веб-сайтов. Вы выполните ряд упражнений и попрактикуетесь при заполнении реальных шаблонов CSS — так вы получите реальный опыт программирования, который укрепит вашу уверенность и поможет вам в реализации ваших собственных проектов!

<a id="Начало-работы-с-CSS">Начало работы с CSS</a>
---

[Содержание:](#Содержание:)

- CSS используется для стилизации элементов на веб-странице. CSS - это язык стилизации, который работает вместе с HTML, чтобы придать странице ее вид и макет.
- CSS основан на HTML. Атрибут `style` позволяет вам использовать свойства CSS для настройки визуального представления элементов HTML.

Изменение цвета текста параграфа с помощью атрибута `style`:
```html
<p style="color: green">Text</p>
```

Свойство `color` используется для управления цветом текста. Код синего заголовка:
```html
<h1 style="color: blue">Main Menu</h1>
```

**CSS свойства** контролируют стиль HTML элементов. 

Примеры CSS свойств - это цвет, граница, размер шрифта и отступ. Увеличение текста в параграфе:
```html
<p style="font-size: large">Text</p>
```

**Свойства CSS** требуют ***значений***.

**Значения** - это возможные настройки для свойства. 
- CSS свойства и значения разделяются с помощью двоеточия `:`, 
- CSS код для HTML элемента должен быть заключен в двойные `""` или одинарные `''` кавычки, следуя за атрибутом `style`. 
- Чтобы применить несколько свойств к элементу, разделяйте CSS свойства с помощью точки с запятой `;`.

**CSS** означает **Каскадные Таблицы Стилей** и является одной из трех основных веб-технологий. 

- Структура: HTML
- Стиль: CSS
- Интерактивность: Java Screept

Каскадность относится к набору правил, которые будут изложены ниже.

Пример код для центрированного заголовка с фоном green:
```html
<h1 style="text-align: center; background-color: green">Items</h1>
```


<a id="Техники-стилизации">Техники стилизации</a>
---

- **Inline CSS** используется для стилизации отдельных элементов HTML
- **Internal CSS** сгруппировывает все стили для страницы внутри тега `<style>`
- **Selectors** используются для выбора элементов HTML

Добавление CSS кода к каждому HTML элементу занимает время и делает вашу HTML структуру неорганизованной. Существует альтернативный способ стилизации ваших страниц, который делает ваш CSS код более эффективным.

Можно добавить CSS код *внутри HTML элементов*, это называется **inline CSS - встроенный CSS**:
```html
<p style="color: gray">Text</p>
```
Встроенный CSS легко добавить в ваш код, но он имеет некоторые недостатки. Например, для применения одного и того же стиля к более чем одному HTML элементу - необходимо повторить код CSS.

Альтернативной техникой стилизации является **internal CSS - внутренний CSS**. Внутренний CSS используется для стилизации всей страницы. Тег-контейнер `<style>` добавляется в документ HTML, чтобы сгруппировать весь CSS код для страницы.
```html
<style>
  p {
    color: orchid;
  }
</style>
<body>
  <p>Explore the city.</p>
  <p>Discover hidden gems.</p>
  <p>Take a free tour.</p>
</body>
```
`<style>` - контейнерный тег это значит, что он требует как открывающего, так и закрывающего тега `</style>`.

Способ добавления CSS кода зависит от техники стилизации, которая используется. В индивидуальные HTML элементы добавляется **встроенный CSS** код.

Стиль, определенный в приведенном внутреннем CSS-коде, будет применен ко всем заголовкам третьего уровня на странице:
```html
<style>
  h3 {
    color: red;
    font-size: small;
  }
</style>
```

В данном случае `h3` - выступает в роли **Селектора.** Селектор в коде CSS соответствует HTML-тегам, которые нужно стилизовать. Селекторы используются с внутренним CSS. Например чтобы стилизовать кнопки на странице, нужно использовать селектор `button`:
```css
button {
  color: green;
  }
```
Чтобы применить один и тот же стиль к различным элементам, нужно разделить несколько селекторов запятой. Это упрощает код CSS.
```html
<style>
  h1, p {
    color: black;
    background-color: yellow;
  }
</style>
```

Лучшей практикой считается включать весь внутренний CSS-код в <head> страницы.
```html
<head>
  <style>
    h1 {
      color: orchid;
      background-color: lime;
    }
    p {
      color: orchid;
    }
    button {
      font-size: large;
      color: lightyellow;
      background-color: orchid;
    }
  </style>
</head>
<body>
  <h1>Explore the city.</h1>
  <p>Discover hidden gems.</p>
  <button>Take a free tour</button>
</body>
```

<a id="Анатомия-CSS">Анатомия CSS</a>
---

- Код CSS состоит из **правил стилизации**
- Правило состоит из селектора и набора деклараций
- Декларация состоит из пары **свойство: значение**

CSS контролирует все аспекты дизайна веб-страницы. Это включает в себя шрифты, размеры, цвета, позицию, расстояние, макет, анимации и многое другое.

CSS код создает **правила стилизации.** Простейшее правило стилизации состоит из **селектора**, плюс **объявление** в фигурных скобках `{}`.
```css
button {
  font-size: large;
  color: blue;
  }
```

Приведенный выше код, будет применять стили для всех кнопок на странице. Можно добавить столько объявлений, сколько нужно, аждое объявление должно заканчиваться на точку с запятой. Объявление состоит из двух частей: **property (свойства)** и **value (значения).** Свойство и значение внутри объявления всегда идут парами. Декларация состоит из пары **свойство: значение**. Пара **свойство: значение** в декларации отделяется двоеточием `:`. 
CSS код может содержать столько стилевых правил, сколько нужно.


<a id="Наследование-стиля">Наследование стиля</a>
---

- По умолчанию элемент **child** будет наследовать стиль от своего **parent**
- Можно **переопределить наследование стиля,** создав другое правило для дочернего элемента
- Селектор **descendant selector** целиком находит дочерний элемент, вложенный в конкретного родителя

При стилизации реальных веб-страниц, код CSS может быстро расти в объеме. Поэтому нужно использовать **наследование стилей** для создания более точных правил и написания кода, который прост, организован, понятен и эффективен.

**Вложенность** в HTML - это когда некоторые теги распологаются внутри других. Элементы внешнего тега известны как **parent (родитель),** внутренние элемента - **child (дочерние).** Правила стилизации для родительских элементов также будут применяться к дочерним элементам по умолчанию. Это известно как **наследование.** Дочерние элементы наследуют стили от своих родителей.
```html
<head>
  <style>
    p{
      background-color: plum;
      color: darkblue;
    }
  </style>
</head>
<body>
  <p>Buy a ticket to <b>Portugal</b></p>
</body>
```

По умолчанию, дочерние элементы наследуют стиль своего родителя. Если вам нужно, чтобы дочерний элемент имел другой стиль, вы должны для него написать отдельное правило.
```html
<head>
  <style>
    p {
      color: lightgray;
      background-color: black;  
    }

    em {
      color: plum;
      background-color: darkslategrey;
    }
  </style>
</head>
<body>
  <p><em>Programming</em> is a valuable skill
  in today's digital age. Learning to
  code is a journey that can
  open up many opportunities.</p>
</body>
```

Можно использовать комбинацию селекторов, чтобы создать более точные правила. **Descendant selector - Селектор потомка** находит дочерний элемент внутри конкретного родителя. Он состоит из селектора родителя, за которым следует пробел, за которым следует селектор ребенка.
```html
<head>
  <style>
    h1 u {
      color: seagreen;
    }
  </style>
</head>
<body>
  <h1>Back to <u>school!</u></h1>
  <p>Our back to <u>school</u> sale from July 15th.</p>
</body>
```


<a id="ID-и-Class-Selectors">ID и Class Selectors</a>
---

- Селектор `ID` использует символ хеша `#` и целится в конкретный элемент
- **Класс** дает общий идентификатор группе элементов
- Селектор **класса** использует точку `.` и целится в группу элементов с одинаковым классом

Для полного контроля над дизайном элементов HTML, можно присвоить им **ID** и **классы**, ID для обращения к конкретным элементам, а классы - для обращения к группам элементов.

Атрибут `id` используется для присвоения уникального идентификатора конкретному элементу на странице, и далее для идентификации уникальных элементов в HTML документе.
```html
<p id="intro">Have a great movie time!</p>
```

Чтобы идентицировать конкретные элементы, используется хештег `#` за которым следует имя `ID` в качестве селектора.
```html
<head>
  <style>
    #heading {
      background-color: DodgerBlue;
      color: white;
      text-align: center;
    }
    #movie {
      text-align: center;
      background-color: grey;
    }
  </style>
</head>
<body>
  <h1 id="heading">Movie Stream</h1>
  <h2 id="movie">Matrix</h2>
  <p>Genre: Action, Sci-fi</p>
</body>
```

Другой способ идентификации элементов - это атрибут `class`, используется чтобы присвоить один и тот же идентификатор группе элементов.
```html
<p class="movie">Avatar</p>
<button class="movie">Watch now</button>
```

- `id` - один уникальный элемент
- `class` - несколько разных элементов

Можно создавать правила стилизации для группы элементов в одном классе (группе). Для этого используется точка `.` за которой следует имя класса, чтобы целенаправленно обратиться ко всем элементам в этом классе. Т.е. можно дать одно и то же имя класса для нескольких элеменов.
```html
<head>
<style>
  .intro {
    color: darkblue;
    font-size: 28px;
    text-align: center;
  }
  .content {
    color: navy;
    font-size: 18px;
  }
</style>
</head>
<body>
  <h1 class="intro">Welcome to
  FitLife Blog</h1>
  <p class="content">Get inspired to lead a
  healthy and active lifestyle.</p>
  <p class="content">Explore workout routines
  and nutritious recipes.</p>
  <button class="content">Signup</button>
</body>
```

- Обращение к уникальным идентификаторам `id` через символ хеша: `#`
- Обращение к классам`class` через символ точки: `.`

Также можно нацелиться только на те элементы определенного типа, которые имеют определенный класс. Это правило CSS изменит только **параграфы** с классом `content`:
```html
<head>
  <style>
    p.content {
      color: navy;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1 class="intro">Welcome to
  FitLife Blog</h1>
  <p class="content">Get inspired to lead a
  healthy and active lifestyle.</p>
  <p class="content">Explore workout routines
  and nutritious recipes.</p>
  <button class="content">Signup</button>
</body>
```


<a id="Стандарты-и-Лучшие-Практики">Стандарты и Лучшие Практики</a>
---

- **Specificity** (специфичность) сообщает браузеру, какое правило применять
- **Comments** в CSS начинаются с `/*` и заканчиваются на `*/`
- **External CSS** означает отдельный файл для правил стилизации

Иногда веб-браузеры решают, какое правило приоритизировать, когда несколько правил одновременно нацелены на один и тот же элемент. HTML элемент может быть стилизирован разными способами. Например, элемент может иметь как класс, так и ID.
```html
<p id="text1" class="info">Text</p>
```
где: `p` - селектор элемента; `text1` - селектор ID; `info` - селектор класса.

Каждый тип CSS селектора имеет свой приоритет. Когда несколько CSS правил нацеливаются на один и тот же HTML элемент, браузер использует следующий порядок, чтобы решить, какое правило применить:

### Selectors Priority: 

1 - Inline style; 

2 - IDs; 

3 - Classes; 

4 - Elements.

Порядок приоритетов известен как **Specificity** - специфичность. Специфичность - это алгоритм, используемый браузерами для определения правила, применяемого к элементу. Это необходимо, потому что HTML-элемент может быть стилизирован разными способами. 

В данном примере `Text` будет цвета `blue` потому что ID `#p1` имеет больший приоритет в сравнении с Element `p`.
```html
<head>
  <style>
    p {
      color: red;
    }
    #p1 {
      color: blue;
    }
  </style>
</head>

<body>
  <p id = "p1">Text</p>
</body>
```

Коментарии помогают другим людям (и будущему вам!) читать ваш код. В CSS начинаются с `/*` и заканчиваются `*/` - т.е. звездочки находятся внутри за слешами.
```html
<head>
  <style>
    /*Стилистические правила для класса menu*/
    .menu {
      font-size: medium;
      background-color: lightblue;
    }
  </style>
</head>

<body>
  <button class="menu">Save for later</button>
  <button class="menu">Add to cart</button>
</body>
```

При использовании встроенного (**inline**) CSS, комментарии должны находиться в тегах `<style>`, а при использовании внутреннего (**internal**) стиля техники, весь CSS код группируется вместе в HTML документе в одном наборе `<style>` тегов.

Альтернативой встроенным и внутренним CSS является **внешний CSS**. Внешний CSS код написан вне HTML документа, в отдельном файле. Одно из преимуществ внешнего CSS заключается в том, что один и тот же файл стилей CSS может использоваться несколькими документами HTML (или веб-страницами). Некоторые разработчики предпочитают внешний CSS, потому что он разделяет структуру и стиль на разные файлы. Это означает, что проект веб-страницы будет состоять из нескольких файлов с разными расширениями файлов. Внешний CSS очень полезен для многостраничных сайтов, так как позволяет стилизовать весь сайт в одном месте.

- файл html - структура
- файл css - стиль

Во внешнем CSS файле не нужны теги `<style>`, правила стилизации добавляются напрямую. Пример содержимого файла **main.css**
```css
.heading {
  font-size: large;
  color: blueviolet;
}
.description {
  font-size: medium;
  color: firebrick;
}
button {
    background-color: burlywood;
}
```


<a id="Проект-страницы-профиля-Шаг-1">Проект страницы профиля Шаг 1</a>
---

Страницы профилей пользователей имеют большое влияние на успех веб-сайта. Давайте начнем с применения некоторых цветов и выравниваний.

Задания:
1. Установите цвет фона тела на `DarkSlateGrey`.
2. Выровняйте по центру заголовки и абзацы и установите для их текста белый цвет.
3. "Запустите" код, чтобы предварительно просмотреть страницу. Затем "сохраните" свой прогресс и двигайтесь дальше.
```html
<html>
<head>
  <title>John Doe's Profile</title>
  <style>
    /*Первое задание*/
    body {
      background-color: DarkSlateGrey;
      }
    /*Второе задание*/
    h2, p {
      text-align: center;
      color: white;
      }
  </style>
</head>
<body>
  <ul id="profile">
    <img src="https://blob.sololearn.com/courses/ava.png">
    <h2>John Doe</h2>
    <p>🇺🇸USA</p>
    <li>25 Followers</li>
    <li>20 Following</li>
    <li>⭐️1581 XP</li>
  </ul>
  <div id="streak">Streak
    <ul>
      <li class="active-day">M</li>
      <li class="active-day">T</li>
      <li class="active-day">W</li>
      <li class="inactive-day">T</li>
      <li class="inactive-day">F</li>
      <li class="inactive-day">S</li>
      <li class="inactive-day">S</li>
    </ul>
    <p>Current Streak: 3</p>
    <p>Longest Streak: 16</p>
  </div>
</body>
</html>
```

Контрольные вопросы к модулю 1.


<a id="Стилизация-элементов">Стилизация элементов</a>
===

<a id="Введение-в-цвет">Введение в цвет</a>
---

- **RGB** - это цветовая модель для доступа к широкому спектру цветов. RGB использует 3 значения, представляющие интенсивность **красного, зеленого** и **синего** цветов.
- **HEX коды** сокращают представление цветов.

Цвет является одним из самых важных элементов в дизайне. Наиболее распространенные цвета имеют названия. CSS позволяет использовать цвета с названиями и даже без них, используя цветовые модели.

**Цветовая модель** - это способ представления и воссоздания реальных цветов с использованием кодов. **RGB** - одна из наиболее используемых цветовых моделей. **RGB** модель создает цвета путем комбинирования разных количеств (интенсивностей) красного, зеленого и синего; каждый варьируется от 0 до 255. `rgb(255, 255, 255)` представляет белый цвет. Регулируя уровни красного, зеленого и синего, можно получить практически любой цвет. Значения RGB заключены в скобки и разделены запятыми. Каждое количество (или интенсивность) красного, зеленого и синего колеблется от `0` до `255`. 

`color` - CSS свойство, используемое для применения цвета к тексту, а `background-color` к фону. В примере приведено правило CSS, которое делает заголовки первого уровня синими:
```css
h1 {
  color: blue;
  background-color: rgb (255,255,0);
}
```

Цвета в модели **RGB** также могут быть представлены в виде **HEX-кодов**. 

**HEX-коды** короче, например `#FFFFFF` соответствует белому цвету, а `#FF9595` розовому. HEX-коды начинаются с символа хеша `#`, за которым следуют 3 пары символов, каждая из которых представляет интенсивность *красного*, *зеленого* и *синего* соответственно. Каждый символ в HEX-коде может иметь одно из 16 возможных значений, начиная от `0` до `9` и расширяясь до букв от `A` до `F`. Каждая пара варьируется от `00` (наименее интенсивный) до `FF` (наиболее интенсивный). 

Представление чисел в системе **HEX** является более эффективным. На цвет требуются только 2 цифры. Цветовые модели и коды нужны, потому что существует слишком много цветов, чтобы каждому дать отдельное имя.

Устройства отображения, такие как экран телефона, монитора, телевизора, состоят из крошечных элементов изображения, известных как пиксели. Каждый пиксель может излучать комбинацию *красного*, *зеленого* и *синего* света для создания любого цвета в *модели RGB*.


<a id="Размеры">Размеры</a>
---

- размер в CSS может быть измерен и установлен в **пикселях** (`px`) и **процентах** (`%`)
- **проценты** `%` позволяют создавать более адаптивные дизайны, корректируясь в зависимости от размеров родительских элементов

Чтобы создавать страницы, которые выглядят красиво и сбалансировано, нужно полностью контролировать размеры элементов. Дисплей, подобный экрану телефона, состоит из элементов изображения или пикселей. Пиксели используются в качестве **единицы измерения** для контроля размеров элементов. Свойство `font-size` контролирует размер текста:
```css
button {
  font-size: 32px;
}
```

В большинстве веб-браузеров, **размер текста** в абзацах, кнопках, списках и таблицах **по умолчанию равен** `16px`. Можно использовать значения, такие как `small (13px)`, `medium (16px)` и `large (18px)` для размера текста. У них уже установлены единицы пикселей.

Современные веб-сайты создаются таким образом, чтобы выглядеть отлично на экранах различных размеров и разрешений. Этот подход известен как адаптивный веб-дизайн. Использование пикселей в качестве единицы измерения не является лучшей практикой в отношении адаптивного веб-дизайна. Экраны разных размеров и разрешений имеют разное количество пикселей, а пиксели являются единицами фиксированного размера.

Чтобы дизайн вашей страницы отлично выглядел на любом экране, используются **проценты** (`%`) для установки относительных размеров. Это обеспечивает последовательный дизайн на разных размерах экрана. При стилизации элемента с использованием процентов (%), 100% будет соответствовать полному размеру его родительского элемента.
```css
img {
  width: 50%;
}
```

Все элементы веб-страницы, которые видны в браузере, вложены внутрь `<body>`. По умолчанию, ширина тела страницы соответствует ширине экрана устройства. Это очень полезно при проектировании адаптивных сайтов. Если ширина элемента HTML установлена на 50%, он займет половину ширины своего родительского элемента.

Также можно использовать проценты для установки размера шрифта. Размеры шрифтов будут рассчитываться с использованием размера шрифта родителя в качестве референса. Если размер родительского шрифта установлен на `20px`, то дочерний, с `font-size` равным `50%` будет отображать текст размером `10px`.

Пример фрагмента *.html файла
```html
<body>
  <div class="parent">
    Parent Text (20px)
      <div class="child">
        Child Text (50% of Parent = 10px)</div>
  </div>
</body>
```

Фрагмент подключенного к html - *.css файла. 
```css
.parent {
    font-size: 20px;
    background-color: #98FB98;
}

.child {
    font-size: 50%;
    background-color: #FFD700;
}
```
Далее примеры кода HTML-CSS будут следовать без пояснительных надписей. Сначала будет следовать фрагмент html, за ним - css. По **тегам html** и **селекторам css** можно узнать где какой находится код.


<a id="Стилизация-текста">Стилизация текста</a>
---

- `text-align` контролирует горизонтальное выравнивание текста
-  `text-decoration` добавляет декоративные эффекты к тексту
-  `text-transform` изменяет написание текста
-  `text-shadow` применяет теневые эффекты за текстом

Еще одним важным элементом веб-дизайна является стилизация текста. 
`text-align: center` - выравнивание текста (по аналогии - `right`, `left`)

Используйте `text-align: justify` для выравнивания текста по обоим краям, регулируя расстояние между словами, чтобы гарантировать, что каждая строка имеет одинаковую ширину
```css
p {
  text-align: justify;
}
```

Можно добавить `text-decoration` (подчеркивание, надчеркивание, зачеркивание), чтобы передать смысл или привлечь внимание к определенным частям текста, например, к ссылкам.
```html
<html>
<body>
  <h1>Underlined text</h1>
  <h2>Overlined text</h2>
  <h3>Line-through text</h3>
  <h4>Underlined and overlined text</h3>
</body>
</html>
```
```css
body {
  background-color: #333333;
}
h1 {
  /*Underlined text*/
  text-decoration: underline;
  color: #F28D35;
}
h2 {
  /*Overlined text*/
  text-decoration: overline;
  color: #6BBE92;
}
h3 {
  /*Line-through text*/
  text-decoration: line-through;
  color: #D83367;
}
h4 {
  /*Underlined and overlined text*/
  text-decoration: underline overline;
  color: #149EF2;
}
```

Некоторые свойства CSS могут принимать несколько значений. Вы можете контролировать цвет декорации, добавив название цвета, rgb или hex-код после типа декорации.
```html
html>
  <body>
    <h1>My Personal Blog</h1>
    <h2 class="article-title">Adventures in New Zealand</h2>
    <p>During my trip to New Zealand, I had the chance to visit...</p>
    <h2 class="article-title">Gourmet Cooking on a Budget</h2>
    <p>Believe it or not, it's possible to cook gourmet meals without breaking the bank...</p>
  </body>
</html>
```
```css
body {
  background-color: #F3F4F6;
  color: #333333;
}
h1 {
  text-align: center;
  color: #555555;
}
.article-title {
  text-decoration: underline #FF4500;
  font-size: 24px;
}
```

Текстовое оформление может принимать различные стили, такие как точечный, двойной, пунктирный и волнистый.
```html
<body>
  <div class="container">
    <p class="double">
      This is a double underline.</p>
    <p class="dotted">
      This is a dotted underline.</p>
    <p class="dashed">
      This is a dashed underline.</p>
    <p class="wavy">
      This is a wavy underline.</p>
  </div>
</body>
```
```css
body {
  background-color: #000A23;
  color: #EDEDED;
}
p {
  font-size: 18px;
}
.double {
  text-decoration: double underline #E67112;
}
.dotted {
  text-decoration: underline dotted #2A9D8F;
}
.dashed {
  text-decoration: dashed underline #E76F51;
}
.wavy {
  text-decoration: wavy underline #62767E;
}
```

Свойство `text-decoration` - это короткий и простой способ ссылаться на различные подсвойства, такие как `text-decoration-line`, `text-decoration-color` и `text-decoration-style`.

```css
text-decoration: wavy overline #2A9D8F;

text-decoration-line: overline;
text-decoration-color: #2A9D8F;
text-decoration-style: wavy;
```

Свойство `text-transform` позволяет вам контролировать использование заглавных букв в текстовом контенте (каждое слово с заглавной, все заглавные и все строчные).
Оно может принимать 3 значения: `capitalize`, `uppercase` и `lowercase`.
```html
<html>
  <body>
    <p class="capitalize">
    this is a sentence with capitalize transformation.</p>
    <p class="uppercase">
     This is a sentence with uppercase transformation.</p>
    <p class="lowercase">
     THIS IS A SENTENCE WITH LOWERCASE TRANSFORMATION.</p>
  </body>
</html>
```
```css
.capitalize { 
  text-transform: capitalize; 
}
.uppercase { 
  text-transform: uppercase; 
}
.lowercase { 
  text-transform: lowercase; 
}
body{
  background-color: #000A23;
  color: white;
}
```

Например CSS правило для кнопки с текстом в верхнем регистре, размером шрифта 18px и зеленым фоном:
```css
button {
  text-transform: apitalize;
  background-color: green;
  font-size: 18px;
}  
```

Свойство `text-shadow` создает эффект глубины, придает выразительность или просто добавляет стильный акцент в вашу типографику.

Оно принимает два обязательных значения в следующем порядке: сначала горизонтальное смещение, затем вертикальное.
- Горизонтальное смещение - это насколько далеко вправо (положительные значения) или влево (отрицательные значения) будет тень.
- Вертикальное смещение - это насколько далеко вниз (положительные значения) или вверх (отрицательные значения) будет тень.

Как пример - применить теневой эффект текста со смещением в 5px вправо и 6px вверх:
```css
h1 {
  text-shadow: 8px 6px;
}
```

`text-shadow` может принимать два дополнительных, необязательных значения.
- `blur radius`: степень размытия, применяемая к тени
- `color`: цвет тени
```html
<html>
  <body>
    <h1>Harry Potter</h1>
  </body>
</html>
```
```css
body {
  background-color: #1a1a1a;
}

h1 {
  color: #FFFFFF; /* white colored text */
  text-shadow: 4px 4px 4px #4296CE; 
  font-size: 4rem;
}
```

Важно сохранять правильный порядок значений для свойства `text-shadow`, иначе оно может не дать желаемого эффекта.


<a id="Стили-шрифтов">Стили шрифтов</a>
---

- `font-family` позволяет вам указывать тип шрифта

- вы можете использовать `font-weight` для контроля толщины текста

Шрифты играют важную роль в веб-дизайне, влияя на читаемость, эстетику и пользовательский опыт. Они оживляют слова на странице и задают тон содержимого.

Свойство `font-family` в CSS позволяет вам указать **шрифт** для вашего текста. Это определяет, как текст выглядит на веб-странице.
```html
<body>
  <p id="font-georgia">Georgia</p>
  <p id="font-arial">Arial</p>
  <p id="font-courier">Courier New</p>
  <p id="font-comic">Comic Sans MS</p>
</body>
```
```css
body {
  background-color: #000A23;
  font-size: 24px;
  color: #FFFFFF;
}
#font-georgia {
  font-family: Georgia;
}
#font-arial {
  font-family: Arial;
}
#font-courier {
  font-family: "Courier New";
}
#font-comic {
  font-family: "Comic Sans MS";
}
```

Многие шрифты установлены по умолчанию на всех устройствах. Они известны как **веб-безопасные** шрифты.

Другие шрифты могут потребовать установки на устройстве пользователя, поэтому вам нужно указать веб-безопасный шрифт в качестве запасного, на случай, если у пользователя их нет.
```html
<html>
<body>
  <h2 id="font1">Daily Brews</h2>
  <h2 id="font2">Daily Brews</h2>
  <h2 id="font3">Daily Brews</h2>
  <h2 id="font4">Daily Brews</h2>
</body>
</html>
```
```css
/*некоторые веб-безопасные шрифты:
Arial, Courier New, Times New Roman,
Trebuchet MS, Verdana
*/
#font1 {
  font-family: Georgia;
}
#font2 {
  font-family: Tahoma;
}
#font3 {
  font-family: Lucida Console;
}
#font4 {
  font-family: Comic Sans MS;
}
/* Вот еще веб-безопасные шрифты, которые вы можете попробовать: Arial, Courier New, Times New Roman, Trebuchet MS, Verdana */
```

Свойство `font-family` указывает список шрифтов, от самого приоритетного до наименее приоритетного. Выбор шрифта останавливается на первом шрифте в списке, который есть в системе пользователя.

Например, если `Helvetica` недоступен браузер сначала пробует `Georgia`, затем семейства шрифтов `Arial`:
```css
p {
  font-family: Helvetica, Georgia, Arial;
}
```

**Обобщенные семейства шрифтов** - это группы шрифтов с похожими начертаниями, и они используются в качестве универсальных резервных вариантов. Это лучшая практика, чтобы помещать их в качестве последнего варианта в свойстве font-family. Если предпочтительные шрифты недоступны, браузеры будут использовать шрифт из этого семейства.

Ниже приведен код пяти общих обобщенных семейств шрифтов:
```html
<body>
  <h2 class="serif-font">This is a serif font.</h2>
  <h2 class="sans-serif-font">This is a sans-serif font.</h2>
  <h2 class="monospace-font">This is a monospace font.</h2>
  <h2 class="cursive-font">This is a cursive font.</h2>
  <h2 class="fantasy-font">This is a fantasy font.</h2>
</body>
```
```css
.serif-font {
  /*Шрифты имеют декоративные
  штрихи или засечки.*/
  font-family: serif;
}
.sans-serif-font {
  /*В шрифтах отсутствуют 
  декоративные штрихи.*/
  font-family: sans-serif;
}
.monospace-font {
  /*Шрифты имеют одинаковый 
  интервал между символами.*/
  font-family: monospace;
}
.cursive-font {
  /*Шрифты имитируют почерк для 
  придания персонального или 
  художественного штриха.*/
  font-family: cursive;
}
fantasy-font {
  /*Декоративные или уникальные шрифты, 
  которые не подходят ни в одну 
  другую категорию.*/
  font-family: fantasy;
}
body {
  background-color: #0C1527;
  color: #FFFFFF;
}
```

Используйте кавычки для обертывания названий шрифтов, состоящих из нескольких слов. Это хорошая практика. 
```css
p {
  font-family: "Courier New", Monaco, monospace;
}
```

Свойство `font-weight` контролирует толщину (или жирность) шрифта (или текста).
```css
.button {
  font-weight: 500;
}
```

Можно использовать числовые значения от **100** (самый тонкий) до **900** (самый жирный) для указания веса шрифта, увеличивая на **100 единиц**.
```html
<body>
  <p id="light">This is light text.</p>
  <p id="normal">This is normal text.</p>
  <p id="bold">This is bold text.</p>
  <p id="bolder">This is bolder text.</p>
</body>
```
```css
p {
  font-family: Arial, sans-serif;
  font-size: 1.5em;
}
#light {
  font-weight: 100;
}
#normal {
  font-weight: 400;
}
#bold {
  font-weight: 700;
}
#bolder {
  font-weight: 900;
}
```

Пример - выравнивание текста по левому краю, размер шрифта `22p`x и вес `300`
```css
p {
  text-align: left;
  font-size: 22px;
  font-weight: 300;
}
```

Некоторые значения веса, такие как **400** и **700**, имеют именованные эквиваленты, которые можно использовать непосредственно в качестве значений: **normal** и **bold**.

<a id="Проект-страницы-профиля-Шаг-2">Проект страницы профиля Шаг 2</a>
---

Установите шрифты для страницы и выровняете раздел профиля. Также нужно сделать раздел активности более понятным для пользователя. 

Задачи:
1. Установите `font-family` для body на `Arial`, `sans-serif`
2. Выровняйте по центру раздел `#profile` и окрасьте текст в цвет `#FFFFFF`
3. Окрашивайте элементы `.active-day` в `#00CC00` и `.inactive-day` в `#CCCCCC` для отображения активных и неактивных дней соответственно
```html
<html>
<head>
  <title>John Doe's Profile</title>
  <style>
    /*Task 1*/
    body {
      background-color: DarkSlateGrey;
      font-family: Arial, sans-serif;  /*Первое задание*/
      }
    #profile {
      text-align: center;  /*Второе задание*/
      color: #FFFFFF;  /*Второе задание*/
      }  
    h2, p {
      text-align: center;
      color: yellow;
      }
    .active-day {
      color: #00CC00  /*Третье задание*/
      }
    .inactive-day {
      color: #CCCCCC  /*Третье задание*/
      }
  </style>
</head>
<body>
  <ul id="profile">
    <img src="https://blob.sololearn.com/courses/ava.png">
    <h2>John Doe</h2>
    <p>🇺🇸USA</p>
    <li>25 Followers</li>
    <li>20 Following</li>
    <li>⭐️1581 XP</li>
  </ul>
  <div id="streak">Streak
    <ul>
      <li class="active-day">M</li>
      <li class="active-day">T</li>
      <li class="active-day">W</li>
      <li class="inactive-day">T</li>
      <li class="inactive-day">F</li>
      <li class="inactive-day">S</li>
      <li class="inactive-day">S</li>
    </ul>
    <p>Current Streak: 3</p>
    <p>Longest Streak: 16</p>
  </div>
</body>
</html>
```


<a id="Стилизация-ссылок">Стилизация ссылок</a>
---

- Можно использовать псевдоселекторы для стилизации различных состояний ссылок
- Можно переопределить формат подчеркивания по умолчанию с помощью свойства `text-decoration`

Ссылки являются сутью веба, соединяя одну страницу с другой. Они критически важны для навигации, но стандартный стиль синих подчеркнутых ссылок не всегда подходит для каждого дизайна.

В этом уроке вы научитесь стилизовать ссылки в соответствии с темой вашего сайта и улучшить пользовательский опыт.
```html
<a herf="url">Products</a>
```

Ссылка по умолчанию синего цвета и подчеркнута. Можно переопределить этот стиль по умолчанию с помощью CSS, чтобы настроить цвета, шрифты и декораторы.
```html
<body>
  <div class="container">
    <h1>Welcome to our website!</h1>
    <p>Check out our 
      <a href="https://www.example.com">special offers</a> 
      page for amazing deals.</p>
  </div>
</body>
```
```css
body {
  font-family: Arial, sans-serif;
  background-color: #F4F4F4;
  text-align: center;
}

a {
  color: #52C80C;
  font-family: 'Georgia', serif;
  background-color: #D6E5E3;
}
```

Можно контролировать стиль ссылок, которые пользователь еще не посетил.
```css
a {
    color: #3498DB;
    font-family: 'Georgia', serif;
    background-color: #E9E9E9;
}
```

Когда пользователи взаимодействуют со ссылкой (также и с другими элементами), она меняет свое **состояние**. Вы можете обратиться к состоянию элемента с помощью **псевдо-селекторов**.
```html
<body>
  <a href="www.example.com">Link </a>
</body>
```
```css
/* определяет стиль непосещенных ссылок */
a:link {
  color: #D11BCE;
  text-decoration: none;
}
/* ссылка считается наведенной, 
когда указатель мыши находится над ней */
a:hover {
  color: #6897EE;
  background-color: #000000;
}
/* когда вы кликаете по ссылке, 
но ещё не отпустили кнопку мыши*/
a:active{
  color: #B8860B;
  background-color: #000000;
/*:focus срабатывает при клике на элемент или переходе на него с клавиатуры при помощи клавиши tab. Применяется состояния ко всем интерактивным элементам — <button>, <a>, <input>, <select> и элементам с tabindex.

Существует также состояние :focus-visible, которое возникает исключительно при фокусе с клавиатуры. Это состояние улучшает доступность сайта для пользователей с ограниченными возможностями. */
}
body {
 font-size: 20px;
}
```

Например правило, ссылки становятся красными, когда мышь находится над ними:
```css
a.hover {
    color: red;
}
```
Или еще правило, ссылки становятся фиолетовыми, когда на них нажимают и кнопку еще не отпустили:
```css
a:active {
    color: purple;
}
```
Псевдо-селектор нацеливается на элементы, основываясь на их состоянии. Можно добавлять псевдо-селекторы к элементам, ID и классам, например так будет выглядеть правило для стилизации группы ссылок, класс которых - `file`, когда они наведены:
```css
.flie:hover {
    font-size: large;
}
```
Или правило для цели ссылки с идентификатором ```home```,  когда она была посещена:
```css
#home:visited {
    color: green;
}
```
По умолчанию все ссылки подчеркнуты. Можно удалить стиль подчеркивания, установив свойство `text-decoration` в значение `none`.
```css
a {
    text-decoration: none;
}
```
Например можно удалить подчеркивание у всех ссылок и сделать текст розовым:
```css
a {
    color: pink;
    text-decoration: none;
}
```
или подчеркивание удаляется при наведении на ссылки
```css
a:hover {
    text-decoration: none;
}
```

<a id="Стилизация-таблиц">Стилизация таблиц</a>
---

- Свойство `border` добавляет и стилизует границы вокруг элементов таблицы
- Свойство `border-collapse` позволяет вам контролировать, остаются ли границы ячеек таблицы отдельными или объединяются
- Селектор `nth-child()` позволяет вам выбирать и стилизовать определенные строки или группы строк, например, нечетные и четные строки

Таблицы - мощный инструмент для представления данных в структурированном и организованном виде, но по умолчанию они могут быть довольно простыми и не соответствовать общему дизайну вашего веб-сайта. В этом уроке вы узнаете, как преобразовать простые таблицы в визуально привлекательные и привлекательные элементы, гармонирующие с дизайном вашего веб-сайта.

Тэги и элементы таблиц:
- Таблица: `<table>`
- Строка таблицы: `<tr>`
- Ячейка данных: `<td>`
- Ячейка заголовка: `<th>`

Внешний вид HTML-таблицы можно значительно улучшить с помощью свойства `border`, это короткий и простой способ обращения к 3 различным подсвойствам:
- `border-width: 1px`
- `border-style: solid`
- `border-color: red`
  
Чтобы добавить рамку вокруг таблицы, примените свойство border к `<table>`. Чтобы добавить границы ко всем ячейкам, примените свойство border к `<th>` и `<td>`. По умолчанию, таблицы стилизуются без границ.
```html
<body>
  <!-- Таблица с рамкой вокруг таблицы -->
  <table id="table1">
    <tr>
      <th>Rank</th>
      <th>Movie Title</th>
      <th>Director</th>
    </tr>
    <tr>
      <td>1</td>
      <td>Dune</td>
      <td>Dennis Villeneuve</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Spider-Man: No Way Home</td>
      <td>Jon Watts</td>
    </tr>
    <tr>
      <td>3</td>
      <td>The French Dispatch</td>
      <td>Wes Anderson</td>
    </tr>
  </table>
  <br>
  <!-- Таблица с границами на всех ячейках -->
  <table id="table2">
    <tr>
      <th>Rank</th>
      <th>Movie Title</th>
      <th>Director</th>
    </tr>
    <tr>
      <td>1</td>
      <td>Dune</td>
      <td>Dennis Villeneuve</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Spider-Man: No Way Home</td>
      <td>Jon Watts</td>
    </tr>
    <tr>
      <td>3</td>
      <td>The French Dispatch</td>
      <td>Wes Anderson</td>
    </tr>
  </table>
</body>
```
```css
body {
  font-family: Arial, sans-serif;
  background-color: #F7F8FC;
}

/* Применение рамки вокруг таблицы */
#table1 {
  border: 2px solid #0C1527;
}

/* Применение границ к каждой ячейке */
#table2 th, 
#table2 td {
  border: 2px solid #0C1527;
}

td {
  text-align: left;
}

th{
  text-align: left;
  background-color: #149EF2;
}
```

Например чтобы задать заголовкам таблицы синюю рамку из сплошной линии, толщиной 1 пиксель - нужно использовать следующее правило:
```css
th {
    border: 1px solid blue;
}
```

Можно использовать подсвойство `border-width` для определения толщины границы. Оно может принимать пиксели и проценты или именованные значения, такие как `medium`.
```css
td, th {
    border: medium dotted blue;
}
```
Ячейки таблицы по умолчанию имеют расстояние между ними, из-за чего появляются двойные границы. Чтобы убрать это пространство, вы можете присвоить элементам `table` свойство `border-collapse`. Значение свойства `border-collapse` по умолчанию - `separate` (разделенная).
```css
body {
  font-family: Arial, sans-serif;
  background-color: #F3F4F6;
  color: #333;
}

table {
  border-collapse: collapse;  /*оно*/
}

th, td {
  border: 2px solid #909092;
}

th {
  background-color: #4A90E2;
  color: white;
}
```
У таблицы может быть несколько строк в качестве дочерних элементов. Псевдоселекторы также могут использоваться для выбора элементов исходя из их порядка или позиции. 

Псевдоселектор `:nth-child(n)` выбирает дочерние элементы исходя из их порядка. Например селектор для выбора второй строки в таблице будет выглядеть следующим образом:
```css
tr: nth-child(2) {
    color: red;
    font-weight: bold;
}
```
Можно использовать псевдо-селектор `:nth-child` для выбора нечетных и четных строк:
```css
body {
  font-family: Arial, sans-serif;
  background-color: #F3F4F6;
  color: #333;
}
table {
  border-collapse: collapse;
}
/* светло-серый для нечетных рядов */
tr:nth-child(odd) {
  background-color: #E9E9E9;  
}
/* белый для четных рядов */
tr:nth-child(even) {
  background-color: #FFFFFF;  
}
th, td {
  border: 2px solid #909092;
}
```


<a id="Стилизация-списков">Стилизация списков</a>
---

- `list-style-type` контролирует тип маркеров
- `list-style-position` контролирует позицию маркеров
- `list-style-image` добавляет пользовательские изображения в качестве маркеров

Стилизация списков улучшает визуальную привлекательность, удобство использования и доступность. В этом уроке вы преобразуете простые списки в визуально привлекательные и хорошо организованные элементы на ваших веб-страницах.

Списки бывают:
- Упорядоченные `<ol>`
- Неупорядоченные `<ul>`

Свойство `list-style` требует 3 значения. Это короткий и простой способ обращения к 3 различным подсвойствам: `type`, `position` и `image`.
```css
ul {
  list-style: square inside none;
}
```

Подсвойство `list-style-type` изменяет маркеры для неупорядоченных и упорядоченных списков. Давайте сначала рассмотрим неупорядоченные списки.
```html
<body>
  <h2>type square</h2>
  <ul class="square">
    <li>first marker</li>
    <li>second marker</li>
  </ul>
  <h2>type circle</h2>
  <ul class="circle">
    <li>first marker</li>
    <li>second marker</li>
  </ul>
  <h2>type disc</h2>
  <ul class="disc">
    <li>first marker</li>
    <li>second marker</li>
  </ul>
  <h2>type none</h2>
  <ul class="none">
    <li>first marker</li>
    <li>second marker</li>
  </ul>
</body>
```
```css
.square {
  list-style-type: square;
}
.circle {
  list-style-type: circle;
}
.disc {
  list-style-type: disc;
}
.none {
  list-style-type: none;
}
body {
  background-color: #232323;
  color: #FFFFFF;
  font-size: 18px;
}
h2 {
  color: #B8A7C2;
  text-align: center;
}
```

Например нужно стилизовать список с ID items с помощью маркеров в виде пустых кружков:
```css
#items {
  list-style-type: circle;
}
```

По умолчанию элементы в упорядоченном списке отмечаются с помощью цифр. Для упорядоченных списков свойство `list-style-type` имеет различные возможные значения.
```html
<body>
  <h1>Types of numbered lists</h1>
  <h2>type: decimal-leading-zero</h2>
  <ol class="zero">
    <li>Harry Potter</li>
    <li>The Hunger Games</li>
    <li>The Da Vinci Code</li>
  </ol>
  <h2>type: decimal</h2>
  <ol class="decimal">
    <li>Pride and Prejudice</li>
    <li>Moby-Dick</li>
    <li>War and Peace</li>
  </ol>
  <h2>type: lower-roman</h2>
  <ol class="l-roman">
    <li>Steve Jobs</li>
    <li>Einstein</li>
    <li>The Diary of a Young Girl</li>
  </ol>
  <h2>type: upper-roman</h2>
  <ol class="u-roman">
    <li>A Song of Ice and Fire series</li>
    <li>The Lord of the Rings</li>
    <li>The Wheel of Time series</li>
  </ol>
</body>
```
```css
.zero {
  list-style-type: decimal-leading-zero;
}
.decimal {
  list-style-type: decimal;
}
.l-roman {
  list-style-type: lower-roman;
}
.u-roman {
  list-style-type: upper-roman;
}
h1,h2 {
  background-color: #FFA055;
  text-align: center;
}
li {
  font-size: 18px;
}
```

Как пример стилизовать списки с классом **songs**, используя римские цифры в верхнем регистре:
```css
.songs {
  list-style-type: upper-roman;
}
```

Можно отмечать элементы списка буквами алфавита, либо в нижнем ```lower-alpha```, либо в верхнем ```upper-alpha``` регистре.
```css
ol {
  color: #F2F2F2;
  text-transform: capitalize;
  list-style-type: upper-alpha;
}
```

Технически возможно стилизовать упорядоченный список с помощью маркеров и неупорядоченный список с помощью чисел, но это семантически не правильно и может сбивать с толку пользователей и поисковые системы.

Рассмотрим позицию маркеров. Свойство `list-style-position` принимает два возможных значения: `inside` и `outside`.
```html
<body>
  <p>list-inside</p>
  <ul id="list-inside">
    <li>When planning a road trip, make sure to check the weather forecast.</li>
    <li>Research and choose your destination based on your interests.</li>
    <li>Book your accommodations in advance to secure the best deals and availability.</li>
  </ul>
<br>
  <p>list-outside</p>
  <ul id="list-outside">
    <li>Start your day by identifying the most important tasks you need to accomplish.</li>
    <li>Allocate dedicated time blocks for specific tasks or projects.</li>
    <li>Plan your day or week in advance to reduce decision-making stress.</li>
  </ul>
</body>
```
```css
/* помещает маркер в текстовую область, 
  внутри элемента*/
#list-inside {
  list-style-position: inside;
}
/* помещает маркер за пределы 
  текстовой области, за пределы элемента*/
#list-outside {
  list-style-position: outside;
}
p {
  text-align: center;
  background-color: #B538E7;
  font-size: 26px;
}
li {
  border: 2px solid #CCCCCC;
  font-size: 18px;
}
```

Например нужны буквенные маркеры внутри текста, когда текст обтекает маркеры:
```css
ol {
  list-style-type: upper-alpha;
  list-style-position: inside;
}
```

Финальное подсвойство, `list-style-image`, позволяет добавить пользовательское изображение в качестве маркера.
```css
ul {
  list-style-image: url('url_image');
}
```
Значение для свойства `list-style-image` - это URL, заключенный в кавычки, следующий за ключевым словом `url`. Он указывает путь к файлу изображения, который будет использован в качестве маркера для элементов списка. По умолчанию значение свойства `list-style-image` равно `none`.

<a id="Проект-Страницы-Профиля-Шаг-3">Проект Страницы Профиля Шаг 3</a>
---

На этом шаге вы стилизуете списки в разделах `#profile` и `#streak`, чтобы улучшить визуальное восприятие страницы.

Задания:

- Переопределите стиль списка по умолчанию от списков в обоих разделах `profile` и `streak`, установив `list-style` на `none`
- Дайте списку в разделе `#streak` контрастный белый фон и добавьте закругленные углы с `border-radius 5px`
- Измените цвет абзацев в разделе `streak` на `#676767`, чтобы текст можно было прочитать на новом фоне

```html
<html>
<head>
  <title>John Doe's Profile</title>
  <style>
    /*Task 1*/
    body {
      background-color: DarkSlateGrey;
      font-family: Arial, sans-serif;
      }
    #profile {
      text-align: center;
      color: #FFFFFF;
      list-style-type: none;
      }  
    #streak {
      background-color: white;
      border-radius: 5px;
      text-align: center;
            }
    div p {
      color: #676767;
    }
    div ul {
      list-style-type: none;
      }
    h2, p {
      text-align: center;
      color: yellow;
      list-style-type: none;
      }
    .active-day {
      color: #00CC00
      }
    .inactive-day {
      color: #CCCCCC 
      }
  </style>
</head>
<body>
  <ul id="profile">
    <img src="https://blob.sololearn.com/courses/ava.png">
    <h2>John Doe</h2>
    <p>🇺🇸USA</p>
    <li>25 Followers</li>
    <li>20 Following</li>
    <li>⭐️1581 XP</li>
  </ul>
  <div id="streak">Streak
    <ul>
      <li class="active-day">M</li>
      <li class="active-day">T</li>
      <li class="active-day">W</li>
      <li class="inactive-day">T</li>
      <li class="inactive-day">F</li>
      <li class="inactive-day">S</li>
      <li class="inactive-day">S</li>
    </ul>
    <p>Current Streak: 3</p>
    <p>Longest Streak: 16</p>
  </div>
</body>
</html>
```

<a id="Стилизация-форм">Стилизация форм</a>
---

- `[attribute]` селектор нацелен на разные типы ввода
- Свойство `border-radius` делает углы закругленными
- **Псевдо-селекторы**, такие как `:hover` и `:visited`, используются для стилизации элементов ввода в разных состояниях

Формы играют важную роль во взаимодействии пользователей на многих веб-сайтах, включая вход в систему, обратную связь и ввод данных. В этом уроке вы научитесь стилизовать формы, чтобы они соответствовали дизайну вашего веб-сайта и обеспечивали плавный пользовательский опыт.

Для создания формы на веб-странице, используется HTML-тег `<form>`. Например так выглядит текстовое поле ввода и метка к нему:
```html
<form>
    <label>Email</label>
    <input type="text">
</form>
```

Можно стилизовать вводы и метки с помощью селекторов элементов:
```html
<form>
  <label for="name">Name: </label>
  <input type="text" id="name"> 
  <br><br>
  <label for="email">Email: </label>
  <input type="email" id="email">
  <br><br>
  <input type="button" value="Send">
</form>
```
```css
body{
  background-color: #0C1527;
}
input {
  border:1px solid #FF9E03;
}
label {
  font-weight: bold;
  color: #FF9E03;
}
```

По умолчанию, элементы ввода имеют границы. Удалить границы из элементов ввода:
```css
input {
    border: none;
}
```

Пример правила CSS для применения шрифта **Arial** в **жирном** стиле ко всем меткам:
```css
label {
    font-family: Arial;
    font-weight: bold;
}
```

Элементы ввода бывают разных типов. Можно нацелиться на разные элементы ввода с помощью **[attribute] селектора**.

```html
<form>
  <label for="name">Name: </label>
  <input type="text" id="name"> 
  <br><br>
  <label for="email">Email: </label>
  <input type="email" id="email">
  <br><br>
  <input type="submit" value="Send">
</form>
```
```css
body{
  background-color: #0C1527;
}
/*[attribute] селектор*/
input[type="text"] {
  border: 1px solid #FF9E03;
  background-color: #17233B;
}
label {
  font-weight: bold;
  color: #FF9E03;
}
```

Это означает, что можно оформлять ввод пользователя. Приведенный ниже код делает текстовый ввод от пользователя белым и жирным.
```html
<form>
  <label for="name">Name: </label>
  <input type="text" id="name"> 
  <br><br>
  <label for="email">Email: </label>
  <input type="email" id="email">
  <br><br>
  <input type="submit" value="Send">
</form>
```
```css
body{
  background-color: #0C1527;
}
/*селектор атрибутов text и email*/
input[type="text"], input[type="email"] {
  border: 1px solid #FF9E03;
  background-color: #17233B;
  color: #FFFFFF;
  font-weight: bold;
}
label {
  font-weight: bold;
  color: #FF9E03;
}
```

Свойство `border-radius` округляет углы элементов, придавая им более мягкий вид. Оно принимает значения в пикселях (`px`) или процентах (`%`). Большие значения создают более округлые углы.

```css
body{
  background-color: #0C1527;
}
/*Округление полей ввода*/
input[type="text"], input[type="email"] {
  border: 1px solid #FF9E03;
  background-color: #17233B;
  color: #FFFFFF;
  font-weight: bold;
  border-radius: 5px;
}
/*Округление кнопки отправки*/
input[type='submit'] {
  background-color: #149EF2;
  border-radius: 5%;
  border: none;
  font-weight: bold;
  color: white;
  width: 70px;
  height: 40px;
  font-size: 18px;
}
label {
  font-weight: bold;
  color: #FF9E03;
}
```

Когда свойству `border-radius` задается одно значение, оно применяет равномерное округление ко всем четырем углам элемента, создавая равномерно округленные углы.

Свойство `border-radius` также может использовать процентные (`%`) значения, которые рассчитываются относительно размеров элемента. Это означает, что применение радиуса 50% к элементу квадратной формы превратит его в круг.

Например, можно стилизовать квадратное изображение с `ID` `avatar`, чтобы сделать его круглым:
```css
#avatar {
    border-radius: 50%;
}
```
Чтобы применить разные значения к разным углам, вы можете предоставить список из 4 значений, разделенных пробелами в этом порядке: верхний-левый, верхний-правый, нижний-правый и нижний-левый.
```css
border-radius: 20px 15px 10px 8px;
/*верхний-левый: 20px
верхний-правый: 15px
нижний-правый: 10px
нижний-левый: 8px*/
```

Так же как и для ссылок, можно использовать псевдоселекторы для стилизации различных состояний кнопок:
```html
<form>
  <label for="name">Name: </label>
  <input type="text" id="name"> 
  <br><br>
  <label for="email">Email: </label>
  <input type="email" id="email">
  <br><br>
  <input type="button" value="Send">
</form>
```
```css
body{
  background-color: #0C1527;
}
input[type="text"], input[type="email"] {
  border: 1px solid #FF9E03;
  background-color: #17233B;
  color: #FFFFFF;
  font-weight: bold;
}
input[type='button'] {
  background-color: #149EF2;
  border-radius: 10px;
  border: none;
  font-weight: bold;
  color: white;
}
/*При наведении мыши на кнопку - меняются ее цвета*/
input[type='button']:hover {
  background-color: #0C1527;
  color: #FF9E03;
  border: 1px solid #FF9E03;
  border-radius: 10px;
}
label {
  font-weight: bold;
  color: #FF9E03;
}
```

По умолчанию, у кнопок есть границы. Удаление границы у кнопок в формах:
```css
input[type="submit"] {
    border: none;
}
```

<a id="Контрольные-вопросы-к-модулю-2">Контрольные вопросы к модулю 2</a>
---

```css
1. Сопоставьте цвет с его шестнадцатеричным представлением:
Красный: [...]
Черный: [...]
Зеленый: [...]

Варианты ответов: #000000, #FF0000, #00FF00.
```
```css
2. Напишите правило CSS, чтобы сделать абзацы синими:
[...] {
    color: [...]([...], 0, [...]);
}

Варианты ответов: p, rgb, 255, .p, 150, 0.
```
```css
3. Дополните код, чтобы получить наиболее яркий возможный красный цвет:
rgb([...], 0, 0)

Варианты ответов: 0, 500, 255.
```
```css
4. Если вы установите ширину элемента на 50%, что это означает?

Варианты ответов:
    [Он займет половину ширины своего родительского элемента],
    [Он займет всю ширину своего родительского элемента],
    [У него будет ширина 50 пикселей].
```
```css
5. Если у div установлен размер шрифта 20px, каким будет размер шрифта абзаца (p), вложенного в div, если мы укажем следующие значения?
200%: [...]
100%: [...]
50%: [...]

Варианты ответов: 20px, 40px, 10px.
```
```css
6. Что контролирует свойство font-weight?

Варианты ответов:
    [Размер текста],
    [Толщина (жирность) текста],
    [Цвет текста].
```
```css
7. Псевдоселекторы позволяют вам выбирать и стилизовать элементы...

Варианты ответов:
    [исходя из их HTML атрибутов],
    [исходя из времени их создания],
    [исходя из их состояния или позиции].
```
```css
8. Сделайте так, чтобы подчеркивание исчезало, когда пользователь нажимает и удерживает ссылку:

a:[...] {
    text-decoration[...];
}

```
```css
9. Селекторы атрибутов используются для выбора элементов...

Варианты ответов:
    [на основе их позиции]
    [на основе родительско-дочерних отношений]
    [на основе их HTML-атрибутов]
```
```css
10. Выберите значения для свойства text-decoration, отображаемого на изображении [синяя надпись, надчеркнутая пунктирной красной линией]
Варианты ответов:
    [blue]
    [red]
    [dashed]
    [overline]
```

<a id="Дизайн-и-макет-страницы">Дизайн и макет страницы</a>
===
<a id="Box-Model">Box Model</a>
---

- **Box Model** рассматривает каждый HTML элемент как коробку, состоящую из **4 слоев**
- **Content**, **padding**, **border** и **margin** могут быть настроены при проектировании веб-страниц
- Вы можете задать значения `padding` и `margin` для разных сторон коробки, запомните **последовательность: верх, право, низ, лево**

**Box Model** - это способ представления о том, как HTML-элементы отображаются на веб-странице. Каждый элемент рассматривается как прямоугольная коробка с четырьмя слоями: содержимое, отступ, рамка и поле. В этом уроке вы узнаете о различных частях **Box Model** и о том, как использовать свойства CSS для контроля их размера и внешнего вида.

**Content box** - это внутренний слой, где отображается контент, такой как текст и изображения.
```html
<p>Discounts</p>
```

Свойства **width** и **height** устанавливают размер содержимого для элемента.
```css
h1 {
  width: 100px;
  height: 20px;
}
```

Все элементы HTML можно классифицировать на **inline** (не требует закрывающего тега) и **block-elements**.

По умолчанию, когда ширина и высота не были установлены, блочные элементы занимают всю доступную ширину.

Полная доступная ширина для элемента уровня блока задается его родителем.

В примере заголовок находится внутри тела, занимая всю ширину экрана (по умолчанию), в то время как абзац занимает всю ширину своего родительского `div`, которая была установлена на половину экрана.

По умолчанию, **inline** элементы, такие как изображения и ссылки, имеют слой контента, который занимает столько ширины, сколько необходимо для отображения контента. Они не используют все доступное пространство, предоставляемое родителем.
```html
<html>
<head>
  <title>Block-level Elements</title>
</head>
<body>
  <h2>Block-level Element 1</h2>
  <div>
  <p>Block-level Element 2</p>
  </div>
  <a href = "example.com">Inline Element</a>
</body>
</html>
```
```css
body {
  font-family: 'Arial', sans-serif;
  margin: 0;
  padding: 0;
}
h2, p, a {
  background-color: #D6C4E9;
}
div{
    width: 50%;
}
```

Свойство `text-align` выравнивает текст в пределах контентного блока элемента.
```css
h1 {
  text-aligh: right;
}
```

По умолчанию, граница будет применена к краям содержимого блока, если только не было добавлено **padding**. Слой `padding` обеспечивает отступ вокруг содержимого блока, чтобы создать дополнительное пространство внутри элемента и отодвинуть границу наружу.
```html
<body>
  <div class="padded-box">
    This is a div with padding.
  </div> <br>
  <div class="default-box">
    This is a div without padding.
  </div>
</body>
```
```css
.padded-box {
  border: 2px solid #FFA310;
  padding: 20px;
  color: #FFFFFF;
}
.default-box {
  border: 2px solid #FFA310;
  color: #FFFFFF;
}

body {
  background-color: #0C1527;
}
```

**Border** является 3-м слоем. Он окружает `padding`. Пример правила, применяющего сплошную синюю рамку толщиной `1px` к кнопкам на странице:
```css
button {
  border: 1px solid blue;
}
```

Таким образом первые три слоя модели Box, начиная изнутри, распологаются следующим образом: **Content -> Padding -> Border**.

По умолчанию, значение отступа для большинства HTML элементов равно 0. **Padding** представляет собой область между содержимым и границами слоев. Можно задать разные значения отступа для каждой из 4 сторон. Для этого нужно добавить 4 значения, разделенные пробелами, в следующем порядке: **верх**, **право**, **низ**, **лево**.
```css
p {
  padding: 5px 13px 7px 12px;
}
```

Используйте `padding-top`, `padding-right`, `padding-bottom` и `padding-left` для того, чтобы нацелиться на конкретные стороны. 

Пример отступа в `10px` с левой стороны элемента `div`:
```css
div {
  padding-left: 10px;
}
```

В качестве примера правило CSS для применения отступа в 10px и границы в 3px ко всем абзацам
```css
p {
  padding: 10px;
  border: 3px solid;
}
```

Чтобы вычислить **общие размеры блока**, нужно сложить размеры 3 слоев: содержимого, отступов и рамки.

**Margin** - это самый внешний слой в Box Model. Он оборачивает слой `border` и создает дополнительное пространство вне элемента, между границей и соседними элементами. Margin прозрачен, обеспечивает разделение и предотвращает перекрытие.

Свойство `margin` можно использовать для применения равномерного отступа со всех сторон элемента HTML:
```html
<body>
  <div class="default-box">
    This is a div without padding and 
    margin.
  </div>  
  <div class="custom-box1">
    This is a div with padding.
  </div> <br>
  <div class="custom-box2">
    This is a div with padding and margin.
  </div>
</body>
```
```css
.custom-box2 {
  border: 2px solid #FFA310;
  padding: 10px;
  margin: 10px;
  color: #FFFFFF;
}

.custom-box1 {
  border: 2px solid #FFA310;
  padding: 10px;
  color: #FFFFFF;
}
.default-box {
  border: 2px solid #FFA310;
  color: #FFFFFF;
}

body {
  background-color: #0C1527;
}
```

Аналогично отступам `padding`, можно установить значения полей `margin` со всех 4-х сторон элемента (верх, право, низ, лево):
```css
p {
  margin: 5px 10px 8px 15px;
}
```


<a id="Flexbox-Layout">Flexbox Layout</a>
---

- Можно переопределить поведение элементов *встроенного* и *блочного* уровня с помощью свойства `display`
- **Flexbox layout** располагает элементы внутри контейнера в одном направлении: либо в ряд, либо в столбец
- `display: flex` делает контейнер гибким
- `flex-grow` и `flex-shrink` контролируют пропорции элементов в flex-контейнере для создания адаптивных дизайнов

Современные веб-сайты разработаны так, чтобы отлично выглядеть на любом устройстве, независимо от размеров экрана. В этом уроке вы научитесь использовать **Flexbox layout** для расположения HTML-элементов для более адаптивных дизайнов.

Каждый HTML элемент может быть классифицирован как строчный или блочный.
- полная доступная ширина - блочный (block-level), всегда начинается с новой строки; 
- ширина его содержимого - строчный (inline), НЕ начинается с новой строки.

Свойство `display` может переопределить стандартные поведения строчных и блочных элементов. Заставим элемент `<a>` вести себя как блочный элемент:
```html
<body>
  <h1>My Blog</h1>
  <p>Today, I went to the <a href="#">park</a> 
  and saw some birds.</p>
</body>
```
```css
a {
  display: block;
  border: #4478B1 solid;
  text-decoration: none;
}
```

Изображения по умолчанию являются строчными элементами, вот как можно переопределить их поведение:
```css
img {
  display: block;
}
```

Параграфы являются элементами уровня блока. По умолчанию они всегда начинаются с новой строки. Вот как можно переопределить это поведение, чтобы показать две колонки абзацев на изображении:
```css
p {
  display: inline;
}
```

**Макет Flexbox** упрощает создание и дизайн адаптивных страниц. Он создает макет в виде строки или колонки.

Flexbox используется для автоматического расположения элементов внутри контейнера. Чтобы создать гибкий (flex) контейнер, установите свойство `display` в значение `flex`.
```html
<body>
  <div>
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
    <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
  </div>
</body>
```
```css
div {
  border: 1px solid rgb(189, 185, 185);
  box-shadow: 0 2px 4px #000000;
  display: flex;
}

p {
  border: 1px solid rgb(189, 185, 185);
  margin-left: 2px;
}
```

По умолчанию, дочерние элементы в контейнере `flex` автоматически располагаются в 1 ряд, пытаясь максимально эффективно использовать доступное пространство.

Например как сделать элемент `div` контейнером `flex`:
```css
div {
  display: flex;
}
```

Чтобы автоматически расположить дочерние элементы внутри родительского контейнера, вам нужно применить `display: flex` к контейнеру (родительскому элементу).

По умолчанию, дочерние элементы в контейнере `flex` располагаются в ряд (горизонтально). Установите подсвойство `flex-direction` в значение `column`, чтобы расположить элементы вертикально внутри контейнера `flex`.
```html
<body>
  <h2>This is a row flex container</h2>
  <div class="container-row">
    <p>Item 1</p>
    <p>Item 2</p>
    <p>Item 3</p>
  </div>

  <h2>This is a column flex container</h2>
  <div class="container-column">
    <p>Item 1</p>
    <p>Item 2</p>
    <p>Item 3</p>
  </div>
</body>
```
```css
.container-row {
  display: flex;
  flex-direction: row;
  border: 1px solid red;
  margin-bottom: 25px;
}

.container-column {
  display: flex;
  flex-direction: column;
  border: 1px solid blue;
}

p {
  border: 1px solid rgb(150, 150, 150);
  padding: 8px;
  margin: 5px;
  font-size: 18px;
}

h2 {
  border: 1px solid purple;
  box-shadow: 5px 5px #000000;
}
```

`flex` контейнер с элементами, расположенными вертикально:
```css
div {
  display: flex;
  flex-direction: column;
}
```

По умолчанию, дочерние элементы в контейнере `flex` все попытаются уместиться на одной линии. Можно изменить это и разрешить элементам переноситься по мере необходимости с помощью подсвойства `flex-wrap`. Опять же, элементы будут автоматически располагаться, и количество строк будет зависеть от размера экрана.
```html
<body>
  <p>Items that do not wrap to the next line:</p>
  <div id="nowrap">
    <button>Submit</button>
    <button>Revert</button>
    <button>Delete all</button>
  </div>
  <p>Items that wrap to the next line if needed:</p>
  <div id="wrap">
    <button>Submit</button>
    <button>Revert</button>
    <button>Delete all</button>
  </div>
</body>
```
```css
#wrap {
  padding: 20px;
  margin-bottom: 10px;
  border: 1px solid rgb(189, 185, 185);
  display: flex;
  flex-wrap: wrap;
}

#nowrap {
  padding: 20px;
  border: 1px solid rgb(189, 185, 185);
  display: flex;
  flex-wrap: nowrap;
}

button {
  border: 1px solid rgb(189, 185, 185);
  box-shadow: 0 2px 4px #000000;
  background-color: rgb(247, 228, 203);
  margin: 5px;
  font-size: 30px;
}

p {
  font-size: 24px;
  font-family: Arial, Helvetica, sans-serif;
  background-color: blueviolet;
  color: #FFFFFF;
}
```

Таким образом, чтобы автоматически расположить элементы с использованием макета **Flexbox**, сначала нужен родительский контейнер, который установлен как `flex`.

По умолчанию, дочерние элементы внутри flex-контейнера будут располагаться автоматически. Пространство, которое занимает каждый элемент, будет зависеть от его содержимого. Так что возможно, что некоторые элементы будут отображаться больше других, если они имеют больше содержимого.
```html
<body>
  <div id="container">
    <p id="small-content">A quick brown fox.</p>
    <p id="large-content">The quick brown fox jumps over the lazy dog. </p>
  </div>
</body>
```
```css
#container {
  display: flex;
  border: 1px solid #333;
  padding: 10px;
  margin: 10px;
}
#small-content {
  border: 1px solid black;
  margin-right: 2px;
}

#large-content {
  border: 1px solid black;
}
```

Чтобы иметь больший контроль над пространством, которое занимают элементы внутри контейнера `flex`, можно установить подсвойство `flex-grow`. 

Подсвойство `flex-grow` дает элементу возможность увеличиваться, чтобы занять больше пространства, когда это пространство доступно в контейнере (больший экран). Оно принимает безразмерное значение в качестве пропорции.

Пример показывает три `flex` элемента с относительными пропорциями 1, 2 и 3.
```html
<body>
  <div id="container">
    <p id="item1">Element 1</p>
    <p id="item2">Element 2</p>
    <p id="item3">Element 3</p>
  </div>
</body>
```
```css
#container {
  border: 1px solid #818181;
  box-shadow: 2px 2px #474747;
  display: flex;
}

#item1 {
  flex-grow: 1;
  border: 1px solid #868686;
  box-shadow: 2px 2px black;
  margin-right: 10px;
  margin-left: 5px;
}

#item2 {
  flex-grow: 2;
  border: 1px solid #868686;
  box-shadow: 2px 2px black;
  margin-right: 10px;
}

#item3 {
  flex-grow: 3;
  border: 1px solid #868686;
  box-shadow: 2px 2px black;
  margin-right: 5px;
}
```

Свойство `flex-grow` позволяет элементам в flex-контейнере занимать больше пространства на больших экранах. Элемент `item2` займет в два раза больше места, чем элемент `item1`.

Возможные значения для `flex-grow` - это целые неотрицательные числа (0, 1, 2, 3, ...). Это безразмерные значения, которые служат пропорциями для размеров элементов.

Значения `flex-grow` `1` к `1` к `1` приведут к тому, что все три элемента будут занимать одинаковое пространство, независимо от размера экрана.

По умолчанию, элементы внутри flex-контейнера имеют значение flex-grow равное 0. Это означает, что когда имеется доступное пространство (например, на большем экране), они не всегда будут увеличиваться.
```html
<body>
  <div id="container">
    <p class="item">Item 1</p>
    <p class="item">Item 2</p>
  </div>
</body>
```
```css
#container {
  display: flex;
  border: 1px solid black;
}

.item {
  flex-grow: 0;
  border: 1px solid green;
  margin-right: 2px;
}
```

`flex-shrink` делает противоположное `flex-grow`. Он используется для адаптации дизайна к меньшим экранам. 

Это значение определяет, насколько сильно `flex` элемент будет сжиматься относительно остальных элементов, когда в `flex` контейнере недостаточно места. Более высокое значение означает, что элемент будет сжиматься больше.
```html
<body>
  <div>
    <p id="item1">In a world increasingly driven by technology and automation, the importance of nurturing human connection and empathy cannot be overstated. </p>
    <p id="item2">In the pursuit of personal growth and fulfillment, resilience emerges as an invaluable trait. Life is rife with challenges, setbacks, and unexpected turns.</p>
  </div>
</body>
```
```css
div {
  padding: 20px;
  border: 1px solid rgb(189, 185, 185);
  box-shadow: 0 2px 4px #000000;
  display: flex;
}

#item1 {
  flex-shrink: 1;
  flex-grow: 1;
}

#item2 {
  flex-shrink: 2;
  flex-grow: 1;
}

p {
  border: 1px solid rgb(189, 185, 185);
  box-shadow: 0 2px 4px #000000;
  background-color: rgb(247, 228, 203);
  margin: 5px;
}

body {
  font-family: Arial, sans-serif;
}
```

Значение по умолчанию для `flex-shrink` равно единице.

Пример: элемент `item2` уменьшается больше, когда в контейнере не хватает места из-за меньшего экрана:
```css
#item1 {
  flex-shrink: 1;
}
#item2 {
  flex-shrink: 2;
}
```


<a id="Позиционирование">Позиционирование</a>
---

- По умолчанию элементы располагаются в том порядке, в котором они отображаются в коде HTML, это называется **статическим** расположением
- Общей точкой отсчёта в веб-разработке является **верхний левый угол**
- Свойство `position` точно контролирует, где элементы размещаются на странице

При дизайне профессиональных страниц, вам скорее всего потребуется расположить элементы в определенных позициях. Вот тут в игру вступает позиционирование CSS! В этом уроке вы научитесь располагать элементы точно там, где вы хотите, на страницах.

Свойство `position` дает больше контроля над размещением элементов HTML в проектах. По умолчанию все элементы имеют позицию `static`. Это означает, что они не позиционированы никаким особым образом, и браузер отображает их один за другим, в том порядке, в котором они появляются в HTML-коде.

**Система координат** страницы используется в веб-дизайне для точного определения и описания позиции элементов на странице. Точкой отсчета (или началом) является *верхний левый угол*.
- **Ось x** (или горизонтальная) идет слева направо. 
- **Ось y** (или вертикальная) идет сверху вниз.

С использованием позиционирования `absolute`, можно задать точное положение элементов на странице. Так-же, используя left и top, можно добавить горизонтальные и вертикальные координаты в пикселях.
```html
<body>
  <button id="item1">Element 1</button>
  <button id="item2">Element 2</button>
  <button id="item3">Element 3</button>
</body>
```
```css
#item1 {
  position:absolute;
  left: 10px;
  top: 20px;
}
#item2 {
  position:absolute;
  left: 50px;
  top: 60px;
}
#item3 {
  position:absolute;
  left: 80px;
  top: 120px;
}
```

Позиционирование элемента HTML означает позиционирование его блока, точнее, *верхнего левого угла* блока.

Применение `property: absolute` к элементу удаляет элемент из его статического потока (порядок элементов). В примере, второй элемент абсолютно позиционирован, это означает, что он больше не является вторым элементом в потоке.
```html
<body>
  <div id="item1"></div>

  <div id="item2"></div>
</body>
```
```css
/* Статическая позиция по умолчанию */
#item1 {
  background-color: #0000FF;
  height: 100px;
  width: 300px;
}

/* Абсолютное позиционирование */
#item2 {
  position: absolute;
  left: 50px;
  top: 40px;
  background-color: #FF0000;
  height: 100px;
  width: 300px;
}
```

Элемент с `position: fixed` всегда остается на том же месте, даже если страница прокручивается:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Header Social Network Feed</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Fixing header -->
    <header class="fixed-header">
        MySocialApp
    </header>
    <div class="feed">
        <!-- Create several posts for the newsfeed -->
        <div class="post">
            <strong>John Doe</strong>
            <p>Having a great day at the park!</p>
        </div>
        <div class="post">
            <strong>Jane Smith</strong>
            <p>Check out this amazing recipe I found!</p>
        </div>
        <div class="post">
            <strong>Alice Adams</strong>
            <p>Spending time with family is the best.</p>
        </div>
        <div class="post">
            <strong>Bob Brown</strong>
            <p>Attending a concert tonight! So excited!</p>
        </div>
        <div class="post">
            <strong>Charlie Chaplin</strong>
            <p>Learning to cook has been a rewarding journey.</p>
        </div>
        <div class="post">
            <strong>Dana White</strong>
            <p>Who else loves hiking during the summer?</p>
        </div>
        <div class="post">
            <strong>Edward Stone</strong>
            <p>Reading a fantastic book about space exploration.</p>
        </div>
        <div class="post">
            <strong>Fiona Frost</strong>
            <p>Visited the museum today and learned so much!</p>
        </div>
        <div class="post">
            <strong>George Graham</strong>
            <p>Saw a brilliant play at the theatre today.</p>
        </div>
        <div class="post">
            <strong>Hannah Hill</strong>
            <p>Photography has become a new hobby of mine.</p>
        </div>
        <!-- ... Feel free to add more posts if needed ... -->
    </div>
</body>
</html>
```
```css
body {
    font-family: Arial, sans-serif;
}
.fixed-header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    padding: 10px 0;
    background-color: #cc005c;
    color: white;
    text-align: center;
}
.feed {
    margin-top: 50px;
    padding: 10px;
}
.post {
    border-bottom: 1px solid #ccc;
    padding: 10px 0;
    margin-bottom: 10px;
}
``` 

`relative` позиционированные элементы берут статическую позицию в качестве отсчета. Таким образом, верхний левый угол статической позиции становится новым отсчетом.
```html
<body>
  <div>First</div>
  <div class="special">Second</div>
  <div>Third</div>
</body>
```
```css
div {
    width: 80%;
    margin: 10px 0px;
    border: 1px solid #747171;
    text-align: center;
}

.special {
    background-color: #FFD700;
    position: relative;
    /*сдвиг слева*/
    left: 20px;
}
```

По умолчанию, `relative` делает статическую позицию элемента новой точкой отсчёта.

Пример правила для размещения элемента на основе его статического положения:
```css
#element {
  position: relative;
  left: 30px;
  top: 15px;
}
```

Чтобы точно расположить дочерние элементы по отношению к позиции родителя, нужно установить для родителя `position: relative`. Это сделает верхний левый угол родительского блока новой точкой отсчета (началом координат):
```html
<body>
  <div id="parent">
    <button id="child">Accept</button>
  </div>
</body>
```
```css
#parent {
  border:solid;
  width: 150px;
  height: 80px;
  left: 40px;
  top: 60px;
  position: relative;
}

#child {
  position:absolute;
  top: 10px;
  left: 20px
}
```

`relative` и `absolute` используются в комбинации для позиционирования дочерних элементов относительно их родителей. 
- Родитель: `position: relative;`
- Дочерний: `position:absolute;`

Если у родителя не установлена позиция, ссылкой будет ближайший предок со свойством, установленным на `relative`:
```html
<body>
  <div id="grandparent">
    <div id="parent">
      <button id="child">Click me</button>
    </div>
  </div>
</body>
```
```css
#grandparent {
  position: relative;
  width: 250px;
  height: 150px;
  border: 1px solid;
}

#parent {
  width: 150px;
  height: 100px;  
  border: 1px solid blue;
  margin: 40px 20px;
}

#child {
  position: absolute;
  left: 150px;
  top: 110px;
}
```

Если ни у одного из предков не установлено свойство `position` со значением `relative`, то точкой отсчета для позиционирования является `body` (родитель всех элементов).

В дополнение к `top` и `left` вы также можете использовать `bottom` и `right` для контроля позиции элементовw
```html
<body>
  <div id="parent">
      <button id="child">Click me</button>
  </div>
</body>
```
```css
#parent {
  position: relative;
  width: 150px;
  height: 100px;
  border: 1px solid;
}

#child {
  position: absolute;
  /* правый и нижний края дочернего 
  элемента будут выровнены с правым и 
  нижним краями #parent */
  right: 0px;
  bottom: 0px;
}
```


<a id="Проект-страницы-профиля-Шаг-4">Проект страницы профиля Шаг 4</a>
---

Вы вступаете в захватывающую территорию сейчас. Вы будете использовать модель **Box** для улучшения эстетики и читаемости вашей страницы.

На этом шаге вы настроите отступы и поля.

Задачи:

1. Примените `display: inline` к элементам списка в разделе `profile` и добавьте вокруг них отступ `15px`
2. Добавьте отступ сверху `10px` ко всему разделу `streak` (контейнер)
3. Примените `display: inline` к списку в разделе `streak` и установите отступ и поле по `5px`
4. Примените `display: inline` к абзацам в разделе `streak` и добавьте отступ `10px`
```html
<html>
<head>
  <title>John Doe's Profile</title>
  <style>
    /*Task 1*/
    body {
      background-color: DarkSlateGrey;
      font-family: Arial, sans-serif;
      }
    #profile {
      text-align: center;
      color: #FFFFFF;
      list-style-type: none;
      display: inline; /*Первое задание*/
      margin: 15px; /*Первое задание*/
      }  
    #streak {
      padding: 10px; /*Второе задание*/
      top: 15px;
      background-color: white;
      border-radius: 5px;
      text-align: center;
            }
    #streak p {
      display: inline  /*Четвертое задание*/
      //margin: 10px;  /*Четвертое задание*/
    }
    div {
      margin: 10px; /*Добавил от себя, 
      связано с заданием 2*/
    }
    div p {
      color: #676767;
    }
    div ul {
      display: inline;  /*Третье задание*/
      padding: 5px;  /*Третье задание*/
      margin: 5px;  /*Третье задание*/
      list-style-type: none;
      }
    h2, p {
      text-align: center;
      color: yellow;
      list-style-type: none;
      }
    .active-day {
      color: #00CC00
      }
    .inactive-day {
      color: #CCCCCC 
      }
  </style>
</head>
<body>
  <ul id="profile">
    <img src="https://blob.sololearn.com/courses/ava.png">
    <h2>John Doe</h2>
    <p>🇺🇸USA</p>
    <li>25 Followers</li>
    <li>20 Following</li>
    <li>⭐️1581 XP</li>
  </ul>
  <div id="streak">Streak
    <ul>
      <li class="active-day">M</li>
      <li class="active-day">T</li>
      <li class="active-day">W</li>
      <li class="inactive-day">T</li>
      <li class="inactive-day">F</li>
      <li class="inactive-day">S</li>
      <li class="inactive-day">S</li>
    </ul>
    <p>Current Streak: 3</p>
    <p>Longest Streak: 16</p>
  </div>
</body>
</html>
```


<a id="Фоны">Фоны</a>
---

- `background-image` закрашивает фон изображением
- `background-repeat` и `background-position` контролируют замощение и позицию изображения
- `background-size` контролирует область, закрашиваемую изображением

Фоны могут оказывать драматическое влияние на общий внешний вид и ощущение от веб-сайта. В этом уроке вы научитесь настраивать фоны ваших страниц и их элементов.

`background-color` - CSS свойство, которое устанавливает цвет фона для элемента. В примере правило CSS для жёлтого заголовка `h1` с синим фоном:
```css
h1 {
  color: yellow;
  background-color: blue;
}
```

Можно добавить изображение в качестве фона для элемента! Для этого нужно использовать свойство `background-image`, указав URL изображения в кавычках, например так:
```html
<body>
  <h1>Morning Bliss Coffee</h1>
  <p>Where every sip feels like 
  the embrace of the morning sun.</p>
</body>
```
```css
body {
  background-image: url('https://blob.sololearn.com/courses/coffee.jpeg');
}
```

С помощью контейнера для группы элементов HTML `<div>` - можно применять фоны к группам элементов или различным секциям страницы. Например добавить фоновое изображение элементу `div` с классом `container1`:
```html
<div class="container1">
  <h2>Cats</h2>
  <p>Cats are the best pets</p>
  <p>Cats are adorable</p>
</div>
```
```css
.container1 {
  background-image: url('cat.png');
}
```

Если естественный размер изображения меньше пространства, которое вы хотите им заполнить, изображение по умолчанию будет повторяться (или замощаться), чтобы покрыть всю область рисования.

Вы можете установить `background-repeat` в значение `no-repeat`, в таком случае изображение появится только один раз (расположенное в верхнем левом углу), и область рисования фонового изображения не обязательно будет полностью покрыта.
```html
<div class="box1">
</div>

<div class="box2">
</div>
```
```css
.box1 {
  background-image: url('https://blob.sololearn.com/courses/logo1.png');
  background-repeat: repeat; /*default*/
  height: 150px;
  width: 150px;
  border: 1px solid;
  margin-bottom: 10px;
}

.box2 {
  background-image: url('https://blob.sololearn.com/courses/logo1.png');
  background-repeat: no-repeat;
  height: 150px;
  width: 150px;
  border: 1px solid;
}
```
Пример: установить изображение `logo` в качестве фона для элемента с ID `demo`. Изображение не должно повторяться:
```css
#demo {
  background-image: url("logo.png");
  background-repeat: no-repeat;
}
```

Можно использовать значения `repeat-x` или `repeat-y` для контроля направления размещения плитки. Помните, что **ось x** идет **от левого края к правому**, а **ось y - сверху вниз**.
```css
.box1 {
  background-image: url('https://blob.sololearn.com/courses/logo1.png');
  background-repeat: repeat-x;
  height: 150px;
  width: 150px;
  border: 1px solid;
  margin-bottom: 10px;
}

.box2 {
  background-image: url('https://blob.sololearn.com/courses/logo1.png');
  background-repeat: repeat-y;
  height: 150px;
  width: 150px;
  border: 1px solid;
}
```

В итоге, `background-repeat` может принимать следующие значения:
- `no-repeat` - изображение появится один раз, область рисования фонового изображения не будет полностью покрыта
- `repeat-x` - направление размещения изображения слева-направо по горизонтали в один ряд
- `repeat-y` - направление размещения изображения сверху-вниз по вертикали в один ряд
- `repeat` - изображение будет повторяться (или замощаться), чтобы покрыть всю область рисования

Помните, что верхний левый угол является опорным при позиционировании элементов. Используйте свойство `background-position` для размещения изображения на фоне. 

Например нужно расположить изображение на 15 пикселей вправо и 10 пикселей вниз:
```css
body {
  background-position: 15px 10px;
}
```

Свойство `background-position` может принимать **пиксели**, **проценты** и **ключевые слова**, такие как `top`, `left`, `right`, `center`, `bottom`.
```css
#box1 {
  background-image: url('https://sololearnassets.azureedge.net/sl-logo.png');
  background-repeat: no-repeat;
  background-position: bottom center;
  height:150px;
  padding: 10px;
  margin-bottom: 15px;
  border: 1px solid black;
}
#box2 {
  background-image: url('https://sololearnassets.azureedge.net/sl-logo.png');
  background-repeat: no-repeat;
  background-position: top right;
  height:150px;
  padding: 10px;
  border: 1px solid black;
}
```

Пример: позиция фонового изображения в верхнем правом углу:
```css
div {
  background-position: right top;
}
```

Свойство `background-size` контролирует размеры фонового изображения. **Первое значение** представляет **ширину**, а **второе значение - высоту**.

Например код, который устанавливает фоновое изображение с шириной `50px` и высотой `30px`:
```css
div {
  background-size: 50px 30px;
}
```

Свойство `background-size` также имеет 2 ключевых значения для контроля того, как изображение вписывается в рамку. Ни одно из них не изменит пропорции изображения:
- `contain` масштабирует изображение так, чтобы показать всё изображение как можно большим. Это может привести к замощению или пустому пространству.
- `cover` масштабирует изображение так, чтобы полностью покрыть всю область рисования. Возможно, будет показана только часть изображения, если пропорции отличаются.
```html
<div id="container1">
  contain
</div>

<div id="container2">
  cover
</div>
```
```css
#container1 {
  background-image: url('https://sololearnassets.azureedge.net/sl-logo.png');
  background-repeat: no-repeat;
  background-size: contain;
  height: 150px;
  padding: 10px;
  border: 1px solid black;
  margin-bottom: 10px;
}
#container2 {
  background-image: url('https://sololearnassets.azureedge.net/sl-logo.png');
  background-repeat: no-repeat;
  background-size: cover;
  height: 150px;
  padding: 10px;
  border: 1px solid black;
}
```
Пример кода, когда изображение полностью помещается внутри контейнера:
```css
div {
  background-size: contain;
}
```

<a id="Контрольные-вопросы-к-модулю-3">Контрольные вопросы к модулю 3</a>
---

```css
1. Установите padding равным 10px для всех сторон элементов button:
button {
  [...]: [...];
}

Варианты ответов: padding-all, 10px, padding, padding-left.
Ответ: padding: 10px;
```
```css
2. Код для размещения 3 элементов в вертикальном макете Flexbox:
div {
  display: [...];
  flex-[...]: [...];
}

Варианты ответов: direction, column, wrap, flex, row, inline.
Ответ:   display: flex;
  flex-direction: column;
```
```css
3. Код для переноса элементов flex на следующую строку, когда не хватает горизонтального пространства:
div {
  [...]: flex;
  [...]-wrap: [...];
}

Варианты ответов: wrap, flex, display.
Ответ:   display: flex;
       flex-wrap: wrap;
```
```css
4. Сопоставьте числа с координатами правого нижнего угла заголовка:
x: [...]
y: [...]

Варианты ответов: 100px, 50px, 150px.
Ответ: x: 150px; y: 50px.
```
```css
5. Завершите позиционирование кнопки, используя её родителя (установленного на позицию: relative) в качестве эталона:
#button {
  position: [...];
}

Варианты ответов: relative, absolute, static.
Ответ: position: absolute;
```
```css
6. Завершите, чтобы установить изображение как фон:
div {
  background-[...]: [...]('image.png[...]);
}

Варианты ответов: url, image, png, ', position.
Ответ: background-image: url('image.png');
```
```css
7. Завершите, чтобы получить заголовок на изображении:
h1 {
  text-align: [...];
  border; 1px,[...], [...];
}

Варианты ответов: нет.
Ответ: text-align: center;
           border: 1px, solid, blue;
```
```css
8. Переставьте слои Боксовой Модели от внешнего к внутреннему:

Margin
Border
Padding
Content
```
```css
9. Сделайте так, чтобы фоновое изображение полностью помещалось внутрь блока и располагалось в его центре:
.box {
  background-[...]: url('books.png');
  background-[...]: center;
  background-size: [...]; 
}

Варианты ответов: нет.
Ответ: background-image: url('books.png');
    background-position: center;
        background-size: contain;
```
```css
10. Дополните код, чтобы стилизовать изображение слева так, чтобы расстояние между двумя изображениями составляло 15px:
#pic {
  margin-[...]: [...];
}

Варианты ответов: нет.
Ответ: margin-right: 6px;
```


<a id="Переходы-и-Преобразования">Переходы и Преобразования</a>
===
<a id="Преобразования">Преобразования</a>
---

- **Трансформации** используются для создания визуальных эффектов, связанных с движением
- Вы можете перемещать, масштабировать и вращать элементы с помощью свойства `transform`


Визуальные эффекты, такие как движущиеся элементы, делают вашу страницу более интересной для пользователя. В этом уроке вы научитесь масштабировать, перемещать и вращать элементы с помощью **CSS transformations**.

Трансформации обычно запускаются действиями пользователя. `transform: translate` переставляет элемент в горизонтальном и/или вертикальном направлениях. Предоставление одного значения перемещает элемент в горизонтальном направлении.

Следующий код демонстрирует перемещение элемента на `50px` в горизонтальном направлении, когда элемент активен (нажат):
```css
div:active {
  transform: translate (50px);
}
```

Трансформации не являются постоянными изменениями. Они используются для создания визуальных эффектов. Когда `translate` используется с 2 значениями, визуальный эффект перемещает элемент в горизонтальном и вертикальном направлениях.

Пример визуального эффекта, который перемещает элемент на `25px` вправо и на `10px` вниз при наведении:
```css
div:hover {
  transform: translate (25px, 10px);
}
```

**Горизонтальное** и **вертикальное** направления имеют **2 значения**: 
- **Положительные значения** перемещают элемент **вправо и вниз**.
- **Отрицательные значения** перемещают элемент **влево и вверх**.

В следующем прмере объект `card`, когда становится активен (нажат) - перемещается `25px` влево, и `50px` вниз.
```html
<body>
  <div id="card"></div>
</body>
```
```css
#card {
  width: 150px;
  height: 150px;
  background-color: #3498DB;
  margin: 80px;
  z-index: 10;
}

#card:active {
  transform: translate(-25px, 50px);
}
```

В следующем примере - перемещение элемента на `50px` вправо и на `100px` вверх:
```css
transform: translate(50px, -100px);
```

`transform: scale` делает элемент больше или меньше, сохраняя пропорции. Возможные значения - это коэффициенты масштабирования (1 - это оригинальный размер). 
- 2 означает в два раза больше оригинального размера, 
- 0.5 - в два раза меньше оригинального размера.
```html
<body>
  <div class="blue"></div>
  <div class="yellow"></div>
</body>
```
```css
.blue:active {
  transform: scale(1.5);  
}
.yellow:active {
  transform: scale(0.7);  
}
.blue {
  width: 150px;
  height: 150px;
  background-color: #3498DB;
  border-radius: 20px;
  margin: 50px;
}
.yellow {
  width: 150px;
  height: 150px;
  background-color: #DBBC34;
  border-radius: 20px;
  margin: 50px;
}
```

C помощью `transform: rotate` - можно вращать элементы.

Следующий код демонстрирует при нажматии на элемент - поворот его на 15 градусов по часовой стрелке:
```html
<body>
  <div></div>
</body>
```
```css
div:active {
  /* вращает карту на 15 градусов при нажатии */
  transform: rotate(15deg);  
}

div {
  width: 150px;
  height: 150px;
  background-color: #3498DB;
  border-radius: 20px;
  margin: 40px;
}
```

Отрицательные значения приводят к вращению против часовой стрелки.
```html
<body>
  <div class="blue"></div>
  <div class="yellow"></div>
</body>
```
```css
.blue:active {
  /*по часовой стрелке*/
  transform: rotate(15deg);  
}

.yellow:active {
  /*против часовой стрелки*/
  transform: rotate(-15deg);  
}

.blue {
  width: 150px;
  height: 150px;
  background-color: #3498DB;
  border-radius: 20px;
  margin: 50px;
}

.yellow {
  width: 150px;
  height: 150px;
  background-color: #DBBC34;
  border-radius: 20px;
  margin: 50px;
}
```

По умолчанию, вращения происходят *вокруг центра элемента*. Используйте `transform-origin` для изменения точки, вокруг которой происходит вращение. 

`transform-origin` требует горизонтального и вертикального положения новой точки отсчета:
```html
<body>
  <div class="card"></div>
  <div class="empty"></div>
</body>
```
```css
.card:active {
  transform: rotate(30deg);
  /*устанавливает точку в верхнем левом углу*/
  transform-origin: top left;
}

.card {
  position: absolute;
  width: 150px;
  height: 150px;
  background-color: #3498DB;
  border-radius: 20px;
  margin-left: 81px;
  margin-top: 1px;
  z-index: 10;
}

.empty {
   height: 150px;
   width: 150px;
   margin: 80px;
   border: 1px solid black;
}
```

В следующем примере, элемент `.card` - поворачивается на 30 градусов против часовой стрелки, относительно его верхнего левого угла:
```css
.card {
  transform: rotate (-30deg);
  transform-origin: top left;
}
```

Поворот по часовой стрелке, относитльно верхнего правого угла:
```css
transform: rotate (45deg);
transform-origin: top right;
````

Можно применять комбинации преобразований к элементу:
```html
<body>
  <div></div>
</body>
```
```css
div {
  width: 150px;
  height: 150px;
  background-color: #3498DB;
  border-radius: 20px;
  margin: 50px;
}
div:active {
  transform: translate(100px, 150px) 
  rotate(70deg) scale(1.5);
}
```

Переместить элемент на 20px вверх:
```css
transform: translate (0px, -20px);
```


<a id="Переходы">Переходы</a>
---

- Используйте `transition` для создания визуальных эффектов, которые меняются от одного значения свойства к другому
- Переходы требуют **свойство(а)**, **начальное значение**, **конечное значение**, **продолжительность** и **триггер**
- Вы можете применять эффекты перехода к трансформациям

Современные веб-сайты содержат анимированные элементы, которые завораживают, направляют и даже влияют на поведение пользователей. В этом уроке вы научитесь создавать анимации с помощью **CSS transitions**.

Псевдоселекторы играют важную роль в создании переходов для анимаций.
- `:active` - элемент при нажатии
- `:hover` - элемент под указателем

Анимация создает визуальные эффекты изменения в элементах HTML. Анимация создается, когда происходят визуальные изменения в течении определенного промежутка времени.

**CSS переходы** - это изменения свойств элемента, которые происходят в течение определенного периода времени. Они могут быть применены к широкому спектру свойств и элементов.

Для перехода требуется как минимум **свойство** (которое будет изменяться), его **начальное значение**, его **конечное значение**, **продолжительность** и **триггер**.
```html
<p>Press & hold</p>
```
```css
p {
  font-size: x-large;
  color: white;
  width: 40%;
  background-color: blueviolet;
  transition: width 3s;
}
p:active {
  width: 100%;
}
```
Пример перехода:
```css
#element {
  color: red;
  transition: color 3s;
}
#element:hover {
  color: yellow;
}
```
- Cвойство, которое меняется: `color`
- Начальное значение: `red`
- Конечное значение: `yellow`
- Длительность: `3s`

Следующий переход - изменяет ширину элемента в течение 3 секунд при наведении:
```css
#element {
  width: 20%;
  transition: width 3s;
}
#element:hover {
  width: 100%;
}
```

Можно изменить несколько свойств сразу в переходе. Убедитесь, что каждый набор инструкций для изменения свойства разделен запятыми.
```html
<div id="box">Press & Hold</div>
```
```css
#box {
  width: 100px;
  height: 100px;
  background-color: #4169E1;
  transition: width 1s, height 1s, 
  background-color 1s;
}
#box:active {
  width: 150px;
  height: 150px;
  background-color: #DC143C;
}
```

Пример: переход, который изменяет высоту элемента за 3 секунды и размер шрифта за 2 секунды
```css
#element {
  height: 15%;
  font-size: 20px;
  transition: height 3s, font-size 2s;
}
#element:hover {
  height: 100%;
  font-size: 30%;
}
```

Используйте `transition-delay` чтобы добавить время ожидания для эффекта перехода. В следующем примере задержка перед началом составляет 2 секунды:
```html
<body>
  <div id="element">Press & hold at least 2 seconds</div>
</body>
```
```css
#element {
  width: 100px;
  background-color: blue;
  color: white;
  transition: width 2s, 
  background-color 1s;
  transition-delay: 2s;
}

#element:active {
  width: 200px;
  background-color: red;
}
```

Таким образом задержка к переходу в три секунды будет выглядеть следующим образом:
```css
#box {
  width: 15%;
  transition: width 5s;
  transition-delay: 3s;
}
```

Можно добавлять переходы к трансформациям. Напомним как выглядит трансформация, которая удваивает размер элемента:
```css
transform: scale (2);
```

Эффект перехода к трансформации, кнопка будет масштабироваться при активации:
```html
<body>
  <button>Press & Hold</button>
</body>
```
```css
button {
  padding: 10px 20px;
  font-size: 16px;
  margin: 30px;
  border: none;
  border-radius: 5px;
  background-color: #3498DB;
  color: #FFFFFF;
  transition: transform 1s;
}

button:active {
    transform: scale(1.3);
}
```

Изменение высоты элемента и применение трансформации, оба действия с длительностью 5 секунд:
```css
transition: transform 5s, height 5s;
```

Переход для поворота элемента `#card` на 35 градусов за 2 секунды при наведении:
```css
#card {
  transition: transform 2s;
}
#card:hover {
  transform: rotate (35deg);
}
```

Переход к `#element`, который изменяет радиус границы в течение 3 секунд при наведении:
```css
#element {
  border-radius: 3px;
  transition: border-radius 3s;
}
#element:hover {
  border-radius: 6px;
}
```

Переход к трансформации масштаба. Он должен увеличиваться в 1,5 раза при наведении


<a id="Кадры-ключевые-и-Анимации">Кадры ключевые и Анимации</a>
---

- `@keyframes` определяют последовательность стилей, через которые проходит элемент во время анимации
- Свойство `animation-name` связывает `keyframes` с анимируемым элементом

В прошлом уроке вы научились создавать простые анимации с использованием переходов. К концу этого урока вы сможете создавать более сложные анимации, чтобы оживить вашу страницу.

Переходы используются для создания простых анимаций. У перехода есть начальное значение и конечное значение.
```css
#element {
  color: red;
  transition: color 3s;
}

#element:hover {
  color: yellow;
}
```

В приведенном выше примером начальным значением выступал `color: red;`, а конечным - `color: yellow;`.
 
Анимации используются для создания более сложных переходов и трансформаций с большим количеством промежуточных состояний. С анимациями вы можете изменять столько свойств, сколько вам нужно, столько раз, сколько вам нужно.

Анимации требуют `keyframes` для хранения стилей, которые элемент будет иметь в определенное время.
```html
<body>
  <h2>Transition</h2>
  <div id="element1"><p>Press & hold</p></div>
  
  <h2>Animation</h2>
  <div id="element2"></div>
</body>
```
```css
#element1 {
  width: 150px;
  height: 150px;
  background-color: red;
  transition: background-color 3s; 
  margin: 20px;
}

#element1:active {
  background-color: yellow;
}

#element2 {
  width: 150px;
  height: 150px;
  background-color: red;
  margin: 20px;
  animation-name: colorChange;
  animation-duration: 3s;
}

@keyframes colorChange {
  0% {
    background-color: red;
    }
  50% {
    background-color: yellow;
    }
  100% {
    background-color: blue;
    }
}

p {
  color: white;
  text-align: center;
  padding-top: 65px;
  font-size: 20px;
}

h2 {
  padding-left: 40px;
}
```

**Анимация** - это последовательность переходов.

**Keyframes** - это снимки с важными промежуточными состояниями, которые определяют анимацию.

Новой анимации нужно присвоить `animation-name`. Используйте `@keyframes` за которыми следует `animation-name`, чтобы определить ключевые промежуточные состояния.

Код ниже анимирует цвет фона элемента в четырех точках: при `0%`, `33%`, `66%` и `100%` завершения анимации.
```html
<body>
  <div></div>
</body>
```
```css
div {
  width: 150px;
  height: 150px;
  position: relative;
  margin: 50px;
  animation-name: snakeMove;
  animation-duration: 5s;
}

@keyframes snakeMove {
  0% {
    background-color: #7B41EA;
    bottom: 0;
    left: 0;
  }
  33% {
    background-color: #CCB4FB;
    bottom: 40px;
    left: 40px;
  }
  66% {
    background-color: #C833FD;
    bottom: 0;
    left: 80px;
  }
  100% {
    background-color: #F91583;
    bottom: 40px;
    left: 120px;
  }
}
```

Например в следующей анимации элемент двигается по горизонтальной линии, начиная слева и заканчивая справа:
```css
@keyframes myAnimation {
  0% {left: 0px;}
  50% {left: 10px}
  100% {left: 20px}
}
```

`animation-duration` контролирует время, необходимое элементу для перемещения от первого ключевого кадра до последнего.

Следующая анимация длилтся 5 секунд:
```css
div {
  weight: 100px;
  height: 100px;
  background-color: red;
  animation-name: example;
  animation-duration: 5s;
}
```

Анимации и переходы представляют собой различные поведения. Вы могли заметить это на примерах. Если сопоставить визуальный эффект с поведением, то:
- `transition` - требует триггер,
- `animation` - может воспроизводиться автоматически.

По умолчанию, анимация начинает воспроизводиться автоматически, когда страница загружается в браузере, если не установлена задержка.

`animation-delay` добавляет время ожидания для начала воспроизведения анимации.
```html
<body>
  <div>Disco!</div>
</body>
```
```css
div {
  padding: 30px;
  border-radius: 50%;
  width: 50px;
  background-color: #007BFF;
  color: white;
  animation-name: colorChange;
  animation-duration: 4s;
  animation-delay: 2s;
}

@keyframes colorChange {
  0% {background-color: #007BFF;}
  25% {background-color: #FFC107;}
  50% {background-color: #28A745;}
  75% {background-color: #DC3545;}
  100% {background-color: #6610F2;}
}
```

Следующие три ключевых кадра создадут визуальный эффект, который изменит толщину границы:
```css
@keyframes demo {
  0% { border: 1px solid;}
  50% { border: 2px solid;}
  100% { border: 3px solid;}
}
```

Когда в анимации есть только два кадра, в качестве альтернативы использованию процентов для ключевых кадров, можно использовать ключевые слова `from` и `to`.
```html
<body>
  <div>Disco!</div>
</body>
```
```css
div {
  padding: 30px;
  border-radius: 50%;
  width: 50px;
  background-color: #007BFF;
  color: white;
  animation-name: colorChange;
  animation-duration: 4s;
}

@keyframes colorChange {
  from { background-color: #007BFF;}
  to { background-color: #F2106E;}
}
```

В примере анимация под названием demo, с ключевыми кадрами на 0% и 100%, контролирущая цвет текста:
```css
@keyframes demo {
  from {color: green;}
  to {color: blue;}
}
```

Так-же можно анимировать трансформации. Название преобразования, которое изменяет размер элемента - `scale()`. Чтобы анимировать трансформации, нужно добавить их в ключевые кадры. После определения ключевых кадров анимации, можно применить их к различным элементам.

В следующем примере можно увидеть как анимация с именем `pulse` объединяется с трансформацией `scale` и применяется к трем кругам:
```html
<body>
  <div class="visual">
    <div class="circle-yellow"></div>
    <div class="circle-green"></div>
    <div class="circle-blue"></div>
  </div>
</body>
```
```css
body {
  margin: 50px;
  background-color: #0C1527;
  display: flex;
}

.circle-yellow {
  width: 40px;
  height: 40px;
  background-color: #FFA310;
  border-radius: 50%;
  animation-name: pulse;
  animation-duration: 3s;
}

.circle-green {
  width: 100px;
  height: 100px;
  top: 120px;
  left: 30px;
  background-color: #10FF14;
  border-radius: 50%;
  position: absolute;
  animation-name: pulse;
  animation-duration: 3s;
}

.circle-blue {
  left: 170px;
  top: 15px;
  width: 60px;
  height: 60px;
  background-color: #1064FF;
  border-radius: 50%;
  position: absolute;
  animation-name: pulse;
  animation-duration: 3s;
}

.visual {
  position: relative;
  width: 50px;
  height: 50px;
  display: inline;
}

@keyframes pulse {
  0% { transform: scale(1);}
  50% { transform: scale(2);}
  100% { transform: scale(1);}
}
```

В примере два ключевых кадра анимации с именем `rotation`:
```css
@keyframes rotation {
  from {transform: rotate(0deg);}
  to {transform: rotate(360deg);}
}
```

В примере анимация под названием `moveRight` для элемента `div` c установленной продолжительностью в пять секунд:
```css
div {
  animation-name: moveRight;
  animation-duration: 5s;
}
```


<a id="Свойства-анимации">Свойства анимации</a>
---

- Функции скорости могут быть установлены для анимаций и переходов с помощью подсвойства `timing-function`
- `animation-iteration-count` контролирует количество повторений анимации

Думаете ли вы, что уже достаточно знаете об анимациях? Пройдите этот урок, чтобы стать профессионалом в анимации и применить передовые техники, которые выделят ваши веб-дизайны.

В следующем примере три ключевых кадра анимации под названием `widening`:
```css
@keyframes widening {
  0% {width: 20px;}
  50% {widht: 30px;}
  100% {width: 40px}
}
```

Анимация - это последовательность изображений, известных как **кадры**. **Ключевые кадры** - это важные кадры, которые определяют начало и конец плавного перехода. Таким образом - есть **кадры**, и **ключевые кадры**.

Переходы между двумя **ключевыми кадрами** являются плавными и вычисляются автоматически на основе функции скорости. Функция скорости определяет, насколько быстро происходят изменения на различных этапах перехода.

По умолчанию, функция скорости - `ease`. Можно установить альтернативы стандартной функции скорости с помощью `animation-timing-function`:

- `ease` - сначала ускоряется, затем замедляется;
- `linear` - постоянная скорость;
- `ease-in` - запускается медленно, затем ускоряется;
- `ease-out` - запускается быстро, затем замедляется.
```html
<body>
  <div class="visual">
      <h3>ease</h3>
      <div id="item1"></div>

      <h3>linear</h3>
      <div id="item2"></div>

      <h3>ease-in</h3>
      <div id="item3"></div>

      <h3>ease-out</h3>
      <div id="item4"></div>
  </div>
</body>
```
```css
#item1 {
  width: 40px;
  height: 40px;
  background-color: #FFA310;
  animation: move 5s;
  /*speeds up first, then slows down*/
  animation-timing-function: ease;
}

#item2 {
  width: 40px;
  height: 40px;
  background-color: #10FF14;
  animation: move 5s;
  /*constant speed*/
  animation-timing-function: linear;
}

#item3 {
  width: 40px;
  height: 40px;
  background-color: #1064FF;
  animation: move 5s;
  /*starts slow, then speeds up*/
  animation-timing-function: ease-in;
}

#item4 {
  width: 40px;
  height: 40px;
  background-color: #C73447;
  animation: move 5s;
  /*starts fast, then slows down*/
  animation-timing-function: ease-out;
}

@keyframes move {
  0% { left: 0;}
  100% { left: 250px;}
}

div {
  margin-top: 30px;
  position: relative;
}
```

Анимация - это последовательность переходов. Каждый переход происходит между двумя ключевыми кадрами. Можно установить функцию скорости при работе с переходами. Имя свойства для переходов - `transition-timing-function` со значением по умолчанию.

По умолчанию функция плавности скорости - сначала ускорояется, затем замедляется.

Свойство `animation-iteration-count` определяет количество повторений анимации. В примере ниже, анимация пульсации повторяется пять раз:
```html
<head>
  <title>Notification Badge Animation</title>
</head>
<body>
  <div class="visual">
    <div class="circle-yellow"></div>
    <div class="circle-green"></div>
    <div class="circle-blue"></div>
  </div>
</body
```
```css
body {
  margin: 50px;
  background-color: #0C1527;
  display: flex;
}

@keyframes pulse {
  0% { transform: scale(1);}
  50% { transform: scale(2);}
  100% { transform: scale(1);}
}

.circle-yellow {
  width: 40px;
  height: 40px;
  background-color: #FFA310;
  border-radius: 50%;
  animation: pulse 3s;
  animation-iteration-count: 5;
}

.circle-green {
  width: 100px;
  height: 100px;
  top: 120px;
  left: 30px;
  background-color: #10FF14;
  border-radius: 50%;
  position: absolute;
  animation: pulse 3s;
  animation-iteration-count: 5;
}

.circle-blue {
  left: 170px;
  top: 15px;
  width: 60px;
  height: 60px;
  background-color: #1064FF;
  border-radius: 50%;
  position: absolute;
  animation: pulse 3s;
  animation-iteration-count: 5;
}

.visual {
  position: relative;
  width: 50px;
  height: 50px;
  display: inline;
}
```

В следующем примере анимация с именем `rotation`, длится две секунды, и повторяется три раза:
```css
#card {
  animation-name: rotation;
  animation-duration: 2s;
  animation-iteration-count: 3;
}
```

Чтобы анимация повторялась бесконечно, просто используйте значение `infinite` с `animation-iteration-count`. В примере анимация, которая повторяется бесконечно:
```html
<head>
  <title>Animated Loading Spinner</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="spinner"></div>
</body>
```
```css
body {
  background-color: #0C1527;
}

.spinner {
  position: absolute;
  top: 50px;
  left: 50px;
  border: 8px solid #7F622F;
  border-radius: 50%;  
  border-top: 8px solid #FB9C02;
  width: 50px;
  height: 50px;
  animation-name: spin;
  animation-duration: 1s;
  animation-timing-function: linear;
  animation-iteration-count: infinite;

}

@keyframes spin {
  from { transform: rotate(0deg);}
  to { transform: rotate(360deg);}
}
```

В примере бесконечная анимация пульсации круга:
```css
.circle {
  animation-name: pulse;
  animation-iteration-count: infinite;
}
@keyfranes pulse {
  0% {transform: scale(1);}
  50% {transform: scale(2);}
  100% {transform: scale(1);}
}
```

Свойство `animation` может быть использовано в качестве краткой записи для всех свойств, связанных с анимацией. Возьмем пример:
- `animation-name` - имя, напрмиер `spin`
- `animation-duration` - продолжительность анимации, (1сек)
- `animation-timing-function` - одна из четырех, например линейная
- `animation-delay` - задержка перед воспроизведением анимации (0,5сек)
- `animation-iteration-count` - количество воспроизведений анимации, например - пять;

Все переичиленные свойства, в краткой записи `animation` будут выглядеть следующим образом:
```css
animation: spin 1s linear 0.5s infinite;
```
Подробный пример:
```html
<head>
  <title>Animated Loading Spinner</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="spinner"></div>
</body>
```
```css
body {
  background-color: #0C1527;
}

.spinner {
  position: absolute;
  top: 50px;
  left: 50px;
  border: 8px solid #7F622F;
  border-radius: 50%;  
  border-top: 8px solid #FB9C02;
  width: 50px;
  height: 50px;
  animation: spin 1s linear 0.5s infinite;
}

@keyframes spin {
  from { transform: rotate(0deg);}
  to { transform: rotate(360deg);}
}
```

Порядок, в котором каждое свойство объявлено в сокращенном объявлении, важен и не может быть изменен. В противном случае анимация не будет работать должным образом.

В примере анимация с названием loading, продолжительностью 5 секунд, которая будет повторяться бесконечно:
```css
animanion: loading 5s infinite;
```


<a id="Проект-Профильной-Страницы-Шаг-5">Проект Профильной Страницы Шаг 5</a>
---

На этом шаге вы примените анимацию пульсации к секции развода, чтобы они меняли размер и цвет.

Задачи: 
1. Примените `animation-name: pulse` к элементам `.active-day`
2. Сделайте продолжительность анимации `2s` и убедитесь, что она играет `infinite` раз
3. Используйте `@keyframes` для анимации пульсации, чтобы размер текста колебался между `100%` и `120%`, и измените цвет на `#00CC00` на `50%` отметки анимации



<a id="Контрольные-вопросы-к-модулю-4">Контрольные вопросы к модулю 4</a>
---
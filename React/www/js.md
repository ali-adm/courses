Повторное введение в JavaScript [(JS учебник)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Language_overview#описание) с коментариями chatGPT.
===

## <a id="Содержание:">Содержание:</a>
### [Вступление](#Вступление)
### [Описание](#Описание)
### [Числа](#Числа)
### [Строки](#Строки)
### [Другие типы](#Другие-типы)
### [Переменные](#Переменные)
### [Операторы](#Операторы)
### [Управляющие структуры](#Управляющие-структуры)
  ##### [Коментарий GPT else if else](#Коментарий-чата-GPT-else-if-else)
  ##### [Коментарий GPT while do-while for](#Коментарий-GPT-while-do-while-for)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)
### [Name](#Chapter_id)


<a id="Вступление">Вступление</a>
===

[-> Назад к содержанию](#Содержание:)

[//]:(Комментарии_добавил_aliadm_конец_августа_2024)

Почему повторное введение? Потому что [JavaScript](https://developer.mozilla.org/ru/docs/Glossary/JavaScript) известен тем, что является [самым неправильно понятым языком программирования в мире](http://javascript.crockford.com/javascript.html). Его часто называют игрушкой, но под слоем обманчивой простоты ожидают мощные языковые возможности. В настоящее время JavaScript используется невероятным количеством высококлассных приложений, показывая, что углублённое знание этой технологии является важным навыком для любого веб или мобильного разработчика.

Было бы полезно начать с истории языка. JavaScript был создан в 1995 Бренданом Айком, инженером в компании Netscape. Первый релиз состоялся вместе с выходом браузера Netscape 2 в начале 1996 года. Сначала язык назывался LiveScript, но затем был переименован в связи с маркетинговыми целями, чтобы сыграть на популярности языка Java компании Sun Microsystem — несмотря на это языки практически не имеют ничего общего друг с другом. Так было положено начало путаницы между этими языками.

Чуть позже Microsoft выпустила очень похожий и практически совместимый язык JScript, который шёл вместе с IE3. Через пару месяцев Netscape отправил язык в [Ecma International](https://www.ecma-international.org/), Европейскую организацию занимающуюся стандартами, которая выпустила первую версию стандарта [ECMAScript](https://developer.mozilla.org/en-US/JavaScript/Language_Resources) в 1997. Стандарт получил значимое обновление в [ECMAScript edition 3](https://www.ecma-international.org/publications/standards/Ecma-262.htm) в 1999, и остаётся самым стабильным до сегодняшнего дня. Четвёртая версия была отклонена, из-за проблем с усложнениями в языке. Многие вещи из четвёртого издания послужили основой для стандарта ECMAScript 5 (декабрь 2009) и ECMAScript 6 (июнь 2015).

В отличие от большинства языков, JavaScript не следует концепции ввода (input) и вывода (output). Он спроектирован таким образом, чтобы запускаться как язык сценариев, встроенный в среду исполнения. Самая популярная среда исполнения это браузер, однако интерпретаторы JavaScript присутствуют и в Adobe Acrobat, Photoshop, Yahoo!'s Widget engine, и даже в серверном окружении, например [node.js](https://nodejs.org/).


<a id="Описание">Описание</a>
===

[-> Назад к содержанию](#Содержание:)

JavaScript является объектно-ориентированным языком, имеющий типы и операторы, встроенные объекты и методы. Его синтаксис происходит от языков Java и C, поэтому много конструкций из этих языков применимы и к JavaScript. Одним из ключевых отличий JavaScript является отсутствие классов, вместо этого функциональность классов осуществляется прототипами объектов (смотрите ES6 Classes) . Другое главное отличие в том, что функции это объекты, в которых содержится исполняемый код и которые могут быть переданы куда-либо, как и любой другой объект.

Начнём с основы любого языка: с типов данных. Программы на JavaScript оперируют значениями, и все эти значения принадлежат к определённому типу. Типы данных в JavaScript:JavaScript является объектно-ориентированным языком, имеющий типы и операторы, встроенные объекты и методы. Его синтаксис происходит от языков Java и C, поэтому много конструкций из этих языков применимы и к JavaScript. Одним из ключевых отличий JavaScript является отсутствие классов, вместо этого функциональность классов осуществляется прототипами объектов [смотрите ES6 (Classes)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes) . Другое главное отличие в том, что функции это объекты, в которых содержится исполняемый код и которые могут быть переданы куда-либо, как и любой другой объект.

Начнём с основы любого языка: с типов данных. Программы на JavaScript оперируют значениями, и все эти значения принадлежат к определённому типу. Типы данных в JavaScript:

- Числа
- Строки
- Логические типы
- Функции
- Объекты
- Символы (новый тип из шестой редакции)

Да, ещё [Undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined) и [Null](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/null), которые немного обособлены. И [Массивы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array), которые являются особым видом объектов. А также [Даты](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date) и [Регулярные выражения](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp), тоже являющиеся объектами. И, если быть технически точным, функции это тоже особый вид объекта. Поэтому схема типов выглядит скорее так:

- Числа
- Строки
- Логические типы
- Символы (новый тип из шестой редакции)
- Объекты
    - Функции
    - Массивы
    - Даты
    - Регулярные выражения
- Null
- undefined

Также есть несколько встроенных типов [Ошибок](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error). Чтобы было проще, рассмотрим подробнее первую схему.

<a id="Числа">Числа</a>
===

[-> Назад к содержанию](#Содержание:)

Числа в JavaScript — это "64-битные значения двойной точности формата IEEE 754", согласно спецификации. Это имеет интересные последствия. В JavaScript нет такой вещи, как целое число, поэтому с арифметикой нужно быть начеку, если вы привыкли к вычислениям в языках C или Java. Взгляните на пример:

```js
0.1 + 0.2 == 0.30000000000000004;
```

На практике целые значения это 32-битные целые (и хранятся таким образом в некоторых браузерных реализациях), что может быть важно для побитовых операций.

Поддерживаются стандартные [арифметические операторы](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators), включая сложение, вычитание, остаток от деления и т.д. Есть ещё встроенный объект, который я забыл упомянуть, называемый [Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math), который содержит более продвинутые математические функции и константы:

```js
Math.sin(3.5);
var circumference = Math.PI * (r + r);
```

Вы можете преобразовать строку в целое число, используя встроенную функцию [parseInt()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseInt). Её необязательный второй параметр — основание системы счисления, которое следует всегда явно указывать:
```js
parseInt("123", 10); // 123
parseInt("010", 10); // 10
```

Если вы не предоставите основание, то можете получить неожиданные результаты:
```js
parseInt("010"); // 8
parseInt("0x10"); // 16
```

Это случилось потому, что функция parseInt() расценила строку как восьмеричную из-за начального 0, а шестнадцатеричную - из-за начального "0x".

Если хотите преобразовать двоичное число в десятичное целое, просто смените основание:
```js
parseInt("11", 2); // 3
```

Вы можете аналогично парсить дробные числа, используя встроенную функцию [parseFloat()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseFloat), которая использует всегда основание 10 в отличие от родственной [parseInt()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseInt).

Также можно использовать унарный оператор `+` для преобразования значения в число:
```js
+"42"; // 42
+"0x10"; // 16
```

Специальное значение [NaN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/NaN) (сокращение от "Not a Number") возвращается, если строка не является числом:
```js
parseInt("hello", 10); // NaN
```

NaN "заразителен": любая математическая операция над `NaN` возвращает `NaN`:
```js
NaN + 5; // NaN
```

Проверить значение на `NaN` можно встроенной функцией [isNaN()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isNaN):
```js
isNaN(NaN); // true
```

JavaScript также имеет специальные значения [Infinity](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Infinity) (бесконечность) и `-Infinity`:
```js
1 / 0; // Infinity
-1 / 0; // -Infinity
```

Проверить значение на `Infinity`, `-Infinity` и `NaN` можно с помощью встроенной функции [isFinite()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isFinite):
```js
isFinite(1 / 0); // false
isFinite(-Infinity); // false
isFinite(NaN); // false
```

<a id="Строки">Строки</a>
===

[-> Назад к содержанию](#Содержание:)

Строки в JavaScript - это последовательности [символов Unicode](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Grammar_and_types) (в кодировке UTF-16). Для тех, кто имеет дело с интернационализацией, это должно стать хорошей новостью. Если быть более точным, то строка - это последовательность кодовых единиц, каждая из которых представлена 16-битовым числом, а каждый символ Unicode состоит из 1 или 2 кодовых единиц.

Чтобы представить единственный символ, используйте строку, содержащую только этот символ.

Чтобы выяснить длину строки (в кодовых единицах), используйте свойство [length](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/length):
```js
"hello".length; // 5
```

Это уже первый шаг для работы с объектами! Мы уже говорили, что и строки можно использовать как объекты? У них тоже есть [методы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String):
```js
"hello".charAt(0); // h
"hello, world".replace("hello", "goodbye"); // goodbye, world
"hello".toUpperCase(); // HELLO
```

<a id="Другие-типы">Другие типы</a>
===

[-> Назад к содержанию](#Содержание:)

JavaScript дополнительно различает такие типы, как `null`, который указывает на преднамеренное отсутствующее значение, и `undefined`, указывающий на неинициализированное значение — то есть, значение, которое даже не было назначено. Мы поговорим о переменных позже, но в JavaScript можно объявить переменную без присвоения ей значения. В этом случае тип переменной будет `"undefined"`.

Ещё в JavaScript есть логический (булевый) тип данных, который может принимать два возможных значения `true` или `false` (оба являются ключевыми словами). Любое значение может быть преобразовано в логическое значение в соответствии со следующими правилами:

1. `false`, `0`, пустая строка (`""`), `NaN`, `null` и `undefined` преобразуются в `false`.
2. Все остальные значения преобразуются в `true`.
   
Преобразование значений можно осуществить явно, используя функцию `Boolean()`:
```js
Boolean(""); // false
Boolean(234); // true
```

Этот метод используется редко, так как JavaScript может автоматически преобразовывать типы в тех случаях, когда ожидается булевое значение, например в операторе `if`. Из-за того, что любой тип данных может быть преобразован в булевое значение, иногда говорят, что данные "истинные" или "ложные".

Для операций с логическими данными используются логические операторы: `&&` (логическое И), `||` (логическое ИЛИ), `!` (логическое НЕ).

<a id="Переменные">Переменные</a>
===

[-> Назад к содержанию](#Содержание:)

Для объявления новых переменных в JavaScript используются ключевые слова [let](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let), [const](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/const) или [var](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var).
```js
let a;
let name = "Simon";
```

`let` позволяет объявлять переменные, которые доступны только в блоке, в котором они объявлены:
```js
// myLetVariable недоступна здесь

for (let myLetVariable = 0; myLetVariable < 5; myLetVariable++) {
  // myLetVariable доступна только здесь
}

// myLetVariable недоступна здесь
```

`const` позволяет создавать переменные, чьи значения не предполагают изменений. Переменная доступна из блока, в котором она объявлена.
```js
const Pi = 3.14; // в переменную Pi записано значение.
Pi = 1; // вызовет исключение, так как значение константы нельзя изменить.
```

`var` наиболее общее средство объявления переменной. Оно не имеет ограничений, которые имеют два вышеописанных способа. Это потому, что это был изначально единственный способ объявления переменной в JavaScript. Переменная, объявленная с помощью `var`, доступна в пределах функции, в которой она объявлена.
```js
var a;
var name = "Simon";
```

Пример кода с переменной, объявленной с помощью `var`:
```js
// myVarVariable доступна здесь

for (var myVarVariable = 0; myVarVariable < 5; myVarVariable++) {
  // myVarVariable доступна для всей функции
}

// myVarVariable доступна и здесь
```

Если вы объявляете переменную без присвоения ей какого-либо значения, то её тип будет определён как `undefined`.

Важной особенностью языка JavaScript является то, что блоки данных не имеют своей области видимости, она есть только у функций. Поэтому, если объявить переменную через `var` в блоке данных (например, внутри контролирующей структуры `if`), то она будет доступна всей функции. Следует отметить, что в новом стандарте ECMAScript Edition 6 появились инструкции `let` и `const`, позволяющие объявлять переменные с областью видимости, ограниченной пределами блока.

<a id="Операторы">Операторы</a>
===

[-> Назад к содержанию](#Содержание:)

JavaScript поддерживает такие операторы, как `+`, `-`, `*`, `/` и `%`, который возвращает остаток от деления (не путать с модулем). Значения присваиваются с помощью оператора `=`, или с помощью составных операторов `+=` и `-=`. Это сокращённая запись выражения `x = x оператор y`.
```js
x += 5;
x = x + 5;
```

Так же используются операторы инкремента (`++`) и декремента (`--`). Которые имеют префиксную и постфиксную форму записи.

[Оператор +](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators) так же выполняет конкатенацию (объединение) строк:
```js
"hello" + " world"; // "hello world"
```

При сложении строкового и числового значений происходит автоматическое преобразование в строку. Поначалу такое может запутать:
```js
"3" + 4 + 5; // "345"
3 + 4 + "5"; // "75"
```

Для приведения значения к строке просто прибавьте к нему пустую строку.

Для [сравнения](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators) в JavaScript используются следующие операторы: `<`, `>`, `<=` и `>=`. Сравнивать можно не только числа, но и строки. Проверка на равенство немного сложнее. Для проверки используют двойной (`==`) или тройной (`===`) оператор присваивания. Двойной оператор `==` осуществляет автоматическое преобразование типов, что может приводить к интересным результатам:
```js
123 == "123"; // true
1 == true; // true
```

Если преобразование нежелательно, то используют оператор строгого равенства:
```js
1 === true; // false
123 === "123"; // false
true === true; // true
```

Для проверки на неравенство используют операторы `!=` и `!==`.

Отдельного внимания стоят [побитовые операторы](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators), с которыми вы можете ознакомиться в соответствующем разделе.

<a id="Управляющие-структуры">Управляющие структуры</a>
===

[-> Назад к содержанию](#Содержание:)

Управляющие структуры в JavaScript очень похожи на таковые в языках семейства C. Условные операторы выражены ключевыми словами `if` и `else`, которые можно составлять в цепочки:
```js
var name = "kittens";
if (name == "puppies") {
  name += "!";
} else if (name == "kittens") {
  name += "!!";
} else {
  name = "!" + name;
}
name == "kittens!!";
```

<a id="Коментарий-чата-GPT-else-if-else">Коментарий GPT - else if else</a>
---

[-> Назад к содержанию](#Содержание:)

Обилие восклицательных знаков может сбивать с толку, особенно когда они напоминают логическое отрицание (`!`). Давай возьмем более реалистичный пример, который проще воспринимать и имеет практическое применение.

Пример: Проверка статуса заказа.
Допустим, у нас есть переменная `orderStatus`, которая хранит статус заказа, и в зависимости от этого статуса мы хотим обновить сообщение для пользователя.
```js
var orderStatus = "processing";  // Инициализируем переменную со статусом заказа

if (orderStatus == "pending") {
  orderStatus = "Ваш заказ ожидает подтверждения.";
} else if (orderStatus == "processing") {
  orderStatus = "Ваш заказ обрабатывается.";
} else if (orderStatus == "shipped") {
  orderStatus = "Ваш заказ отправлен.";
} else {
  orderStatus = "Статус заказа неизвестен.";
}

console.log(orderStatus);  // Выведет: "Ваш заказ обрабатывается."
```
### Объяснение кода

1. Инициализация переменной:
- Мы задаем переменной `orderStatus` значение "processing", что означает, что заказ находится в стадии обработки.
2. Проверка статуса заказа:
- `if (orderStatus == "pending")`: Проверяет, ожидает ли заказ подтверждения.
- `else if (orderStatus == "processing")`: Проверяет, обрабатывается ли заказ.
- `else if (orderStatus == "shipped")`: Проверяет, был ли заказ отправлен.
3. Изменение значения переменной `orderStatus`:
- В зависимости от того, какой статус у заказа, переменная `orderStatus` обновляется соответствующим сообщением для пользователя.
4. Обработка неизвестного статуса:
- Если статус заказа не совпадает ни с одним из известных значений (`pending`, `processing`, `shipped`), выводится сообщение "`Статус заказа неизвестен.`".
### Практическое использование
Этот пример показывает, как можно использовать условные операторы для изменения текста в зависимости от состояния программы. Такой подход часто используется для отображения различных сообщений пользователю в зависимости от ситуации.
### ---> Конец коментария

В JavaScript есть три типа циклов: `while`, `do-while` и `for`. While используется для задания обычного цикла, а do-while целесообразно применить в том случае, если вы хотите, чтобы цикл был выполнен хотя бы один раз:
```js
while (true) {
  // бесконечный цикл!
}

var input;
do {
  input = get_input();
} while (inputIsNotValid(input));
```

<a id="Коментарий-GPT-while-do-while-for">Коментарий GPT while do-while for</a>
---

[-> Назад к содержанию](#Содержание:)

Разберем два приведенных примера: бесконечный цикл с `while` и цикл с `do...while`.

1. Бесконечный цикл с `while`
```js
while (true) {
  // бесконечный цикл!
}
```
### Объяснение
- `while (true)`: Цикл `while` продолжает выполняться, пока условие в скобках остается истинным (`true`).
- В данном случае условие всегда истинно (`true`), поэтому цикл никогда не завершится сам по себе.
- Этот код запускает бесконечный цикл, который будет выполняться без остановки.
### Практическое использование
Бесконечные циклы иногда используются в программировании, например, для серверов или программ, которые должны постоянно работать и реагировать на события. Чтобы избежать зависания программы, такие циклы обычно включают внутри себя команды для выхода (например, `break`) при определенных условиях:
```js
while (true) {
  // какая-то логика
  if (shouldExitLoop) {
    break;  // выход из цикла, если условие выполнено
  }
}
```

2. Цикл с do...while
```js
var input;
do {
  input = get_input();
} while (inputIsNotValid(input));
```

### Объяснение
- `do...while`: Этот цикл сначала выполняет блок кода, а затем проверяет условие в `while`. Если условие истинно, цикл повторяется.
- `input = get_input();`: Внутри цикла вызывается функция `get_input()`, которая, предположительно, запрашивает у пользователя ввод данных.
- `while (inputIsNotValid(input))`: После каждого выполнения блока проверяется, удовлетворяет ли вводимое значение определенному условию (в данном случае, `inputIsNotValid(input)`). Если ввод не валиден, цикл повторяется, и программа снова запрашивает ввод.
### Практическое использование
Цикл `do...while` часто используется, когда нужно выполнить блок кода хотя бы один раз, а затем повторять его, пока не будет выполнено определенное условие. В данном примере цикл гарантирует, что функция `get_input()` будет вызвана как минимум один раз, а затем повторяется до тех пор, пока пользователь не введет корректные данные.
### Пример использования в реальной ситуации:
```js
var password;
do {
  password = prompt("Введите пароль:");  // Запрашивает ввод пароля у пользователя
} while (password.length < 6);  // Продолжает запрашивать, пока длина пароля меньше 6 символов

console.log("Пароль установлен.");  // Выводится сообщение, когда введен пароль корректной длины
```
В этом примере программа запрашивает ввод пароля и продолжает запрашивать его, пока введенный пароль не будет хотя бы 6 символов в длину.
### Основные выводы
- Бесконечный цикл с `while`: используется для непрерывных операций и требует ручного выхода (`break`), чтобы предотвратить зависание программы.
- Цикл `do...while`: полезен, когда нужно гарантировать хотя бы одно выполнение блока кода перед проверкой условия.
### ---> Конец коментария

Цикл `for` похож на такой же в языках C и Java: он позволяет задавать данные для контроля за выполнением цикла:
```js
for (var i = 0; i < 5; i++) {
  // Выполнится 5 раз
}
```
Коментарий чата GPT (GPT-4o mini)
---

Цикл `for` с счётчиком `i`, который выполняется 5 раз, — это очень распространённый шаблон в программировании. Давайте рассмотрим, какие практические применения у такого цикла.
### Объяснение работы цикла
1. Инициализация: var `i = 0` — переменная `i` (счётчик) устанавливается в начальное значение `0`.
2. Условие: `i < 5` — цикл выполняется до тех пор, пока `i` меньше `5`.
3. Инкремент: `i++` — после каждого выполнения тела цикла значение `i` увеличивается на `1`.
4. Цикл выполняет код в теле (внутри фигурных скобок `{}`) 5 раз: для `i = 0, 1, 2, 3, 4`.
### Практическое применение цикла
1. Перебор элементов массива:
- Цикл может использоваться для итерации по элементам массива, чтобы выполнить операцию для каждого элемента.
```js
var fruits = ["apple", "banana", "cherry", "date", "elderberry"];
for (var i = 0; i < 5; i++) {
  console.log(fruits[i]);  // Выведет каждый фрукт на экран
}
```
2. Многократное выполнение задачи:
- Выполнение какого-либо действия фиксированное количество раз
```js
for (var i = 0; i < 5; i++) {
  console.log("Hello, World!");  // Выведет "Hello, World!" 5 раз
}
```
3. Создание элементов интерфейса:
- Используется для динамического создания элементов интерфейса (например, добавление 5 кнопок на веб-страницу).
```js
for (var i = 0; i < 5; i++) {
  var button = document.createElement("button");
  button.textContent = "Кнопка " + (i + 1);
  document.body.appendChild(button);  // Добавляет кнопку в документ
}
```
4. Процессинг данных:
- Применение одной и той же операции к каждому элементу набора данных, например, добавление всех чисел от 0 до 4.
```js
var sum = 0;
for (var i = 0; i < 5; i++) {
  sum += i;  // Суммирует числа: 0 + 1 + 2 + 3 + 4 = 10
}
console.log(sum);  // Выведет 10
```
5. Создание таблиц или списков:
- Генерация HTML-кода для таблицы с фиксированным числом строк.
```js
var table = "<table>";
for (var i = 0; i < 5; i++) {
  table += "<tr><td>Row " + (i + 1) + "</td></tr>";
}
table += "</table>";
document.body.innerHTML = table;  // Добавляет таблицу на веб-страницу
```
6. Анимация и графика:
- Использование цикла для многократного изменения положения или цвета объекта на экране (например, при создании анимации).
### Вывод
Цикл `for` с фиксированным количеством итераций используется во множестве сценариев — от простого вывода данных на экран до сложных вычислений и построения элементов интерфейса. Он особенно полезен, когда нужно повторить одно и то же действие несколько раз, и его использование делает код более компактным и понятным.
### ---> Конец коментария

JavaScript также содержит две других известных конструкции: [for...of](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...of) и [for...in](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in).

Коментарий чата GPT (GPT-4o mini)
---

Оба приведённых примера являются разновидностями циклов в JavaScript, используемых для перебора элементов в коллекциях. Давайте разберём каждый из них и их практическое применение:

1. Цикл for...of
```js
for (let value of array) {
  // операции с value
}
```
### Объяснение
- `for...of` используется для перебора итерируемых объектов. Это включает в себя массивы, строки, объекты типа `Map`, `Set`, `Array`, и другие структуры данных, которые реализуют итератор.
- В каждой итерации цикла переменная `value` получает значение следующего элемента из коллекции `array`.
Этот цикл позволяет легко итерировать по элементам массива без необходимости использовать индексы.
### Пример использования
```js
const fruits = ["apple", "banana", "cherry"];
for (let fruit of fruits) {
  console.log(fruit);
}
```
### Вывод
```
apple
banana
cherry
```
### Практическое применение
- Обработка элементов массива: `for...of` часто используется для итерации по массивам, чтобы выполнить действия с каждым элементом, такие как вывод данных, обработка или выполнение логики.
- Работа с другими итерируемыми объектами: Цикл также полезен для работы с коллекциями типа `Set` или `Map`, где можно перебрать значения или ключи.
2. Цикл for...in
```js
for (let property in object) {
  // операции над свойствами объекта
}
```
### Объяснение
- `for...in` используется для перебора перечисляемых свойств объекта. Это означает, что цикл проходит по всем ключам (именам свойств) объекта.
- В каждой итерации цикла переменная `property` получает имя следующего свойства объекта `object`.
### Пример использования
```js
const user = {
  name: "John",
  age: 30,
  city: "New York"
};

for (let property in user) {
  console.log(`${property}: ${user[property]}`);
}
```
### Вывод:
```
name: John
age: 30
city: New York
```
### Практическое применение
- Перебор свойств объекта: `for...in` позволяет легко итерировать по всем свойствам объекта, что полезно для ситуаций, когда нужно выполнить операции над каждым свойством, например, для вывода данных или копирования.
- Работа с объектами, имеющими неизвестное количество свойств: Этот цикл удобен, когда структура объекта динамична, и количество свойств заранее неизвестно.
### Основные различия и рекомендации
- `for...of`: используется для перебора значений в итерируемых объектах (например, массивы, строки, `Map`, `Set`). Это более предпочтительно для работы с массивами, так как фокусируется на значениях, а не на индексах.
- `for...in`: используется для перебора ключей (имен свойств) объекта. Подходит для работы с объектами, но не рекомендуется использовать его для массивов, так как `for...in` будет перебирать все перечисляемые свойства, включая свойства прототипа, что может привести к неожиданным результатам.
### Примеры, когда не стоит использовать for...in с массивами
```js
const arr = [10, 20, 30];
arr.customProp = "custom value";

for (let index in arr) {
  console.log(index);  // выведет 0, 1, 2, и 'customProp'
}
```
Этот цикл выведет не только индексы массива (0, 1, 2), но и все пользовательские свойства (customProp), что в большинстве случаев не является желаемым поведением.
### Заключение
Используйте `for...of` для итерации по массивам и другим итерируемым объектам и `for...in` для перебора свойств объектов. Это поможет вам избежать ошибок и обеспечит более читаемый и предсказуемый код.
### ---> Конец коментария

Логические операторы `&&` и `||` используют "короткий цикл вычисления", это значит, что вычисление каждого последующего оператора зависит от предыдущего. Например, полезно проверить существует ли объект или нет, прежде чем пытаться получить доступ к его свойствам:
```js
var name = o && o.getName();
```

Коментарий чата GPT (GPT-4o mini)
---
Выражение `var name = o && o.getName();` использует оператор логического И (`&&`) для выполнения условного вызова метода объекта. Давайте разберём, что оно означает и как работает.
### Объяснение
1. Логическое И (`&&`):
- Этот оператор сначала проверяет первое выражение (в данном случае, `o`).
- Если `o` является ложным значением (`false`, `null`, `undefined`, `0`, пустая строка, `NaN`), то выражение сразу же возвращает это значение, и второе выражение (вызов `o.getName()`) не выполняется.
- Если `o` является истинным значением (любое значение, кроме указанных выше), оператор переходит ко второй части выражения и выполняет `o.getName()`.
2. Присваивание результата:
- В итоге переменной name будет присвоено либо значение, возвращённое функцией `o.getName()`, если `o` существует и является истинным значением, либо значение `o`, если оно является ложным.
### Практическое использование
Это выражение часто используется для безопасного вызова метода объекта. Оно позволяет избежать ошибки, которая бы возникла при попытке вызова метода на `undefined` или `null`. Например:
```js
var person = {
  getName: function() {
    return "John Doe";
  }
};

var name = person && person.getName();  // "John Doe"

var nullPerson = null;
var noName = nullPerson && nullPerson.getName();  // noName будет равно null, метод не вызывается
```
### Результат
- Если объект `o` существует и содержит метод `getName()`, то `name` будет равно значению, возвращённому этим методом.
- Если `o` равно `null`, `undefined` или любому другому ложному значению, то `name` будет равно этому значению, а вызов метода `getName()` не произойдет.
### Основная цель
Этот подход используется для проверки существования объекта перед попыткой вызова его метода, что позволяет избежать потенциальных ошибок и сделать код более безопасным и устойчивым.
### ---> Конец коментария

Таким способом удобно задавать значения по умолчанию:
```js
var name = otherName || "default";
```

К условным операторам в JavaScript принадлежит также тернарный оператор "`?`":
```js
var allowed = age > 18 ? "yes" : "no";
```
Коментарий чата GPT (GPT-4o mini)
---
### Тернарный оператор
Тернарный оператор (или *тернарный условный оператор*) в JavaScript — это короткий способ записи условного оператора `if...else`. Он позволяет выполнять проверку условия и возвращать одно значение, если условие истинно, и другое значение, если оно ложно.
### Синтаксис тернарного оператора
```js
условие ? значение1 : значение2;
```
- условие — логическое выражение, которое оценивается (например, age > 18).
- значение1 — результат, который возвращается, если условие истинно (true).
- значение2 — результат, который возвращается, если условие ложно (false).
### Объяснение выражения
```js
var allowed = age > 18 ? "yes" : "no";
```
1. Условие: `age > 18`
- Проверяет, больше ли значение переменной `age` 18.
2. Если условие истинно (`true`): возвращается `"yes"`.
- Например, если `age = 20`, то `age > 18` будет `true`, и переменной `allowed` присвоится значение `"yes"`.
3. Если условие ложно (`false`): возвращается `"no"`.
- Например, если `age = 16`, то `age > 18` будет `false`, и переменной `allowed` присвоится значение `"no"`.
### Практическое применение тернарного оператора
Тернарный оператор полезен, когда нужно сделать короткое условное присваивание или вернуть значение на основе условия. Он делает код компактнее и легче читаемым, особенно для простых условий.
### Примеры практического использования
1. Присваивание значения на основе условия:
```js
var age = 20;
var category = age >= 18 ? "взрослый" : "несовершеннолетний";
console.log(category);  // Выведет: "взрослый"
```
2. Краткий возврат значения из функции:
```js
function getDiscount(isMember) {
  return isMember ? 10 : 0;  // Возвращает скидку 10, если пользователь является членом клуба, иначе 0
}

console.log(getDiscount(true));  // 10
console.log(getDiscount(false)); // 0
```
3. Обработка значений в HTML-шаблонах (например, в React):
```js
const Button = ({ isLoggedIn }) => (
  <button>
    {isLoggedIn ? "Logout" : "Login"}
  </button>
);
```
4. Быстрая проверка и обработка ошибок:
```js
var input = userInput ? userInput : "default value";  // Использует пользовательский ввод, если он существует, иначе присваивает "default value"
```
### Заключение
Тернарный оператор делает код более коротким и читаемым, когда требуется простое условие. Однако важно не злоупотреблять им для сложных условий, так как это может сделать код трудночитаемым.
### ---> Конец коментария

Оператор `switch` используется при необходимости множественного сравнения:
```js
switch (action) {
  case "draw":
    drawit();
    break;
  case "eat":
    eatit();
    break;
  default:
    donothing();
}
```
Коментарий чата GPT (GPT-4o mini)
---
Этот код использует конструкцию `switch` для выполнения различных действий в зависимости от значения переменной `action`. Давайте разберём каждую часть этого кода.
### Конструкция switch
Конструкция `switch` в JavaScript позволяет выполнить блок кода в зависимости от значения выражения. Она является альтернативой многократному использованию условных операторов `if...else if...else`.
### Объяснение функции
```js
switch (action) {
  case "draw":
    drawit();
    break;
  case "eat":
    eatit();
    break;
  default:
    donothing();
}
```
Как работает `switch`:
1. `switch (action)`: Эта строка определяет начало конструкции `switch` и использует переменную `action` как условие для выбора.
2. `case "draw":`: Если значение `action` равно `"draw"`, выполняется блок кода после этого `case`.
- `drawit();`: вызывается функция `drawit()`.
- `break;`: оператор `break` завершает выполнение `switch`, предотвращая выполнение последующих ```case```.
3. `case "eat":`: Если значение `action` равно `"eat"`, выполняется блок кода после этого `case`.
- `eatit();`: вызывается функция `eatit()`.
- `break;`: завершает выполнение `switch`.
4. `default:`: Если ни одно из значений `case` не совпадает со значением `action`, выполняется код в блоке `default`.
- `donothing();`: вызывается функция `donothing()`.
### Пример работы:
- Если `action` равно `"draw"`, то вызовется `drawit()` и выполнение `switch` завершится.
- Если `action` равно `"eat"`, то вызовется `eatit()` и выполнение `switch` завершится.
- Если `action` не равно ни `"draw"`, ни `"eat"` (например, `"sleep"` или `undefined`), то вызовется `donothing()`.
### Практическое применение `switch`
`switch` используется, когда нужно проверить одно и то же выражение (например, переменную) против нескольких разных значений и выполнить разные действия для каждого случая. Это делает код более чистым и легко читаемым по сравнению с использованием множества `if...else` условий.
### Примеры:
1. Обработка различных действий пользователя:
```js
function performAction(action) {
  switch (action) {
    case "login":
      logUserIn();
      break;
    case "logout":
      logUserOut();
      break;
    case "signup":
      signUserUp();
      break;
    default:
      showErrorMessage();
  }
}
```
2. Определение дня недели:
```js
function getDayName(dayNumber) {
  switch (dayNumber) {
    case 0:
      return "Sunday";
    case 1:
      return "Monday";
    case 2:
      return "Tuesday";
    case 3:
      return "Wednesday";
    case 4:
      return "Thursday";
    case 5:
      return "Friday";
    case 6:
      return "Saturday";
    default:
      return "Invalid day number";
  }
}
```
### Заключение
Конструкция `switch` позволяет эффективно и легко управлять логикой выбора, основываясь на значении выражения. Она удобна для ситуаций, когда нужно сравнивать одно значение с несколькими возможными вариантами, улучшая читаемость и поддерживаемость кода.
### ---> Конец коментария

Если в конце инструкции `case` не добавить останавливающую инструкцию `break`, то выполнение перейдёт к следующей инструкции `case`. Как правило, такое поведение нежелательно, но если вдруг вы решили его использовать, настоятельно рекомендуем писать соответствующий комментарий для облегчения поиска ошибок:
```js
switch (a) {
  case 1: // fallthrough
  case 2:
    eatit();
    break;
  default:
    donothing();
}
```

Вариант `default` опциональный. Допускается использование выражений как в условии `switch`, так и в `cases`. При проверке на равенство используется оператор строгого равенства `===`:
```js
switch (1 + 3) {
  case 2 + 2:
    yay();
    break;
  default:
    neverhappens();
}
```
Коментарий чата GPT (GPT-4o mini)
---
В этом коде используется конструкция `switch` для сравнения результата выражения с значениями `case`. Давайте разберём его работу шаг за шагом.
### Объяснение работы кода
1. `switch (1 + 3)`: Эта строка выполняет выражение `1 + 3`, которое равно `4`. Таким образом, `switch` сравнивает значение `4` с каждым значением `case`.
2. `case 2 + 2:`: Эта строка выполняет выражение `2 + 2`, которое также равно `4`. Значение `case` и значение `switch` совпадают.
3. `yay();`: Так как значение `case` (`4`) совпадает со значением `switch` (`4`), выполняется код в этом блоке. В данном случае вызывается функция `yay()`.
4. `break;`: Оператор `break` завершает выполнение `switch`, предотвращая выполнение кода в других `case` или `default`.
5. `default:`: Этот блок не выполняется, потому что был найден совпадающий `case`.
6. `neverhappens();`: Эта функция не вызывается, потому что до нее выполнение не доходит из-за `break`.
### Практический результат
Когда этот код выполняется:
- Функция `yay()` будет вызвана, потому что `1 + 3` равно `4`, и это совпадает с `2 + 2`.
- Функция `neverhappens()` не будет вызвана из-за наличия `break;` в `case 2 + 2`.
### Заключение
Этот пример показывает, как `switch` может использоваться для сравнения результатов выражений. Оператор `switch` проверяет значение, полученное после вычисления выражения, с каждым значением `case`. Если он находит совпадение, то выполняет соответствующий блок кода и завершает `switch` при помощи `break`. Если совпадений нет, выполняется блок `default`. В данном случае, `default` не выполняется, так как есть совпадение в `case`.
### ---> Конец коментария


Объекты
===

Объекты в JavaScript представляют собой коллекции пар имя-значение (ключ-значение). Они похожи на:
- Словари в Python.
- Хеши в Perl и Ruby.
- Таблицы хешей в C и C++.
- HashMaps в Java.
- Ассоциативные массивы в PHP.

Именем свойства объекта в JavaScript выступает строка, а значением может быть любой тип данных JavaScript, даже другие объекты. Это позволяет создавать структуры данных любой сложности.

Существует два основных способа создать объект:
```js
var obj = new Object();
```

А также:
```js
var obj = {};
```

Обе эти записи делают одно и то же. Вторая запись называется литералом объекта и более удобная. Такой способ является основой формата JSON, и при написании кода лучше использовать именно его.

С помощью литерала объекта можно создавать не только пустые объекты, но и объекты с данными:
```js
var obj = {
  name: "Carrot",
  for: "Max",
  details: {
    color: "orange",
    size: 12,
  },
};
```

Доступ к свойствам объекта можно получить следующими способами:
```js
obj.details.color; // orange
obj["details"]["size"]; // 12
```

Эти два метода равнозначны. Первый метод используется, если мы точно знаем к какому методу нам нужно обратиться. Второй метод принимает в качестве имени свойства строку, и позволяет вычислять имя в процессе вычислений. Следует отметить, что последний метод мешает некоторым движкам и минимизаторам оптимизировать код. Если появится необходимость назначить в качестве имён свойств объекта зарезервированные слова, то данный метод тоже может пригодиться:
```js
// Вызовет Syntax error, ведь 'for' это зарезервированное слово
obj.for = "Simon";

// А тут всё нормально
obj["for"] = "Simon";
```

Больше информации об объектах и прототипах: [Object.prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object).

Для получения информации по прототипам объектов и цепям прототипов объектов смотрите [Inheritance and the prototype chain](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).


Массивы
===

Массивы в JavaScript всего лишь частный случай объектов. Работают они практически одинаково (если именем свойства является число, то доступ к нему можно получить только через вызов в скобках `[]`), только у массивов есть одно удивительное свойство `length` (длина). Оно возвращает число, равное самому большому индексу массива + 1.

Создать массив можно по старинке:
```js
var a = new Array();
a[0] = "dog";
a[1] = "cat";
a[2] = "hen";
a.length; // 3
```

Но гораздо удобнее использовать литерал массива:
```js
var a = ["dog", "cat", "hen"];
a.length; // 3
```

Запомните, свойство `array.length` не обязательно будет показывать количество элементов в массиве. Посмотрите пример:
```js
var a = ["dog", "cat", "hen"];
a[100] = "fox";
a.length; // 101
```

Запомните — длина массива это его самый большой индекс плюс один.

Если попытаться получить доступ к несуществующему элементу массива, то получите `undefined`:
```js
typeof a[90]; // undefined
```

Для перебора элементов массива используйте такой способ:
```js
for (var i = 0; i < a.length; i++) {
  // Сделать что-нибудь с элементом a[i]
}
```

ES2015 представляет более краткий [for...of](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...of) способ обхода по итерируемым объектам, в т.ч. массивам:
```js
for (const currentValue of a) {
  // Сделать что-нибудь с currentValue
}
```

Перебрать элементы массива также можно с помощью цикла `for...in`. Но, если вдруг будет изменено какое-либо свойство `Array.prototype`, то оно тоже будет участвовать в выборке. Не используйте данный метод.

И самый новый способ перебора свойств массива был добавлен в ECMAScript 5 — это метод [forEach()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach):
```js
["dog", "cat", "hen"].forEach(function (currentValue, index, array) {
  // Сделать что-нибудь с currentValue или array[index]
});
```

Для добавления данных в массив используйте метод `push()`:
```js
a.push(item);
```
У массивов есть ещё множество полезных методов. С их полным списком вы можете ознакомиться по [ссылке](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array).

|Метод|Описание|
|---|----|
|`a.toString()`|Возвращает строковое представление массива, где все элементы разделены запятыми.|
|`a.toLocaleString()`|Возвращает строковое представление массива в соответствии с выбранной локалью.|
|`a.concat(item1[, item2[, ...[, itemN]]])`|Возвращает новый массив с добавлением указанных элементов.|
|`a.join(sep)`|Преобразует массив в строку, где в качестве разделителя используется параметр `sep`|
|`a.pop()`|Удаляет последний элемент массива и возвращает его.|
|`a.push(item1, ..., itemN)`|Добавляет один или более элементов в конец массива.|
|`a.reverse()`|Меняет порядок элементов массива на обратный.|
|`a.shift()`|Удаляет первый элемент массива и возвращает его.|
|`a.slice(start[, end])`|Возвращает новый массив.|
|`a.sort([cmpfn])`|	Сортирует данные в массиве.|
|`a.splice(start, delcount[, item1[, ...[, itemN]]])`|Позволяет вырезать из массива его часть и добавлять на это место новые элементы.|
|`a.unshift(item1[, item2[, ...[, itemN]]])`|Добавляет элементы в начало массива.|


Функции
===

Наряду с объектами функции также являются ключевыми компонентами языка JavaScript. Базовые функции очень просты:
```js
function add(x, y) {
  var total = x + y;
  return total;
}
```

В этом примере показано практически всё, что нужно знать о функциях. Функции в JavaScript могут принимать ноль или более параметров. Тело функции может содержать любые выражения и определять свои собственные переменные, которые будут для этой функции локальными. Инструкция `return` используется для возврата значения и остановки выполнения функции. Если инструкции `return` в функции нет (или есть, но не указано возвращаемое значение), то JavaScript возвратит `undefined`.

Можно вызвать функцию, вообще не передавая ей параметры. В таком случае будет считаться, что их значения равны `undefined`:
```js
add(); // NaN
// Нельзя проводить сложение undefined и undefined
```

Можно передать больше аргументов, чем ожидает функция:
```js
add(2, 3, 4); // 5
// используются только первые два аргумента, "4" игнорируется
```

Это может показаться бессмысленным, но на самом деле функции могут получить доступ к "лишним" аргументам с помощью псевдомассива [arguments](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/arguments), в нём содержатся значения всех аргументов, переданных функции. Давайте напишем функцию, которая принимает неограниченное количество аргументов:
```js
function add() {
  var sum = 0;
  for (var i = 0, j = arguments.length; i < j; i++) {
    sum += arguments[i];
  }
  return sum;
}

add(2, 3, 4, 5); // 14
```

Коментарий чата GPT (GPT-4o mini)
---
Этот код определяет функцию `add`, которая суммирует все свои аргументы и возвращает их сумму. Давайте разберём его работу шаг за шагом.
```js
function add() {
  var sum = 0; // Инициализация переменной для хранения суммы
  for (var i = 0, j = arguments.length; i < j; i++) { // Цикл для перебора всех аргументов функции
    sum += arguments[i]; // Добавление текущего аргумента к сумме
  }
  return sum; // Возврат суммы всех аргументов
}

add(2, 3, 4, 5); // Вызов функции с несколькими аргументами
```
### Объяснение
1. Функция `add`: определяет функцию, которая не имеет фиксированного количества параметров.
2. Переменная `sum`:
- Инициализируется значением `0`. Эта переменная будет использоваться для хранения промежуточной суммы всех переданных аргументов.
3. Объект `arguments`:
- Это встроенный объект в JavaScript, доступный внутри всех функций. Он содержит все аргументы, переданные в функцию.
- `arguments.length`: возвращает количество аргументов, переданных в функцию `add`.
4. Цикл `for`:
- Инициализируется с переменными `i` (начальный индекс) и `j` (длина массива `arguments`).
- Цикл выполняется до тех пор, пока `i` меньше `j`.
- Внутри цикла каждый элемент `arguments[i]` добавляется к переменной `sum`.
5. Возврат значения:
- После выполнения цикла функция возвращает значение переменной `sum`, которая содержит сумму всех аргументов.
### Пример работы
При вызове функции `add(2, 3, 4, 5);`:
- Аргументы: `2, 3, 4, 5`
- `arguments.length`: равно `4` (поскольку было передано 4 аргумента).
- Цикл ```for``` будет работать 4 раза:
    - 1-я итерация: `sum = 0 + 2 = 2`
    - 2-я итерация: `sum = 2 + 3 = 5`
    - 3-я итерация: `sum = 5 + 4 = 9`
    - 4-я итерация: `sum = 9 + 5 = 14`
- Результат: функция возвращает `14`.
### Практическое применение
Функция `add` является примером функции с переменным числом аргументов (или вариадической функции). Она полезна, когда нужно суммировать или обрабатывать неизвестное заранее количество числовых аргументов.

### Современный аналог с использованием ES6
В ES6 можно использовать оператор "остатка" (...), чтобы сделать код более читаемым:
```js
function add(...args) {
  return args.reduce((sum, current) => sum + current, 0);
}

add(2, 3, 4, 5); // 14
```
`...args:` собирает все аргументы функции в массив `args`.
`reduce`: метод массива, который используется для суммирования всех элементов массива.
### ---> Конец коментария

Или создадим функцию для вычисления среднего значения:
```js
function avg() {
  var sum = 0;
  for (var i = 0, j = arguments.length; i < j; i++) {
    sum += arguments[i];
  }
  return sum / arguments.length;
}
avg(2, 3, 4, 5); // 3.5
```

Это довольно полезно, но при этом кажется излишне подробным. Для уменьшения количества кода взглянем на замену использования массива аргументов [синтаксисом остаточных параметров](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters). В этом случае мы можем передавать в функцию любое количество аргументов, сохраняя код минималистичным. **Оператор остаточных параметров** используется в списке параметров функции в формате: `...variable` и включает в себя целый список аргументов, с которыми функция будет вызвана. Мы будем также использовать замену цикла `for` циклом `for...of` для получения значений, которые будет содержать наша переменная.
```js
function avg(...args) {
  var sum = 0;
  for (let value of args) {
    sum += value;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5
```

В JavaScript можно создавать анонимные функции:
```js
var avg = function () {
  var sum = 0;
  for (var i = 0, j = arguments.length; i < j; i++) {
    sum += arguments[i];
  }
  return sum / arguments.length;
};
```

Данная запись семантически равнозначна записи `function` `avg()`3. Это даёт возможность использовать разные интересные трюки. Вот посмотрите, как можно "спрятать" локальные переменные в функции:
```js
var a = 1;
var b = 2;
(function () {
  var b = 3;
  a += b;
})();
a; // 4
b; // 2
```

В JavaScript есть возможность рекурсивного вызова функции. Это может оказаться полезным при работе с иерархическими (древовидными) структурами данных (например такие, которые встречаются при работе с [DOM](https://developer.mozilla.org/ru/docs/DOM)).
```js
function countChars(elm) {
  if (elm.nodeType == 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  var count = 0;
  for (var i = 0, child; (child = elm.childNodes[i]); i++) {
    count += countChars(child);
  }
  return count;
}
```

Коментарий чата GPT (GPT-4o mini)
---
Функция `countChars` рекурсивно подсчитывает количество символов в текстовых узлах внутри элемента `elm`. Эта функция полезна для определения общего количества текстовых символов в каком-либо узле DOM (Document Object Model) и его потомках.
### Объяснение работы функции
1. Условие `if (elm.nodeType == 3)`:
- `elm.nodeType` возвращает тип узла. В DOM:
    - `1` — это **ELEMENT_NODE** (элемент HTML, например `<div>`, `<p>`),
    - `3` — это **TEXT_NODE** (текст внутри элемента, например, текст в `<p>Some text</p>`).
- Проверка `elm.nodeType == 3` проверяет, является ли текущий узел текстовым узлом.
- Если узел является текстовым, функция возвращает длину текстового содержимого этого узла с помощью `elm.nodeValue.length`. `nodeValue` содержит текстовое содержимое текстового узла.
2. Переменная `count`:
Инициализируется значением `0` и будет использоваться для подсчета общего количества символов в текстовых узлах.
3. Цикл `for`:
- Перебирает всех дочерних узлов элемента `elm`.
- `elm.childNodes` возвращает коллекцию (NodeList) всех дочерних узлов элемента `elm`.
- `child = elm.childNodes[i]` берет текущий дочерний узел и сохраняет его в переменной `child`.
- Цикл рекурсивно вызывает функцию `countChars` для каждого дочернего узла и добавляет результат к переменной `count`
4. Рекурсивный вызов функции `countChars(child)`:
- Если дочерний узел является текстовым, функция добавляет длину его текстового содержимого к `count`.
- Если дочерний узел является элементом (а не текстом), функция снова рекурсивно проходит через всех его дочерних узлов.
5. Возврат `count`:
- Функция возвращает общее количество символов в текстовых узлах текущего элемента и его дочерних узлов.
### Пример работы функции
Предположим, у нас есть HTML-код:
```html
<div id="example">
  <p>Hello, <b>world</b>!</p>
  <p>How are you?</p>
</div>
```
Если мы вызовем `countChars(document.getElementById("example"))`, то функция выполнится следующим образом:
1. Элемент `<div>` имеет два дочерних узла: два `<p>`.
2. Вызов функции для первого `<p>`:
- У него есть текстовый узел `"Hello, "` и элемент `<b>`.
- Текстовый узел `"Hello, "` имеет длину `7`.
- Элемент `<b>` имеет текстовый узел `"world"` с длиной `5`.
- Символ `!` в первом `<p>` является текстовым узлом длиной `1`.
- Общая длина для первого `<p>` = `7 + 5 + 1 = 13`.
3. Вызов функции для второго `<p>`:
- Текстовый узел `"How are you?"` имеет длину `12`.
- Общая длина для второго `<p>` = `12`.
4. Общая длина текста в элементе `<div>` = `13 + 12 = 25`.
Таким образом, функция вернет `25`.
### Применение
Функция `countChars` полезна для задач, где нужно подсчитать количество символов в текстовых узлах внутри элементов на веб-странице. Это может использоваться для анализа содержимого, создания отчетов, подсчета символов для редакторов текста и других приложений, где важен точный подсчет текста в DOM-дереве.
### ---> Конец коментария

Тут мы сталкиваемся с проблемой: как вызвать функцию рекурсивно, если у неё нет имени? Для этого в JavaScript есть именованные функциональные выражения [IIFEs (Immediately Invoked Function Expressions)](https://developer.mozilla.org/ru/docs/Glossary/IIFE). Вот пример использования именованной самовызывающейся функции:
```js
var charsInBody = (function counter(elm) {
  if (elm.nodeType == 3) {
    // TEXT_NODE
    return elm.nodeValue.length;
  }
  var count = 0;
  for (var i = 0, child; (child = elm.childNodes[i]); i++) {
    count += counter(child);
  }
  return count;
})(document.body);
```
Имя функции в примере доступно только внутри самой функции. Это улучшает оптимизацию и читаемость кода.


Собственные объекты
===

В классическом Объектно-Ориентированном Программировании (ООП) объекты — это коллекции данных и методов, которые этими данными оперируют. JavaScript - это язык, основанный на прототипах, и в его определении нет понятия классов, таких, как в языках C++ или Java. (Иногда это может запутать программистов, знакомых с языками, в которых есть классы.) Вместо классов JavaScript использует функции. Давайте представим объект с личными данными, содержащий поля с именем и фамилией. Есть два типа отображения имён: "Имя Фамилия" или "Фамилия, Имя". С помощью объектов и функций можно сделать следующее:
```js
function makePerson(first, last) {
  return {
    first: first,
    last: last,
  };
}

function personFullName(person) {
  return person.first + " " + person.last;
}

function personFullNameReversed(person) {
  return person.last + ", " + person.first;
}

s = makePerson("Simon", "Willison");
personFullName(s); // Simon Willison
personFullNameReversed(s); // Willison, Simon
```

Работает, но сам код никуда не годится. С таким подходом у вас будут десятки функций, засоряющих глобальный объект. Это можно исправить, прикрепив функцию к объекту. Это просто, ведь все функции и есть объекты:
```js
function makePerson(first, last) {
  return {
    first: first,
    last: last,
    fullName: function () {
      return this.first + " " + this.last;
    },
    fullNameReversed: function () {
      return this.last + ", " + this.first;
    },
  };
}
s = makePerson("Simon", "Willison");
s.fullName(); // Simon Willison
s.fullNameReversed(); // Willison, Simon
```

А вот кое-что новенькое: ключевое слово `this`. Когда `this` используется внутри функции, оно ссылается на текущий объект. Значение ключевого слова зависит от способа вызова функции. Если вызвать функцию с обращением к объекту через [точку или квадратные скобки](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Property_accessors), то `this` получится равным данному объекту. В ином случае `this` будет ссылаться на глобальный объект. Это часто приводит к ошибкам. Например:
```js
s = makePerson("Simon", "Willison");
var fullName = s.fullName;
fullName(); // undefined undefined
```
При вызове `fullName()`, `this` получает ссылку на глобальный объект. А так как в глобальном объекте не определены переменные `first` и `last`, то имеем два `undefined`.

Используя особенность ключевого слова `this`, можно улучшить код функции `makePerson`:
```js
function Person(first, last) {
  this.first = first;
  this.last = last;
  this.fullName = function () {
    return this.first + " " + this.last;
  };
  this.fullNameReversed = function () {
    return this.last + ", " + this.first;
  };
}
var s = new Person("Simon", "Willison");
```

В примере мы использовали новое ключевое слово: [new](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new). Оно тесно связано с [this](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this). Данное ключевое слово создаёт новый пустой объект, а потом вызывает указанную функцию, а `this` получает ссылку на этот новый объект. Функции, которые предназначены для вызова с `new` называются конструкторами. Существует соглашение, согласно которому все функции-конструкторы записываются с заглавной буквы.

Мы доработали наш код в предыдущем примере, но всё равно остался один неприятный момент с самостоятельным вызовом `fullName()`.

Каждый раз, когда с помощью конструктора создаётся новый объект, мы заново создаём и две новые функции. Гораздо удобнее создать эти функции отдельно и дать доступ к ним конструктору:
```js
function personFullName() {
  return this.first + " " + this.last;
}
function personFullNameReversed() {
  return this.last + ", " + this.first;
}
function Person(first, last) {
  this.first = first;
  this.last = last;
  this.fullName = personFullName;
  this.fullNameReversed = personFullNameReversed;
}
```

Уже лучше: мы создали функции-методы только один раз, а при новом вызове функции-конструктора просто ссылаемся на них. Можно сделать ещё лучше? Конечно:
```js
function Person(first, last) {
  this.first = first;
  this.last = last;
}
Person.prototype.fullName = function fullName() {
  return this.first + " " + this.last;
};
Person.prototype.fullNameReversed = function fullNameReversed() {
  return this.last + ", " + this.first;
};
```

`Person.prototype` это объект, доступ к которому есть у всех экземпляров класса `Person`. Он создаёт особую цепочку прототипов. Каждый раз, когда вы пытаетесь получить доступ к несуществующему свойству объекта `Person`, JavaScript проверяет, существует ли свойство в `Person.prototype`. В результате все, что передано в `Person.prototype`, становится доступным и всем экземплярам этого конструктора через `this` объект.

Это очень мощный инструмент. JavaScript позволяет изменять прототипы в любое время, это значит, что можно добавлять новые методы к существующим объектам во время выполнения программы:
```js
s = new Person("Simon", "Willison");
s.firstNameCaps();
// TypeError on line 1: s.firstNameCaps is not a function

Person.prototype.firstNameCaps = function () {
  return this.first.toUpperCase();
};
s.firstNameCaps(); // "SIMON"
```

Занимательно то, что добавлять свойства в прототип можно и для встроенных объектов JavaScript. Давайте добавим новый метод `reversed` классу `String`, этот метод будет возвращать строку задом наперёд:
```js
var s = "Simon";
s.reversed(); // TypeError on line 1: s.reversed is not a function

String.prototype.reversed = function reversed() {
  var r = "";
  for (var i = this.length - 1; i >= 0; i--) {
    r += this[i];
  }
  return r;
};
s.reversed(); // "nomiS"
```

Данный метод будет работать даже на литералах строки!
```js
"This can now be reversed".reversed();
// desrever eb won nac sihT
```

Как уже упоминалось, `prototype` формирует часть цепочки. Конечным объектом этой цепочки прототипов является `Object.prototype`, методы которого включают и `toString()` — тот метод, который вызывается тогда, когда надо получить строковое отображение объекта. Вот что можно сделать с нашими объектами `Person`:
```js
var s = new Person("Simon", "Willison");
s.toString(); // [object Object]

Person.prototype.toString = function () {
  return "<Person: " + this.fullName() + ">";
};

s.toString(); // "<Person: Simon Willison>"
```

Помните, мы вызывали `avg.apply()` с первым аргументом равным `null`? Теперь мы можем сделать так: первым аргументом, переданным методу `apply()` будет объект, который примет значение `this`. Вот к примеру упрощённая реализация `new`:
```js
function trivialNew(constructor, ...args) {
  var o = {}; // Создаём новый объект
  constructor.apply(o, args);
  return o;
}
```

Это не точная копия new, так как она не устанавливает цепочку прототипов (это сложно ). `Метод apply()` применяется не очень часто, но знать его важно. В примере выше, синтаксис `...args` (включая многоточие) называется остаточными параметрами, потому что они включают в себя все оставшиеся аргументы.

Вызов
```js
var bill = trivialNew(Person, "William", "Orange");
```

практически полностью эквивалентен этому:
```js
var bill = new Person("William", "Orange");
```

В JavaScript метод `apply()` имеет похожий метод `call()`, который тоже позволяет устанавливать `this`, но принимает список, а не массив аргументов.
```js
function lastNameCaps() {
  return this.last.toUpperCase();
}
var s = new Person("Simon", "Willison");
lastNameCaps.call(s);
// Аналогично записи:
s.lastNameCaps = lastNameCaps;
s.lastNameCaps(); // WILLISON
```

Вложенные функции
---

Объявлять новые функции можно и внутри других функций. Мы использовали этот приём чуть выше, создавая функцию `makePerson()`. Главная особенность вложенных функций в том, что они получают доступ к переменным, объявленным в их функции-родителе:
```js
function parentFunc() {
  var a = 1;

  function nestedFunc() {
    var b = 4; // parentFunc can't use this
    return a + b;
  }
  return nestedFunc(); // 5
}
```

Это очень полезное свойство, которое делает сопровождение кода более удобным. Если ваша функция в своей работе использует другие функции, которые больше нигде не используются, то можно просто вложить вспомогательные функции в основную. Это сократит количество функций в глобальном объекте, что довольно неплохо.

Ещё это отличный способ сократить количество глобальных переменных. Так при написании кода у нас часто будет возникать искушение понасоздавать глобальных переменных, которые будут доступны разным функциям. Всё это усложняет код, делает его менее читаемым. Вложенные функции имеют доступ к переменным своей функции-родителя, и мы можем использовать это для группировки множества функций вместе (естественно в разумных пределах), что позволит держать наш глобальный объект в чистоте и порядке.

Замыкания (Closures)
---

Мы подошли к одному из самых мощных и непонятных инструментов JavaScript. Давайте разберёмся.
``` js
Copy to Clipboard
function makeAdder(a) {
  return function (b) {
    return a + b;
  };
}

var x = makeAdder(5);
var y = makeAdder(20);
x(6); // ?
y(7); // ?
```

Функция `makeAdder` создаёт новую функцию, которая прибавляет полученное значение к значению, которые было получено при создании функции.

Такой же фокус мы наблюдали в предыдущем примере, когда внутренние функции получали доступ к переменным той функции, в которой были объявлены. Только в нашем примере основная функция возвращает вложенную. Поначалу может показаться, что локальные переменные при этом перестанут существовать. Но они продолжают существовать — иначе код попросту не сработал бы. Вдобавок ко всему у нас есть две разные "копии" функции `makeAdder`, присвоенные разным переменным (одна копия, в которой `а` - это 5, а во второй `а` - это 20). Вот что имеем в результате вызова:
```js
x(6); // возвратит 11
y(7); // возвратит 27
```

И вот что произошло: когда JavaScript выполняет функцию, создаётся объект 'scope', который содержит в себе все локальные переменные, объявленные внутри этой функции. Он инициализируется любым значением, переданным функции в качестве параметра. 'Scope' подобен глобальному объекту, который содержит все глобальные переменные и функции, кроме нескольких важных отличий: при каждом вызове функции создаётся новый объект 'scope' и, в отличие от глобального, к объекту 'scope' нельзя получить прямой доступ из вашего кода. И нет способа пройтись по свойствам данного объекта.

Так что при вызове функции `makeAdder` создаётся новый объект 'scope' с единственным свойством: a, которому присваивается значение, переданное функции в качестве аргумента. Потом `makeAdder` возвращает новую анонимную функцию. В любом другом случае 'сборщик мусора' удалил бы объект scope, но возвращаемая функция ссылается на этот объект. В итоге объект scope не удаляется до тех пор, пока существует хотя бы одна ссылка на него.

Все объекты scope соединяются в цепочку областей видимости, которая похожа на цепочку прототипов в объектной системе JavaScript.

Замыкание это связка из функции и объекта scope, созданного при её вызове. [Подробнее о замыканиях здесь.](https://stackoverflow.com/questions/111102/how-do-javascript-closures-work)


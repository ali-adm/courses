[Оригинальный источник](https://ru.react.js.org/docs/hello-world.html)

<a name="back"></a>
## Оглавление:

### [1. Привет, мир](#1_hello_w)
  #### [Как читать это руководство](#how_to)
  #### [Ожидаемый уровень знаний](#knowlegs)
  #### [Почему JSX?](#why_jsx)
  #### [Встраивание выражений в JSX](#expression)
  #### [JSX — это выражение тоже](#jsx_expression_too)
  #### [Установка атрибутов с помощью JSX](#attributes_with_jsx)
  #### [Установка дочерних элементов с помощью JSX](#children)
  #### [JSX предотвращает атаки-инъекции](#anti_xss)
  ### [GPT-4o. Экранирование и безопасность](#gpt_shielding_safety)
  #### [JSX представляет из себя объекты](#jsx_is_objects)
### [2. Введение в JSX](#intro_jsx)
### [3. Отрисовка элементов](#render_elements)
### [4. Компоненты и свойства](#propert)
### [5. Свойство (состояние) и жизненный цикл](#current)
### [ipsum](#lorem)


<a name="1_hello_w"></a>
# 1. Привет, мир

### Самый небольшой пример на React выглядит так:
```js
ReactDOM.render(
  <h1>Привет, мир!</h1>,
  document.getElementById('root')
);
```

На странице отображается заголовок «Привет, мир!».

[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/hello-world)

Нажмите на ссылку выше для открытия онлайн-редактора. Не стесняйтесь вносить собственные изменения и смотреть, как они влияют на результат. На большинстве страниц этого руководства будут присутствовать такие доступные для редактирования примеры, как этот.

### [Назад к оглавлению](#back)


<a name="how_to"></a>
Как читать это руководство
---

В этом руководстве мы рассмотрим строительные блоки React-приложений: элементы и компоненты. Как только вы освоите их, то сможете создавать сложные приложения из небольших повторно используемых частей.

> ### Совет 
> Это руководство предназначено для людей, которые предпочитают **концепцию обучения «шаг за шагом»**. Если вы предпочитаете учиться на практике, ознакомьтесь с нашим [практическим руководством](https://ru.react.js.org/tutorial/tutorial.html). Возможно, вы обнаружите, что руководство и учебник дополняют друг друга.

Это первая глава в пошаговом руководстве по основным концепциям React. Ссылка на оригинал руководствав дана в самом начале документа. Все ссылки в документе - оригнальны и ведут на сторонние ресурсы. В пределах этого документа - работают ссылки в описании в начале документа. В конце каждой главы имеется ссылка в начало, к описанию.

Каждая глава этого руководства основывается на знаниях, представленных в предыдущих главах. **Вы можете узнать большинство из React, прочитав главы руководства «Основные концепции» в том порядке, в котором они перечислены в боковой панели.** Например, [«Введение в JSX»](https://ru.react.js.org/docs/introducing-jsx.html) — следующая глава после этой.

### [Назад к оглавлению](#back)


<a name="knowlegs"></a>
Ожидаемый уровень знаний
---
React — это библиотека JavaScript, поэтому мы предполагаем, что у вас есть базовое понимание языка JavaScript. **Если вы не очень уверенны, мы рекомендуем [изучить данное введение в JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript) для проверки своего уровня знаний,** чтобы успешно изучить это руководство. Это может занять от 30 минут до часа, но в результате вам не придётся чувствовать, что вы одновременно изучаете и React, и JavaScript.

> ### Примечание
> Данное руководство в примерах иногда использует некоторые из новых возможностей JavaScript. Если вы не работали с JavaScript в последние несколько лет, [эти три пункта](https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c) должны дать знания, достаточные для комфортного чтения этой документации.

>> ### Примечание'
>> Вышеупомянутые три пункта - являются важным дополнением данного руководства, поэтому их перевод, для удобства, будет приведен здесь.
> 
> Если вы не работали с JavaScript в последние несколько лет, эти три пункта должны дать вам достаточно знаний, чтобы чувствовать себя комфортно при чтении документации React:
> 1.  Мы определяем переменные с помощью операторов [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) и [`const`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const). Для целей документации React вы можете считать их эквивалентными [`var`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var).
> 2. Мы используем `class` ключевое слово для определения [классов JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes). О них стоит помнить две вещи. Во-первых, в отличие от объектов, вам не нужно ставить запятые между определениями методов класса. Во-вторых, в отличие от многих других языков с классами, в JavaScript значение `this` в методе [зависит от того, как он вызывается](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Boxing_with_prototype_and_static_methods).
> 3. Мы иногда используем `=>` для определения ["функций со стрелками"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions). Они похожи на обычные функции, но короче. Например, `x => x * 2` примерно эквивалентно `function(x) { return x * 2; }`. Важно отметить, что функции со стрелками [не имеют собственного `this` значения](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_separate_this), поэтому они удобны, когда вы хотите сохранить `this` значение из определения внешнего метода. 
> 
> **Не волнуйтесь, если этого слишком много для восприятия за один раз. [Справочник MDN по JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) - отличный ресурс, и вы можете обратиться к нему всякий раз, когда вас что-то смущает.**
>
> Кроме того, если вы не уверены в значении какого-либо нового синтаксиса, вы можете использовать [Babel REPL с предустановкой ES2015](http://babeljs.io/repl/#?babili=false&browsers=&build=&builtIns=false&code_lz=MYewdgzgLgBAllApgWwjAvDA2gRgDQwBMBAzALoDcAUKJLACYgCuARgDaL0bxKoB0yAIYAHABQAPDAD4YkgFREAlBSA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&lineWrap=true&presets=es2015%2Creact%2Cstage-1%2Cstage-2%2Cstage-3&prettier=true&targets=Node-6.12&version=6.26.0&envVersion=), чтобы проверить, к какому эквивалентному старому синтаксису он компилируется.

## Давайте начнём
Продолжайте прокручивать страницу вниз, и вы найдете ссылку на [следующую главу руководства](https://ru.react.js.org/docs/introducing-jsx.html) прямо перед футером сайта.

### [Назад к оглавлению](#back)


<a name="intro_jsx"></a>
# 2. Введение в JSX

### Рассмотрим это объявление переменной:
```js
const element = <h1>Привет, мир!</h1>;
```

Синтаксис этого странного тега не является ни строкой, ни HTML.

Он называется JSX, и это расширение синтаксиса JavaScript. Мы рекомендуем использовать его с React для описания того, как должен выглядеть пользовательский интерфейс. JSX может напомнить вам о языке шаблонов, но со всей полной мощью JavaScript.

JSX создаёт «элементы» React. Мы рассмотрим их отрисовку в DOM в [следующем разделе](https://ru.react.js.org/docs/rendering-elements.html). Ниже вы можете найти основы JSX, необходимые для начала работы.

### [Назад к оглавлению](#back)


<a name="why_jsx"></a>
Почему JSX?
---
React принимает тот факт, что логика отрисовки по сути связана с другой логикой пользовательского интерфейса: как обрабатываются события, как изменяется состояние со временем и как данные подготовлены для отображения.

Вместо искусственного разделения технологий, помещая разметку и логику в отдельные файлы, React [разделяет ответственности](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8) с слабо связанными модулями, называемыми «компонентами», которые содержат вместе разметку и логику. Мы вернёмся к компонентам в следующем разделе, но если вы ещё не очень хорошо умеете размещать разметку в JS, этот доклад может убедить вас в другом.

React не требует использование JSX, но большинство людей находят его полезным в качестве визуальной демонстрации при работе с пользовательским интерфейсом внутри кода JavaScript. Он также позволяет React показывать более полезные сообщения об ошибках и предупреждения.

Теперь, когда с этим разобрались, давайте начнём!

### [Назад к оглавлению](#back)


<a name="expression"></a>
Встраивание выражений в JSX
---

В приведённом ниже примере мы объявляем переменную с именем `name`, а затем используем ее внутри JSX, обернув ее в фигурные скобки:
```js
const name = 'Josh Perez';
const element = <h1>Привет, {name}</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

В фигурных скобках JSX вы можете поместить любое корректное [выражение JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions). Например, `2 + 2, user.firstName`, или `formatName(user)` — всё это допустимые выражения в JavaScript.

В приведённом ниже примере мы вставляем результат вызова функции JavaScript, `formatName(user)`, в элемент `<h1>`.
```js
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```
[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/introducing-jsx)

Мы разделяем JSX на несколько строк для удобства чтения. Хотя это не требуется, при этом мы также рекомендуем обёртывать его в круглых скобках, чтобы избежать ошибок, связанных с [автоматической вставкой точки с запятой](http://stackoverflow.com/q/2846283).

### [Назад к оглавлению](#back)


<a name="jsx_expression_too"></a>
JSX — это выражение тоже
---

После компиляции выражения JSX становятся обычными вызовами функций JavaScript и вычисляются в объекты JavaScript.

Это означает, что вы можете использовать JSX внутри операторов `if` и `for`, присваивать его переменным, принимать его в качесиве аргументов и возвращать из функций:
```js
function getGreeting(user) {
  if (user) {
    return <h1>Привет, {formatName(user)}!</h1>;
  }
  return <h1>Привет, незнакомец.</h1>;
}
```

### [Назад к оглавлению](#back)


<a name="attributes_with_jsx"></a>
Установка атрибутов с помощью JSX
---

Вы можете использовать кавычки для указания строковых литералов в качестве атрибутов:
```js
const element = <div tabIndex="0"></div>;
```
Вы также можете использовать фигурные скобки для вставки JavaScript-выражения в атрибут:
```js
const element = <img src={user.avatarUrl}></img>;
```
Не используйте кавычки вокруг фигурных скобок при вставке выражения JavaScript в атрибут. Нужно использовать либо кавычки (для строковых значений), либо фигурные скобки (для выражений), но не оба в одном и том же атрибуте.

> ### ** Внимание: **
>
>Поскольку JSX ближе к JavaScript, чем к HTML, React DOM использует соглашение об именах свойств camelCase вместо имён атрибутов HTML.
>
>Например, `class` становится `className` в JSX, а tabindex становится [tabIndex](https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/tabIndex).

### [Назад к оглавлению](#back)


<a name="children"></a>
Установка дочерних элементов с помощью JSX
---

Если тег пуст, вы можете немедленно его закрыть с помощью `/>`, точно так же, как в XML:
```JS
const element = <img src={user.avatarUrl} />;
```

Теги JSX могут содержать дочерние элементы:
```JS
const element = (
  <div>
    <h1>Привет!</h1>
    <h2>Рад тебя видеть.</h2>
  </div>
);
```

### [Назад к оглавлению](#back)


<a name="anti_xss"></a>
JSX предотвращает атаки-инъекции
---

Безопасно встраивать пользовательские данные в JSX:
```JSJ
const title = response.potentiallyMaliciousInput;
// Это безопасно:
const element = <h1>{title}</h1>;
```

По умолчанию DOM React [экранирует](http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html) любые значения, встроенные в JSX, перед их отрисовкой. Таким образом, гарантируется, что вы никогда не сможете внедрить то, чего явно нет в вашем приложении. Перед отрисовкой все преобразуется в строку. Это помогает предотвратить атаки [межсайтовый скриптинг (cross-site-scripting, XSS)](https://ru.wikipedia.org/wiki/Межсайтовый_скриптинг).

### [Назад к оглавлению](#back)


<a name="gpt_shielding_safety"></a>
Комментарий GPT-4o. Экранирование и безопасность
---

В этом контексте **экранирование** означает, что React автоматически обрабатывает и преобразует любые значения, которые вставляются в JSX, чтобы предотвратить выполнение вредоносного кода, такого как XSS-атаки (межсайтовый скриптинг).

### Как это работает:
1. **Безопасное отображение данных**: 
   Когда ты вставляешь данные из переменной в JSX (например, `<h1>{title}</h1>`), React автоматически преобразует всё, что ты туда вставляешь, в строку. Это делается, чтобы злоумышленник не смог внедрить JavaScript-код, который может быть выполнен в браузере.

2. **Экранирование спецсимволов**:
   Если потенциально опасные символы (например, `<`, `>`, `"`, `'`, или `&`) попадают в переменные, React заменяет их безопасными HTML-эквивалентами:
   - `<` → `&lt;`
   - `>` → `&gt;`
   - `"` → `&quot;`
   - и т.д.
   
   Это предотвращает исполнение вредоносных скриптов, даже если кто-то попытается вставить код через переменные.

### Пример XSS-атаки:
Представь, что переменная `title` содержит следующий вредоносный ввод:
```javascript
const title = '<script>alert("XSS")</script>';
```
Если React не экранировал бы это значение, оно могло бы быть вставлено в DOM и выполнено, что вызвало бы появление всплывающего окна (или даже выполнение более серьёзного кода). Однако, благодаря экранированию, React отобразит это как простой текст:
```html
<h1>&lt;script&gt;alert("XSS")&lt;/script&gt;</h1>
```
Вместо того чтобы выполнить скрипт, браузер просто отобразит его как строку.

### В чём заключается безопасность:
- **React защищает от XSS-атак** путём автоматического экранирования любых данных, переданных в JSX. Это предотвращает возможность выполнения кода, который явно не был предусмотрен в приложении, и делает данные, поступающие от пользователей, безопасными для отображения.
---
Давай разберём этот пример более подробно:

```javascript
const title = response.potentiallyMaliciousInput;
// Это безопасно:
const element = <h1>{title}</h1>;
```

### Что происходит:
1. **`response.potentiallyMaliciousInput`**: Здесь предполагается, что переменная `title` получает данные от пользователя или из какого-то внешнего источника, и эти данные могут быть потенциально вредоносными (например, содержать HTML-код или JavaScript).
   
2. **JSX-синтаксис**: Далее в JSX (внутри тега `<h1>`) мы вставляем значение переменной `title`. Это может быть небезопасно в других системах, так как злоумышленник мог бы вставить в этот ввод вредоносный код.

3. **Безопасность React**:
   - **Экранирование**: React автоматически экранирует значение переменной `title`. Если внутри `potentiallyMaliciousInput` находится вредоносный код, вроде `<script>alert("XSS")</script>`, React преобразует его в безопасную строку перед тем, как вставить в DOM.
   - **Преобразование в строку**: Всё, что передаётся в JSX (например, в `{title}`), будет преобразовано в строку, даже если это были потенциальные HTML- или JavaScript-вставки.

### Почему это безопасно:
Даже если пользователь или злоумышленник попытается передать опасный код через `response.potentiallyMaliciousInput`, React не позволит этому коду выполниться. Он отобразится как текст, а не как работающий код.

Пример:
```javascript
const title = '<script>alert("XSS")</script>';
const element = <h1>{title}</h1>;
```

Вместо того чтобы запуститься, этот код будет отображён на странице как обычный текст:
```html
<h1>&lt;script&gt;alert("XSS")&lt;/script&gt;</h1>
```

То есть пользователи увидят на экране:
```
<script>alert("XSS")</script>
```
Но этот скрипт **не выполнится** благодаря тому, что React экранирует специальные символы (`<`, `>` и т.д.), превращая их в безопасные текстовые эквиваленты.

### Важно:
Экранирование React не работает, если ты явно отключаешь его через опасные функции вроде `dangerouslySetInnerHTML`.

---
Еще раз уточним:

### Что такое экранирование:
Экранирование — это процесс преобразования специальных символов (HTML, JavaScript и других) в их безопасные текстовые представления, чтобы они не воспринимались как код, а отображались просто как текст.

**Пример с HTML**:
- Специальные символы, как `<`, `>`, `&`, имеют особое значение в HTML, так как они используются для тегов. Если они присутствуют в строке, и мы не экранируем их, браузер может интерпретировать их как HTML-код.

**Пример с JavaScript**:
- В XSS-атаках злоумышленники пытаются внедрить JavaScript-код, который может выполниться в браузере. Экранирование предотвращает выполнение этого кода, переводя его в безопасную строку.

### Как это работает:
Когда мы говорим, что символы экранируются, это значит, что их заменяют на специальные **HTML-энтити**, которые безопасны для вывода. Например:
- `<` → `&lt;`
- `>` → `&gt;`
- `&` → `&amp;`

Таким образом, если ты пытаешься отобразить строку, содержащую `<script>`, браузер **не исполнит этот скрипт**, потому что React преобразует символы `<` и `>` в их безопасные версии.

### Почему это называется "экран":
Слово "экран" в этом контексте означает **защиту от выполнения кода**. Экранирование предотвращает выполнение потенциально опасного кода, показывая его просто как текст. Это своего рода "щит" или "фильтр", который блокирует выполнение вредоносного кода.

### Как использовать экранирование в React:
В React экранирование происходит **автоматически**, когда ты вставляешь переменные в JSX через фигурные скобки `{}`.

**Пример:**
```javascript
const title = '<script>alert("XSS")</script>';
const element = <h1>{title}</h1>;
```

Здесь переменная `title` содержит потенциально опасный HTML или JavaScript, но благодаря экранированию React отобразит это как текст:
```html
<h1>&lt;script&gt;alert("XSS")&lt;/script&gt;</h1>
```
Этот текст будет виден на странице, но **скрипт не выполнится**.

### Фигурные скобки в JSX:
Фигурные скобки `{}` в JSX используются для вставки JavaScript-выражений в HTML. Они также позволяют безопасно отображать переменные, как в приведённом выше примере. Ты можешь использовать их для передачи данных в HTML элементы:
```javascript
const name = "John";
const element = <h1>{name}</h1>; // Вставит "John" в <h1>
```

Экранирование в React всегда срабатывает, когда ты используешь такие выражения внутри JSX.

### [Назад к оглавлению](#back)


<a name="jsx_is_objects"></a>
JSX представляет из себя объекты
---

Babel компилирует JSX в вызовы `React.createElement()`.

Ниже два примера идентичны:
```js
const element = (
  <h1 className="greeting">
    Привет, мир!
  </h1>
);
```
```js
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Привет, мир!'
);
```
`React.createElement ()` выполняет несколько проверок для помощи вам написать код без ошибок, но по сути он создает такой объект:
```js
// Примечание: эта структура упрощена
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Привет, мир!'
  }
};
```

Эти объекты называются элементами «React-элементами». Можно думать о них как о том, что вы хотите видеть на экране. React считывает эти объекты и использует их для построения DOM и его обновления.

Мы рассмотрим отрисовку элементов React в DOM в следующем разделе.

> ### ** Совет: **
>
>Мы рекомендуем использовать [определение языка «Babel»](http://babeljs.io/docs/editors) в вашем редакторе, чтобы как код ES6, так и JSX были правильно подсвечены. Этот сайт использует цветовую схему [Oceanic Next](https://labs.voronianski.com/oceanic-next-color-scheme/), которая совместима с этим определением.

### [Назад к оглавлению](#back)


<a name="render_elements"></a>
# 3. Отрисовка элементов

### Элементы — это самые маленькие строительные блоки приложений React.

Элемент описывает, что вы хотите видеть на экране:
```js
const element = <h1>Hello, world</h1>;
```

В отличие от DOM-элементов браузера, элементы React — обычные объекты, лёгкие для создания. React DOM берёт заботу по обновлению DOM на себя для соответствия элементам React.

> ### Примечание: 
> Может сбить с толку элементы с более широко известной концепцией «компонентов». Мы представим компоненты в [следующем разделе](/docs/components-and-props.html). Элементы — это то, что из чего компоненты «сделаны», и мы рекомендуем вам прочитать этот раздел, прежде чем идти вперёд.

### Отрисовка элемента в DOM

Предположим, что в вашем файле HTML есть `<div>`:
```js
<div id="root"></div>
```

Мы называем это «корневым» узлом DOM, потому что всё внутри него будет управляться DOM React.

У приложений, созданных только с использованием React, обычно есть только единственный корневой узел DOM. Если вы интегрируете React в существующее приложение, у вас может быть как можно больше изолированных корневых узлов DOM.

Коментарий GPT-4o. DOM и рендеринг.
---

Утверждение верное, хотя может показаться запутанным.

### Что имеется в виду:

1. **Единственный корневой узел DOM**:
   - Когда ты создаёшь приложение только на React, обычно у тебя есть один корневой узел DOM, куда React "встраивает" всё приложение. Например, у тебя есть один элемент `<div id="root">`, и всё приложение рендерится в этот единственный элемент через `ReactDOM.render()`.
   
2. **Множественные корневые узлы DOM**:
   - Если ты **интегрируешь React в существующее приложение**, то возможно, что у тебя будет несколько разных мест (узлов) на странице, где будут рендериться компоненты React. Например, у тебя может быть несколько элементов типа `<div id="react-root-1">`, `<div id="react-root-2">` и так далее, в каждом из которых React будет рендерить свои компоненты.

### Почему это не "как можно меньше", а именно **"как можно больше"**:
- В приложениях, где React используется частично (например, для динамических виджетов в разных частях страницы), ты можешь использовать **несколько корневых узлов**. Каждый такой узел будет независим, и React будет рендерить компоненты внутри этих узлов отдельно.
  
- Это особенно полезно, если у тебя **гибридное приложение**, где React не является основной технологией, а лишь добавляет отдельные интерактивные элементы. Таким образом, у тебя может быть **много изолированных корневых узлов DOM**, каждый из которых управляется React, но они не пересекаются и работают автономно.

### Пример:
Представь, что у тебя есть существующее приложение на обычном HTML/JavaScript, и ты добавляешь React только для отдельных частей страницы:
```html
<div id="header-root"></div>  <!-- React рендерит хедер -->
<div id="sidebar-root"></div> <!-- React рендерит боковую панель -->
<div id="content-root"></div> <!-- React рендерит контент -->
```
Здесь каждый элемент является **изолированным корневым узлом**. React рендерит свои компоненты в каждом из них независимо.

### Вывод:
Фраза "как можно больше" означает, что ты можешь использовать **несколько корневых узлов** DOM для рендеринга отдельных частей React-компонентов в разных местах страницы. Это не ошибка перевода.

---

Теперь давай разберём рендеринг более детально.

### Что такое рендеринг?

В контексте фронтенд-разработки **рендеринг** — это процесс **преобразования данных и логики приложения в пользовательский интерфейс (UI)**, который видит пользователь в браузере. Это включает создание или обновление HTML-элементов на странице в зависимости от состояния приложения.

### Виды рендеринга:

1. **Первичный рендеринг**:
   - Это когда приложение впервые загружается, и React (или любая другая технология) строит структуру элементов в DOM. Например, при запуске React-приложения происходит начальная отрисовка компонентов в браузере.

2. **Повторный рендеринг**:
   - Это процесс обновления UI, когда изменяется состояние или данные приложения. React определяет, какие части интерфейса нужно изменить, и обновляет только их, не перерисовывая всё приложение.

### Как рендеринг работает изнутри (на примере React):

1. **Virtual DOM (виртуальный DOM)**:
   - React использует **виртуальный DOM**, который представляет собой копию реального DOM, но хранится в памяти. Это ключевой элемент, который делает рендеринг быстрым и эффективным.
   - Когда компоненты обновляются (например, меняется состояние или props), React сначала обновляет виртуальный DOM, сравнивает его с предыдущей версией (этот процесс называется **diffing**), и только после этого применяет изменения к реальному DOM.

2. **Шаги рендеринга**:

   - **Создание компонента**:
     - Когда ты пишешь JSX-код, React преобразует его в вызовы JavaScript-функций, которые создают компоненты.
     - Например, компонент `<h1>Hello, world!</h1>` создаётся как объект в виртуальном DOM с типом `h1` и текстовым содержимым `"Hello, world!"`.

   - **Обновление виртуального DOM**:
     - Когда данные или состояние компонента изменяются, React обновляет виртуальный DOM.
     - React не рендерит всю страницу заново, а только обновляет ту часть, которая действительно изменилась. Это делает работу более производительной.

   - **Diffing и Reconciliation**:
     - React сравнивает текущий виртуальный DOM с предыдущим. Этот процесс называется **diffing**.
     - Если есть различия, React определяет, какие именно элементы изменились, и применяет только эти изменения к реальному DOM.

   - **Применение изменений в реальный DOM**:
     - После сравнения React обновляет только изменённые элементы в реальном DOM. Это называется **reconciliation**.
     - Например, если ты обновляешь текст в элементе `<h1>`, React изменит только текст, не перерисовывая весь компонент.

### Зачем нужен виртуальный DOM?

Обновление реального DOM — это довольно медленный процесс, особенно если изменять весь интерфейс целиком. Виртуальный DOM служит промежуточным слоем, который позволяет React эффективно определять минимальный набор изменений для обновления UI. Это значительно улучшает производительность приложений.

### Пример рендеринга в React:

```javascript
function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

1. **Первичный рендеринг**: Когда приложение впервые загружается, React создаёт HTML-структуру, которая отображает значение `count = 0`.

2. **Повторный рендеринг**: Когда пользователь нажимает кнопку, функция `setCount` изменяет состояние, и React обновляет компонент. Он проверяет, что изменилось (в данном случае только текст внутри `<h1>`), и обновляет **только этот элемент** в реальном DOM, оставив остальные элементы (кнопку и контейнер) без изменений.

### Зачем это нужно?

Рендеринг делает интерфейс интерактивным и динамическим, позволяя пользователю взаимодействовать с приложением, а React эффективно управляет обновлениями. Благодаря использованию виртуального DOM React делает это оптимально, обновляя только те части, которые изменились, что улучшает производительность.

### Виды рендеринга в широком смысле:

1. **Клиентский рендеринг (Client-Side Rendering, CSR)**: Весь рендеринг происходит на стороне клиента (в браузере). React традиционно работает по этой схеме.
   
2. **Серверный рендеринг (Server-Side Rendering, SSR)**: UI предварительно рендерится на сервере и отправляется на клиент в виде готового HTML-кода. Это ускоряет загрузку страниц и улучшает SEO.

3. **Статический рендеринг (Static Site Generation, SSG)**: Страницы рендерятся один раз во время сборки и служат в виде статических файлов. Это ещё быстрее для готовых страниц, но не подходит для динамического контента.

Надеюсь, это прояснило, как работает рендеринг в React и почему он так важен!

---

Теперь давай рассмотрим DOM — это основа для работы с веб-страницами.

### Что такое DOM?

**DOM (Document Object Model)** — это интерфейс, который браузеры используют для представления веб-страницы. Проще говоря, это **объектная модель документа**, которая позволяет скриптам (например, JavaScript) взаимодействовать с HTML и CSS на веб-странице.

Когда ты загружаешь страницу в браузере, HTML-файл превращается в дерево объектов DOM. Каждый элемент HTML (например, `<div>`, `<p>`, `<img>`) становится узлом в этом дереве, и с каждым из этих узлов можно взаимодействовать программно.

### Структура DOM

DOM представляет HTML-документ как дерево узлов. Каждый узел — это элемент страницы.

**Пример HTML:**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Пример</title>
  </head>
  <body>
    <h1>Заголовок</h1>
    <p>Некоторый текст</p>
  </body>
</html>
```

**DOM-структура:**
```
- document
  - html
    - head
      - title
    - body
      - h1
      - p
```

### Основные узлы DOM:

1. **Элементы (Element Nodes)** — это элементы HTML, такие как `<div>`, `<h1>`, `<p>`, `<img>` и так далее. Эти узлы содержат теги и их атрибуты.
   
2. **Текстовые узлы (Text Nodes)** — это текст внутри HTML-элементов. Например, текст "Заголовок" внутри тега `<h1>` является текстовым узлом.

3. **Атрибуты (Attributes Nodes)** — это узлы, представляющие атрибуты элементов, такие как `class`, `id`, `src`.

4. **Документ (Document Node)** — это самый верхний узел, представляющий весь документ. Он является родительским узлом для элемента `<html>`.

### Как работает DOM?

1. **Интерактивность**: Когда страница загружается, браузер строит DOM из HTML-кода. JavaScript может изменять этот DOM, что позволяет странице быть динамической.
   
2. **Манипуляция DOM**: С помощью JavaScript ты можешь:
   - **Изменять структуру DOM** (добавлять/удалять элементы),
   - **Обновлять текст и атрибуты** (например, менять текст заголовка или ссылку изображения),
   - **Реагировать на события** (например, клики или нажатия клавиш).

### Пример манипуляции DOM с помощью JavaScript:

```html
<!DOCTYPE html>
<html>
  <body>
    <h1 id="myTitle">Заголовок</h1>
    <button onclick="changeTitle()">Изменить заголовок</button>

    <script>
      function changeTitle() {
        document.getElementById("myTitle").textContent = "Новый заголовок";
      }
    </script>
  </body>
</html>
```

**Что происходит:**
- Мы используем JavaScript для доступа к элементу с `id="myTitle"` и меняем его текст при нажатии на кнопку. Браузер обновляет DOM, и заголовок меняется.

### DOM и React

React работает с DOM, но делает это через **виртуальный DOM**, как мы обсуждали ранее. Это улучшает производительность, так как React не обновляет весь DOM при каждом изменении, а только те элементы, которые действительно изменились.

### Почему DOM важен?

1. **Динамика страницы**: Взаимодействие с DOM позволяет создавать динамические, интерактивные веб-страницы. С помощью JavaScript ты можешь изменять структуру страницы на лету, что даёт гибкость и интерактивность.

2. **События**: DOM поддерживает события (например, клики, ввод текста), что позволяет отслеживать действия пользователя и реагировать на них.

3. **Кросс-браузерная совместимость**: DOM — это стандарт, поддерживаемый всеми современными браузерами. Это значит, что код, работающий с DOM, будет работать одинаково в разных браузерах (с некоторыми нюансами).

### Пример более сложной работы с DOM:

Допустим, ты хочешь добавить новый элемент в список:
```html
<ul id="myList">
  <li>Элемент 1</li>
  <li>Элемент 2</li>
</ul>

<button onclick="addItem()">Добавить элемент</button>

<script>
  function addItem() {
    const newItem = document.createElement("li");
    newItem.textContent = "Новый элемент";
    document.getElementById("myList").appendChild(newItem);
  }
</script>
```

Здесь `document.createElement()` создаёт новый элемент `<li>`, а `appendChild()` добавляет его в существующий список. Браузер автоматически обновляет страницу.

### Важно:

- **DOM работает синхронно**: Это значит, что любые изменения в DOM сразу же применяются и отображаются в браузере.
- **Обновление DOM может быть медленным**: Именно поэтому React использует виртуальный DOM, чтобы уменьшить количество обновлений реального DOM и повысить производительность.

### Заключение:

DOM — это фундаментальная часть веб-разработки, которая позволяет создавать и управлять интерфейсом приложения. Взаимодействие с DOM через JavaScript даёт возможность делать страницы интерактивными и динамичными. React и другие библиотеки упрощают этот процесс, делая работу с DOM более эффективной.

---

Продолжение: Отрисовка элемента в DOM
---

Чтобы отрисовать элемент React в корневом узле DOM, передайте его в `ReactDOM.render()`:
```js
const element = <h1>Привет, мир</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/rendering-elements/render-an-element)

На странице отобразится «Привет, мир».

## Обновление отрисованного элемента

React-элементы — [неизменяемы](https://ru.wikipedia.org/wiki/Неизменяемый_объект). Создав однажды элемент, вы не сможете изменить его дочерние элементы или атрибуты. Элемент похож на один кадр в фильме: он представляет собой пользовательский интерфейс в определённый момент времени.

Насколько известно из предыдущих разделов, единственный способ обновить интерфейс — создать новый элемент и передать его в `ReactDOM.render()`.

Рассмотрим этот пример тикающих часов:
```js
function tick() {
  const element = (
    <div>
      <h1>Привет, мир!</h1>
      <h2>Сейчас {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);
```
[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/rendering-elements/update-rendered-element)

Он вызывает каждую секунду `ReactDOM.render()` из колбэка `setInterval()`.

> ### Примечание:
>
> На практике большинство приложений React только один раз вызывают `ReactDOM.render()`. В следующих разделах мы узнаем, как такой код инкапсулируется в [компоненты с состоянием](/docs/state-and-lifecycle.html).
>
>Мы рекомендуем вам не пропускать эти темы, потому что они опираются друг на друга.

## React обновляет только то, что необходимо

DOM React сравнивает элемент и его дочерние элементы с предыдущими и применяет только обновления DOM, необходимые для преобразования DOM в желаемое состояние.

Вы можете убедиться в том, проверив [последний пример](https://ru.react.js.org/redirect-to-codepen/rendering-elements/update-rendered-element) с помощью инструментов браузера:

![react_refresh](https://ru.react.js.org/granular-dom-updates-c158617ed7cc0eac8f58330e49e48224.gif)

Несмотря на то, что мы создаём элемент, описывающий всё дерево пользовательского интерфейса на каждом тике, только текстовый узел, содержимое которого изменилось, обновляется в DOM React.

По нашему опыту, размышление о том, как пользовательский интерфейс должен выглядеть в любой данный момент, а не то, как его менять со временем, устраняет целый класс багов.

### [Назад к оглавлению](#back)


<a name="propert"></a>
# 4. Компоненты и свойства

### Компоненты позволяют разделить пользовательский интерфейс на независимые, повторно используемые части и работать с каждой из частей отдельно. На этой странице представлено введение в идею компонентов. [Здесь](https://ru.react.js.org/docs/react-component.html) вы можете найти подробный справочник API по компоненту.

Концептуально компоненты похожи на функции JavaScript. Они принимают произвольные входные данные (называемые «props» или свойствами) и возвращают React-элементы, описывающие, что должно появиться на экране.

## Функциональные и классовые компоненты

Самый простой способ определить компонент — написать JavaScript-функцию:
```js
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
```

Данная функция — корректный компонент React, потому что он принимает один аргумент-объект «props» (который обозначает свойства) с данными и возвращает элемент React. Такие компоненты мы называем «функциональными», потому что они являются буквально функциями JavaScript.

Вы также можете использовать [класс из ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes) для определения компонента:
```js
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
```

Два вышеуказанных компонента эквивалентны с точки зрения React.

У классов есть дополнительные возможности, которые мы обсудим в [следующих разделах](https://ru.react.js.org/docs/state-and-lifecycle.html). До этого момента мы будем использовать функциональные компоненты из-за их краткости.

## Отрисовка компонента

Раньше мы сталкивались только с элементами React, представляющие DOM-теги:
```js
const element = <div />;
```

Однако элементы также могут быть пользовательскими компонентами:
```js
const element = <Welcome name="Сара" />;
```

Когда React видит элемент, представляющий пользовательский компонент, он передаёт JSX-атрибуты этому компоненту в виде единственного объекта. Мы называем этот объект «props».

Например, этот код отображает «Привет, Сара» на странице:
```js
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/components-and-props/rendering-a-component)

Давайте посмотрим, что происходит в этом примере:

1. Мы вызываем `ReactDOM.render()` с элементом `<Welcome name="Сара" />`.
2. React вызывает компонент `Welcome` с объектом `{name: 'Sara'}` как `props`.
3. Наш компонент `Welcome` возвращает элемент `<h1>Hello, Sara</h1>` в качестве результата.
4. React DOM эффективно обновляет DOM, чтобы соответствовать `<h1>Hello, Sara</h1>`.

> ### Примечание: Всегда именуйте компоненты с заглавной буквы.
>
>React обрабатывает компоненты, начинающиеся со строчных букв, как DOM-теги. Например, <div /> представляет HTML-тег div, но <Welcome /> представляет компонент и требует, чтобы Welcome был в области видимости.
>
>Вы можете больше узнать о причинах, лежащих в основе этого соглашения [здесь](https://ru.react.js.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized).

## Композиция компонентов

Компоненты могут ссылаться на другие компоненты в своём выводе. Это позволяет использовать одну и ту же абстракцию компонента для любого уровня детализации. Кнопка, форма, диалоговое окно, экран: в приложениях React все они обычно являются компонентами.

Например, мы можем создать компонент `App`, который многократно отрисовывает `Welcome`:
```js
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Сара" />
      <Welcome name="Кахаль" />
      <Welcome name="Эдит" />
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
```

[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/components-and-props/composing-components)

Как правило, в новых приложениях React есть один компонент App, который находится в самом верху иерархии компонентов. Однако, если вы интегрируете React в существующее приложение, вы можете начать снизу вверх с небольшого компонента, такого как Button, и постепенно идти вверх по иерархии представлений.

## Извлечение компонентов

Не бойтесь разделять компоненты на более мелкие компоненты.

Например, рассмотрим этот компонент Comment:
```js
function Comment(props) {
  return (
    <div className="Comment">
      <div className="UserInfo">
        <img className="Avatar"
          src={props.author.avatarUrl}
          alt={props.author.name}
        />
        <div className="UserInfo-name">
          {props.author.name}
        </div>
      </div>
      <div className="Comment-text">
        {props.text}
      </div>
      <div className="Comment-date">
        {formatDate(props.date)}
      </div>
    </div>
  );
}

[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/components-and-props/extracting-components)

Он принимает `author` (объект), `text` (строка) и `date` (дата) в качестве свойств и описывает комментарий на сайте социальных сетей.

Этот компонент может быть сложно изменить из-за вложенности, а также трудно повторно использовать отдельные его части. Давайте извлечём из него несколько компонентов.

Сначала мы извлечём `Avatar`:
```js
function Avatar(props) {
  return (
    <img className="Avatar"
      src={props.user.avatarUrl}
      alt={props.user.name}
    />

  );
}
```
Компонент `Avatar` не должен знать, что он отрисовывается внутри `Comment`. Вот почему мы присвоили свойству объекта `props` более общее имя: `user`, а не `author`.

Мы рекомендуем называть свойства объекта `props` с точки зрения самого компонента, а не контекста, в котором он используется.

Теперь мы можем чуть-чуть упростить `Comment`:
```js
function Comment(props) {
  return (
    <div className="Comment">
      <div className="UserInfo">
        <Avatar user={props.author} />
        <div className="UserInfo-name">
          {props.author.name}
        </div>
      </div>
      <div className="Comment-text">
        {props.text}
      </div>
      <div className="Comment-date">
        {formatDate(props.date)}
      </div>
    </div>
  );
}
```
Затем мы извлечём компонент `UserInfo`, который отобразит `Avatar` рядом с именем пользователя:
```js
function UserInfo(props) {
  return (
    <div className="UserInfo">
      <Avatar user={props.user} />
      <div className="UserInfo-name">
        {props.user.name}
      </div>
    </div>
  );
}
```
Это позволяет нам упростить `Comment` ещё больше:
```js
function Comment(props) {
  return (
    <div className="Comment">
      <UserInfo user={props.author} />
      <div className="Comment-text">
        {props.text}
      </div>
      <div className="Comment-date">
        {formatDate(props.date)}
      </div>
    </div>
  );
}
```
[Попробовать на CodePen](https://ru.react.js.org/redirect-to-codepen/components-and-props/extracting-components-continued)

Извлечение компонентов сначала может показаться монотонной работой, но наличие палитры повторно используемых компонентов окупается в больших приложениях. Хорошее правило на этот счёт можно сформировать так — если часть пользовательского интерфейса используется несколько раз (`Button`,`Panel`, `Avatar`) или достаточно сложна сама по себе (`App`, `FeedStory`,`Comment`), то это хороший кандидат на извлечение компонента, чтобы он стал повторно используемым компонентом.

## Свойства объекта props доступны только для чтения

Независимо от того, объявляете ли компонент как [функцию или класс](https://ru.react.js.org/docs/components-and-props.html#functional-and-class-components), он не должен изменять свои свойства. Рассмотрим эту функцию sum:
```js
function sum(a, b) {
  return a + b;
}
```
Такие функции называются [«чистыми»](https://ru.wikipedia.org/wiki/Чистота_функции), потому что они не пытаются изменить свои аргументы и всегда возвращают один и тот же результат для одних и тех же входных данных.

Напротив, функция ниже — не чистая, потому что она изменяет свои входные данные:
```js
function withdraw(account, amount) {
  account.total -= amount;
}
```
React довольно гибкий, но имеет одно строгое правило:

### Все React-компоненты должны вести себя как чистые функции в плане своих свойств.

Конечно, пользовательские интерфейсы приложений динамичны и меняются со временем. В [следующем разделе](https://ru.react.js.org/docs/state-and-lifecycle.html) мы представим новую концепцию «состояние». Состояние позволяет компонентам React изменять свой вывод с течением времени в ответ на действия пользователя, сетевые ответы и что-либо ещё без нарушения правила выше.

### [Назад к оглавлению](#back)


<a name="current"></a>
# 5. Свойство (состояние) и жизненный цикл

### На этой странице представлена концепция состояния и жизненного цикла в компоненте React. [Здесь](https://ru.react.js.org/docs/react-component.html) вы можете найти подробный справочник API компонента.

Рассмотрим пример тикающих часов из одного из предыдущих разделов. В разделе Отрисовка элементов мы изучили только один способ обновления пользовательского интерфейса (UI). Мы вызываем ReactDOM.render() для изменения отрисованного вывода:
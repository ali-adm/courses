# Всё что нужно знать о Docker

## [Оглавление:](#оглавление)

### [Установка Docker скриптом](#установка-docker-скриптом-1)
### [Начальная настройка Docker](#начальная-настройка-docker-ubuntu)
### [Основные команды Docker](#основные-команды-docker)
### [Port mapping – проброс портов контейнера]
### [Environment variables - Переменные среды]
### [Docker Volumes Постоянные данные]
### [Docker Networks Сетевые настройки]
### [Dockerfile Файл докера
### Docker Compose. Докер Компос]
### [Очистка и сброс Docker Compose]
### [Portainer. Управление Docker в графическом режиме]


---
# Docker с 0 до 100%. Всё, что нужно знать.
### [Источник youtube](https://youtu.be/O8N1lvkIjig)
---

**! Огромное количество готовых контейнеров** - хранятся на https://hub.docker.com (докерхабе). 

### **Docker** — это платформа, которая позволяет упаковать в контейнер приложение со всем окружением и зависимостями, а затем доставить и запустить его в целевой системе. Работает на Linux, Windows и MacOS. Установка и настройка приведена для Ubuntu 20.04 LTE. Команды Docker работают в docker терминале одинаково в любой из перечисленных ОС.


## **Установка Docker скриптом**

Скачать скрипт:
```bash
curl -fsSL https://get.docker.com -o get-docker.sh 	# -o — указание файла, в который сохраняется загруженный скрипт.
```

Узнать, какие шаги скрипт выполнит при вызове (опция --dry-run):
```bash
sudo sh ./get-docker.sh --dry-run 		# необязательно.
```

Запустить скрипт:
```bash
sudo sh ./get-docker.sh 	# ./ — указание на то, что файл находится в текущей директории
```

Проверить версию Docker:
```bash
docker --version 
```

Проверка версии Docker Compose:
```bash
docker compose --version 	# Docker Compose должен установиться вместе с Docker.
```

[Назад к оглавлению](#оглавление)


## **Начальная настройка Docker (Ubuntu)**

Добавить пользователя в группу docker, дать права использования docker (без sudo):
```bash
usermod -aG docker <имя пользователя>
```

Создать еще одного пользователя:
```bash
useradd -m -s /bin/bash <пользователь>
```

Добавить нового пользователя в группу докер:
```bash
usermod -aG docker <пользователь>
```

Проверить появилась ли у пользователя группа docker:
```bash
id <пользователь> 
```

Переключиться на пользователя:
```bash
su - <пользователь>
```

[Назад к оглавлению](#оглавление)


## **Основные команды Docker**

Проверка статуса Docker:
```bash
service docker status
```

Посмотреть запущенные контейнеры (processes status):
```bash
docker ps
```

Вывод **docker ps** построчный, и иногда не помещается в одну строку, поэтому можно использовать более компактный и настраиваемый вывод этой команды:
```bash
docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Image}}"
```

Полный вид этой команды:
```bash
docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Command}}}\t{{.Ports}}\t{{.Networks}}\t{{.Mounts}}\t{{.Image}}"
```

Посмотреть все контейнеры (запущенные плюс остановленные):
```bash
docker ps -a
```

Удаление контейнера:
```bash
docker rm <имя, id, неск. уникальных знаков из id>
```

Просмотр имеющихся образов:
```bash
docker images
```

Удаление образа:
```bash
docker rmi <id образа>
```

Скачать образ из репозитория:
```bash
docker pull <image>
```

Создать контейнер и запустить образ с командой с параметром:
```bash
docker run <image> <команда> <параметр>
docker run ubuntu sleep 5
```

Запустить образ с командой с параметром:
```bash
docker start <image> <команда> <параметр>
docker start ubuntu sleep 5
```

Создать контейнер и запустить образ с тегом*, командой и аргументом:
```bash
docker run:<tag> <команда> <параметр>
docker run ubuntu:20.04 echo “Hello Docker!”
docker run -d --rm --name Ubuntu20 ubuntu:20.04 sleep 900
```

> **Тег** - как правило версия, или модификация
>> Команда запустит контейнер работающий в фоновом режиме **(-d)** 15 минут **(sleep 900)**, с **тегом** 20.04, c именем “Ubuntu20” **(--name)**. После остановки контейнер будет удален **(--rm)**.

Поставить контейнер на паузу:
```bash
Docker pause <имя, id, неск. уникальных знаков из id>
```

Запустить контейнер с паузы:
```bash
docker unpause <имя, id, неск. уникальных знаков из id>
```

Остановить контейнер:
```bash
docker stop <имя, id, неск. уникальных знаков из id>
```

Убить процесс контейнера:
```bash
docker kill <имя, id, неск. уникальных знаков из id>
```

Просмотр информации о контейнере:
```bash
docker inspect <имя, id, неск. уникальных знаков из id>
```

Просмотр потребляемых контейнером ресурсов:
```bash
docker stats <имя, id, неск. уникальных знаков из id>
```

Просмотр логов контейнера:
```bash
docker logs <имя, id, неск. уникальных знаков из id>
docker logs -f nginx
```

> Параметр **-f (--follow)** позволяет получить обновляемый лог в режиме реального времени; Параметр **--tail N** позволяет получить последние **N** строк лога.

Зайти внутрь контейнера:
```bash
docker exec -it <имя, id, неск. уникальных знаков из id> </bin/bash>
```

Полностью все удалить (очистка всех неиспользуемых ресурсов - остановленные контейнеры и образы)
```bash
docker system prune -a --volumes
```
> Параметр **--volumes** удаляет тома. Команда в данном виде, при условии что все контейнеры остановлены - удаляет всё наверняка!

```docker system df```  # Проверка использования диска
> Колонка **RECLAIMABLE** в выводе команды — указывает на объем дискового пространства, который может быть освобожден путем удаления ненужных данных. Это включает в себя неиспользуемые образы и тома, остановленные контейнеры.

`docker system prune`  # Удаление неиспользуемых данных  
`docker image prune`  # Удаление неиспользуемых образов  
`docker volume prune`  # Удаление неиспользуемых томов  
`docker container prune`  # Удаление остановленных контейнеров

Очистка файла журнала контейнера:
```bash
truncate -s 0 $(docker inspect --format='{{.LogPath}}' <container_name_or_id>)
```
Эта команда состоит из двух:  
Нахождение пути к файлу журнала —

```bash
docker container inspect  --format='{{.LogPath}}' <container_name_or_id>
```

В результате будет получен путь к файлу журнала. Сокращение файла журнала:
```bash
truncate -s 0 /path/to/logfile
```
> **-s** используется для установки размера файла. При ноле (0) в качестве входных данных, происходит полное усечение файла журнала.Таким образом можно не полностью очищать журнал контейнера, а сокращать его до заданного размера.

Сокращение до ноля (0) размера всех контейнеров в системе:
```bash
truncate -s 0 /var/lib/docker/containers/*/*-json.log
```

[Назад к оглавлению](#оглавление)


## **Port mapping – проброс портов контейнера**

```bash
docker run -p <порт_сервера>:<порт_контейнера> <имя_образа>
```
Например:
```bash
docker run -d --name web80 -p 80:80 nginx
```

Портов может быть много. Пример установки **Adguard-Home**:
```bash
docker run --name adguardhome\
    --restart unless-stopped\
    -v /my/own/workdir:/opt/adguardhome/work\
    -v /my/own/confdir:/opt/adguardhome/conf\
    -p 53:53/tcp -p 53:53/udp\
    -p 67:67/udp -p 68:68/udp\
    -p 80:80/tcp -p 443:443/tcp -p 443:443/udp -p 3000:3000/tcp\
    -p 853:853/tcp\
    -p 784:784/udp -p 853:853/udp -p 8853:8853/udp\
    -p 5443:5443/tcp -p 5443:5443/udp\
    -d adguard/adguardhome
```

```bash
docker run -P <имя образа>
```

От параметра **--publish-all** — автоматически будут назначены порты со стороны сервера, со стороны контейнера будут назначены порты, прописанные в директиве **EXPOSE** в **dockerfile** (См. ниже [dockerfile](#dockerfile---файл-докера)).

Узанть проброшенные порты можно командой:
```bash
docker ps
```

*Не рекомендуется использовать в продакшене*. Для большего контроля портов, в проде - рекомендуется параметр `-p <порт_сервера>:<порт_контейнера>`.

[Назад к оглавлению](#оглавление)


## **Environment variables - Переменные среды** 

При запуске **Docker**, можно передавать *переменные окружения*, путем добавления параметра `-e`.  

Переменные окружения – хранятся в ОС, и в Линуксе их можно посмотреть с помощью команды `env` (добавить переменную из линукс можно командой `export <переменная>`).  

На примере запуска контейнера Mysql:
```bash
docker run --name mysqlDB -e MYSQL_ROOT_PASSWORD=my-secret-pswd -d mysql
```

Здесь переменной является пароль **root**, заданный параметром — `-e MYSQL_ROOT_PASSWORD=my-secret-pswd`  

Если после запуска в ОС использовать команду `env` — то можно увидеть появившуюся переменную `MYSQL_ROOT_PASSWORD=my-secret-pswd`. 

Далее можно проверить:
```bash
docker exec -it mysqlDB mysql -uroot -p
Ввод пароля my-secret-pswd
mysql>
```

Список переменных, используемых в контейнерах, можно посмотреть на странице продукта на **hub.docker.com**, либо на официальной странице продукта. Переменные окружения будут работать не все, а лишь те, которые будут указаны в вышеупомянутых источниках.

[Назад к оглавлению](#оглавление)


## **Docker Volumes - Постоянные данные**
либо **Persisting Data - Сохраняющиеся данные**

**Docker** имеет три способа сохранять данные.

**Host volumes:** Пространства на физическом хосте. Позволяет монтировать директории физического сервера, хоста — в выбранную директорию в контейнере
```bash
docker run -v <слева/путь/на/сервере>:<справа/путь/в/контейнере> <образ>
```

Например:
```bash
docker run -v /opt/mysql_data:/var/lib/mysql mysql
docker run -v /opt/app_conf:/etc/app/configs app
```
После остановки и удаления контейнера, данные в пространстве **host volumes - остаются**.

**Anonymous volumes:** Анонимное пространство — в команде не указывается путь к пространству на физическом сервере. Docker создает его (анонимное пространство) сам. 

```bash
docker run -v </путь/в/контейнере> <образ>
```

Например:
```bash
docker run -v /var/lib/mysql mysql
docker run -v /etc/app/configs app
```

На самом деле Docker создает пространство, предварительно его хэшируя по адресу `var/lib/docker/volumes/HASH/_data`

```bash
Docker run -v /var/lib/mysql mysql => var/lib/docker/volumes/HASH/_data
Docker run -v /etc/app/configs app => var/lib/docker/volumes/HASH/_data
```

После удаления контейнера — **удаляется хэш и директория пространства anonymous volumes** контейнера. 

> **ВАЖНО:** при удалении контейнера, анонимное пространство вместе с данными — удаляются вместе с ним!

**Named volumes:** Именные пространства монтируются на физическом хосте там же, где и анонимные пространства, только с именем. В команде указывается произвольное имя, по которому будет называться его смонтированный на хосте каталог.

```bash
Docker run -v <произвольное имя>:</путь/в/контейнере> <образ>
```

Например:
```bash
Docker run -v mysql_data:/var/lib/mysql mysql => var/lib/docker/volumes/mysql_data/_data
Docker run -v app_conf:/etc/app/configs app => var/lib/docker/volumes/app_conf/_data
```

После остановки и удаления контейнера, **данные в пространстве named volumes остаются и находятся в вышеуказанном месте**.

Посмотреть имеющиеся пространства (тома):
```bash
docker volume ls
```

Удалить том:
```bash
docker volume rm <имя пространства>
docker volume rm mysql_data
```

[Назад к оглавлению](#оглавление)


## **Docker Networks - Сетевые настройки**

> Данный раздел подразумевает базовое знание основ сетей и стека их протоколов

В Docker используется несколько способов использования сети:

**Bridge** — сетевой мост, имеющий адрес сети `172.17.0.0/16`, на физическом хосте он представлен интерфейсом `docker0`.   
Тип сети по умолчанию, задействуется при использовании команд `docker run` и `start`.   
Чтобы попасть на контейнер извне — создается сетевой мост с помощью параметра `-p` — порт, после которого через пробел записываются номера портов, сначала порт со стороны извне и за ним порт со стороны контейнера, (см. [Port Mapping](#port-mapping--проброс-портов-контейнера) выше).

**Host** — контейнер работает на *IP-адресе физического сервера* (имеет тот же адрес, что и хост), используя различные порты.   
В команде задействуется параметром `--network=host`. Другими словами, в сетевом смысле, контейнер устанавливается на сам хост. Все интерфейсы сетей на хосте и в контейнере - одинаковы.

**None** — без сети. В данном случае контейнер *не имеет IP-адреса*, и попасть в этот контейнер по сети невозможно. 
Соответственно доступ в контейнер осуществляется только с помощью команд Docker.   
Такой вариант работы контейнера возможен с помощью параметра `--network=none`.

**MacVLAN** — создает виртуальные сетевые интерфейсы с *уникальными MAC-адресами* для каждого контейнера. Эти интерфейсы могут вести себя, как физические сетевые интерфейсы, и быть видимыми в физической сети.   
Поддерживает режимы работы 
- **"bridge"** (по умолчанию), который создает *виртуальные интерфейсы* внутри сети хоста, и 
- **"passthru"**, который позволяет контейнерам использовать *физический MAC-адрес* хоста.

**IPVLAN** —  создает *виртуальные сетевые интерфейсы с уникальными MAC-адресами* для каждого контейнера, также предоставляет уникальные IP-адреса в рамках подсети, создавая виртуальные интерфейсы с уникальными IP-адресами для каждого контейнера.   
Поддерживает только режим **“bridge”**, также поддерживает *несколько IP адресов на одном интерфейсе*.

Можно создавать *произвольное* количество сетей в пространстве `172.17.0.0/16`, в этих сетях создавать *произвольное* количество контейнеров, с ограниченным размерами сети количеством IP адресов. 

Контейнеры могут взаимодействовать только внутри своей сети по IP адресам *и именам!* 

>В нативной сети **bridge** — взаимодействие по именам не работает! 

Имя контейнера задается параметром `--name` при создании контейнера, если этот параметр не указан — контейнер получает случайное имя.   
Взаимодействие контейнеров, находящихся в разных сетях — по умолчанию, без маршрутизации невозможно! Создание сетей при использовании второго **(host)** или третьего способа **(none)** — невозможно!

```bash
docker network create -d bridge --subnet 192.166.10.0/24 --gateway 192.166.10.1 <имя создаваемой сети>
```
Команда выше, позволяет создать (`create`) сеть (`network`) вида сетевого моста — **bridge** `(--drive`, `-d`), с параметрами самой сети - ее размера (`--subnet`), гейта (`--gateway`) и имени сети.

---
Предположим, есть физический интерфейс с IP адресом `192.168.1.2` и подсетью `192.168.1.0/24`. Рассмотрим использование **macvlan** и **ipvlan**:

**Использование macvlan:**

```bash
docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 macvlan_net
docker run --network=macvlan_net -itd --name=container1 alpine
docker run --network=macvlan_net -itd --name=container2 alpine
```

**Использование ipvlan:**

```bash
docker network create -d ipvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 ipvlan_net
docker run --network=ipvlan_net -itd --name=container1 alpine
docker run --network=ipvlan_net -itd --name=container2 alpine
```

> **alpine** — минимальный образ Docker на базе Alpine Linux с полным индексом пакетов и размером **5 мб**.

`container1` и `container2` будут иметь *уникальные MAC-адреса* и могут взаимодействовать с физическим интерфейсом в сети `192.168.1.0/24`. 

`-o parent=eth0` — указывает родительский сетевой интерфейс.

Параметры `-itd`:
- `-i` (или `--interactive`) - создает интерактивное соединение, позволяя вам взаимодействовать с командной строкой контейнера. Этот флаг часто используется с `-t`.
- `-t` (или `--tty`) - ассоциирует ваш терминал с терминалом внутри контейнера. Это обеспечивает корректное отображение управляющих символов, что особенно полезно для интерактивных команд.
- `-d` (или `--detach`) - запускает контейнер в фоновом режиме (**detached mode**), то есть контейнер будет работать в фоновом режиме, и управление терминалом вернется вам. Это полезно для запуска контейнеров в фоне, когда вам не требуется интерактивное взаимодействие.

```bash
docker network create --subnet=172.18.0.0/16 --ip-range=172.18.0.0/24 my_custom_network
```

`--subnet=172.18.0.0/16` - указывает подсеть для сети. Все контейнеры, подключенные к этой сети, будут иметь IP-адреса из этой подсети.

`--ip-range=172.18.0.0/24` - указывает диапазон IP-адресов в пределах выбранной подсети, который может быть использован для назначения IP-адресов контейнерам. В данном случае, адреса будут в пределах от `172.18.0.0` до `172.18.0.255`. 

`--ip-range=172.18.0.1/32` — созданному в этой сети контейнеру будет присвоен адрес `172.18.0.1` — это может быть прокси или гейт.

```bash
docker run --network=my_custom_network --ip=172.18.0.5 -d my_container
```

`--network=my_custom_network` - указывает, к какой сети подключить контейнер;

`--ip=172.18.0.5` - явно указывает IP-адрес, который должен быть назначен контейнеру. Здесь `172.18.0.5` - это адрес из диапазона, который определен для сети `my_custom_network`. 

---

### **Ключевые различия режимов:**

**Типы режимов:**

- **macvlan:** поддерживает режимы **"bridge"** и **"passthru"**.   
Режим **"passthru"** позволяет использовать *физический MAC-адрес* хоста.
- **ipvlan:** поддерживает только режим **"bridge"**.

**Особенности конфигурации:**

- **macvlan:** может требовать *более сложной конфигурации*, особенно при использовании режима **"passthru"**.
- **ipvlan:** часто требует меньше конфигурации и может быть *проще в использовании*.

**Множественные IP адреса:**

- **macvlan:** может использовать *один IP адрес* на один виртуальный интерфейс.
- **ipvlan:** может использовать *множество IP-адресов* на одном виртуальном интерфейсе.
  
### **Несколько интерфейсов:**

В *стандартной конфигурации* Docker, контейнер обычно имеет только *один сетевой интерфейс*. Этот интерфейс подключен к сети, указанной при создании или запуске контейнера. Однако, в некоторых случаях, и с использованием дополнительных инструментов, можно настроить контейнер *с несколькими сетевыми интерфейсами*.

#### Примеры использования нескольких сетевых интерфейсов в Docker-контейнере:

Создание Docker-сети с несколькими подсетями, что позволит контейнеру иметь несколько сетевых интерфейсов:
```bash
docker network create my_multi_interface_network --subnet=172.18.0.0/24 --subnet=172.19.0.0/24
```

При запуске контейнера можно подключить его к нескольким сетевым интерфейсам, указав имя каждой сети:
```bash
docker run --network=my_multi_interface_network --network=my_other_network -d my_container
```

Можно настроить сетевые интерфейсы внутри контейнера, используя инструменты `ip` и `ipconfig`
```bash
docker exec -it my_container /bin/bash
ip link add link eth0 name eth1 type macvlan mode bridge
ip link set dev eth1 up
```

> Нужно обратить внимание, что использование нескольких сетевых интерфейсов в контейнере может потребовать дополнительной конфигурации внутри контейнера и на хосте. Это также может вносить сложности в управлении и поддержке.

Узнать информацию о сети:
```bash
docker network inspect <имя сети, либо ID>
```

Вывести список имеющихся сетей:
```bash
docker network ls
```

Добавить сеть в контейнер, даже если контейнер уже принадлежит к какой-то сети, команда *именно добавит сеть к уже имеющимся* в контейнере:
```bash
docker network connect <имя сети> <имя контейнера>
```

Удалить сеть из контейнера, или удалить из сети контейнер, что одно и тоже:
```bash
docker network disconnect <ID сети*> <имя контейнера>
* ID сети можно посмотреть с помощью команда inspect (см выше).
```

[Назад к оглавлению](#оглавление)


## **Dockerfile - Файл докера**

**Dockerfile** состоит из следующих компонентов:

- Базовый образ (Image):
```bash
FORM <образ базового имиджа, например Ubuntu 22.04>
FORM ubuntu:22.04
```

> См. Основные команды — Тэг

- Описание образа:
```bash 
LABEL author=<информация об авторе>  		# Эту информацию можно потом будет посмотреть при помощи docker inspect
LABEL author=aliadm 
```

- Команды, которые будут исполнены после старта:
```bash
RUN apt-get update
RUN apt-get install nginx -y
```

- Рабочие директории:
```bash
WORKDIR <путь к рабочей папке в контейнере>
WORKDIR /var/www/html/
```

- Файлы (работа с файлами, находящимися на хосте):
```bash
COPY <путь к файлу для копирования на физическом хосте> <путь в контейнере, куда буедт скопирован файл>
COPY MyProject/scripts/MyScript.sh /apt/script.sh 	# Копировать файл script.sh
COPY MyProject/files/index.html . 	# Копировать файл index.html в рабочую директорию, точка через пробел - см. ниже
RUN chmod +x /apt/script.sh 	# Разрешить исполнение файла script.sh
```

- Указание переменных **Environment variable** (по умолчанию при запуске контейнера, потом их можно изменять):
```bash 
ENV OWNER=”aliadm” 	# Указание владельца
ENV TYPE=demo 	# Указание типа
```

> См. Переменые среды — параметр `-e`

- Порты:
```bash
EXPOSE 80 	# Открытый из контейнера наружу порт; команда несет информационный контекст
```

- Описание команд при запуске контейнера:
```bash
ENTRYPOINT [“echo”] 	# Команду после этой инструкции - нельзя перезаписать указанием команды при запуске контейнера.
CMD [“Рад приветствовать почтенную публику!”] 	# Команда после этой инструкции является как-бы по умолчанию, и ее можно переписать указанием команды при запуске контейнера.
```

- Запуск dockerfile:
```bash
docker build . 
```

> Точка через пробел в конце команды означает что нужно делать **build** с докерфайлом, лежащим в той же директороии, откуда запускается команда.

После билда могут появляться контейнеры следующего вида:

```bash
docker images  
REPOSITORY   TAG         IMAGE ID      CREATED   SIZE
<none>       <none>      <image id>    <date>   <size>
```

Задать репозиторий и тэг контейнеру:
```bash
docker tag <image id> mydocker:v1
```

Получается:
```bash
docker images
REPOSITORY       TAG         IMAGE ID      CREATED   SIZE
<mydocker>       <v1>        <image id>    <date>    <size>
```
Запуск dockerfile с указанием имени:
```bash
Docker build -t <mydocker:v1> . 	# -t - тэг
```

Пример dockerfile для запуска nginx:
```bash
FROM ubuntu:22.04
LABEL autor=aliadm
RUN apt-get update
RUN apt-get install nginx -y
EXPOSE 80/tcp
EXPOSE 443/tcp
CMD ["nginx","-g","daemon off;"] 	# Параметры CMD - указаны в докерхабе.
```

Пример dockerfile для запуска apache:
```bash
FROM ubuntu:22.04
LABEL autor=aliadm
RUN apt-get update
RUN apt-get install nginx -y
EXPOSE 80/tcp
EXPOSE 443/tcp
CMD ["apache2ctl","-D","FOREGROUND"] 	# Параметры CMD - указаны в докерхабе.
```
Пример dockerfile для запуска сайта
```bash
FROM ubuntu:22.04
LABEL autor=aliadm
RUN apt-get update
RUN apt-get install nginx -y 
RUN apt-get clean && rm -rf /var/lib/apt/lists/*
WORKDIR /var/www/html/ 	# Рабочая директория, при docker exec -it — попдает сюда (по умолчанию - попадает в корень /); /var/www/html/  - рабочая директория nginx
COPY <Путь к файлу на хосте> . 	# Точка после пробела сообщает о том, что файлы будут копироваться в рабочую директорию 
ENV  OWNER=aliadm 	# Переменная окружения, данные будут исп по умолчанию. См. Часть 5. Environment variables
ENV TYPE=demo
EXPOSE 80/tcp
EXPOSE 443/tcp
CMD ["apache2ctl","-D","FOREGROUND"] 
```

Пример докера на PHP:

Содержимое файла index.php
```php
<?php
phpinfo();
phpinfo(INFO_MODULES);
?>
```

Содержимое dockerfile:
```bash
FROM php:7.2-apache
COPY index.php /var/www/html/ 	# Подразумевается что index.php лежит в одном каталоге с dockerfile, иначе нужно указывать путь до файла index.php
```

Команда для билда контейнера:
```bash
docker build -t myphp:v1 .
```

Команда для запуска контейнера:
```bash
docker run -d --rm --name myphpdocker -p 80:80 myphp:v1
```

В браузере по адресу `http://localhost` либо `http://<IP-адрес хоста>` — отображается информация о PHP 

Пример контейнера с питоном (сумма двух чисел):

Содержимое sum.py:
```py
num1 = input('Enter first number: ')
num2 = input('Enter second number: ')
sum = float(num1) + float(num2)
print('The sum of {0} and {1} is {2}'.format(num1, num2, sum))
```

Содержание dockerfile:
```bash
FROM python:3
WORKDIR /usr/src/app
COPY sum.py ./
CMD [ "python", "./sum.py" ]
```

Билд контейнера:
```bash
docker build -t mypython:v1 .
```

Запуск контейнера:
```bash
docker run -it --rm mypython:v1
```

Работа контейнера: 
```bash
Enter first number: 
```

[Назад к оглавлению](#оглавление)


## **Docker Compose. Докер Компос**

- Используется для управления одним, или несколькими контейнерами;
- Содержит инструкции по запуску контейнеров (команды cli прописываются в файл)
- Упрощает автоматизацию контейнеров (не нужно запоминать параметры запуска)
- Описывается в YAML файле (как правило это docker-compose.yml)

### **Установка Docker Compose в Ubuntu:**

### Добавление Docker apt репозитория:

Добавление официального GPG ключа Docker:
```bash
sudo apt-get update
sudo apt-get install ca-certificates curl gnupg
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg
```

Добавление репозитория в Apt источники:
```bash
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
```

Установка Docker Compose:
```bash
sudo apt-get install docker-compose-plugin
```

Проверка версии Docker Compose:
```bash
docker-compose --version
```

новый вид записи:
```bash
docker compose version
```

Сложная команда CLI для запуска контейнера:
```bash
docker run --name web-server \ 	# 1 имя отображаемое в процессах - ps
-v /opt/web/html:/var/www/html/ \ 	# 2 присоединенное пространство см. Docker volumes
-v /opt/web/pics:/var/www/pictures \
-e NGINX_HOST=web.aliadm.kg \ 	# 3 Указание переменных среды см. Environment variables
-e NGINX_PORT=80 \
-d \ 	# 7 Detached mode - запуск в фоновом режиме
-p 80:80 \ 	# 4 Указание рабочих портов, см. Docker networking
-p 443:443 \ 	
-net webnet \ 	# 5 Указание рабочей сети, см. Docker networking
nginx:stable  	# 6 Указание образа и тега, см. Тэги
```

YAML файл для описания этой команды:
```yaml
version: “3.5”
services:
    web-server: 
        image: nginx:stable 	# 6 Указание образа и тега, см. Тэг
        container_name: web-server 	# 1 имя отображаемое в процессах - ps
        volumes: 		# 2 присоединенное пространство см. Docker volumes
            — /opt/web/html:/var/www/html/ 	# Host volumes 
            — /opt/web/pics:/var/www/pictures/ 	# Директории в /opt создаются сами
            — nginx-config:/var/www/config 	# Named volumes
        environment:
            — NGINX_HOST=web.aliadm.kg 	# 3 Указание Environment variables
            — NGINX_PORT=80 
        ports: 	# 4 Указание рабочих портов, см. Docker networking
            — “80:80”
            — “443:443”
        restart: unless-stopped 		# always/no/on-failure - параметры определения поведения контейнера в случае его аварийного завершения.

networks: 	# 5 Указание рабочей сети, (блок из того-же YAML файла)
    default:
        driver: bridge
        name: webnet
```

### Стратегии поведения контейнера:

**restart: unless-stopped** — контейнер будет всегда перезапускаться, если его остановили явно (с помощью docker stop). Но не будет перезапускаться после неудачного завершения, из-за внутренней ошибки, или при использовании docker kill. (После перезагрузки хоста, контейнер если был запущен — будет перезапущен, если был в остановленном состоянии, то так и останется остановленным).

**restart: on-failure** — контейнер будет перезапущен только в случае завершения с ошибкой (ненулевой код завершения).

**restart: always** — контейнер будет всегда перезапускаться, даже если он завершится успешно, без ошибок.

**restart: no** — контейнер не будет автоматически перезапускаться.

---

Чтобы запустить Docker Compose, нужно в месте нахождения файла `docker-compose.yml` запустить команду:
```bash
docker-compose up -d 	# 7 -d - Detached mode - запуск в фоновом режиме
```

либо новый вид записи:
```bash
docker compose up -d 	# 7 -d - Detached mode - запуск в фоновом режиме
```
Остановка Docker Compose:
```bash
docker compose stop
```

Вывод логов контейнеров в реальном времени:
```bash
docker compose logs -f
```

Переименование файла `docker-compose.yaml`

Файл `docker-compose.yaml` для удобства можно переименовывать. Только тогда для его запуска нужно использовать команду:
```bash
docker-compose -f my-custom-name.yml up
```

Можно использовать это другое имя файла по умолчанию (чтобы каждый раз не указывать `-f` с именем файла), для этого нужно изменить переменную окружения `COMPOSE_FILE`. Чтобы использовать файл с именем `my-docker-compose.yml` по умолчанию, нужно выполнить:
```bash
export COMPOSE_FILE=my-docker-compose.yml
```

Перевод docker compose --help:
```bash
Использование: docker compose [OPTIONS] COMMAND

Определение и запуск многоконтейнерных приложений с помощью Docker.

Опции:
  	--ansi string — Указывает, когда печатать управляющие символы ANSI ("never" (никогда) | "always" (всегда) | "auto" (авто)) (по умолчанию "auto")
  	--compatibility — Запуск compose в режиме обратной совместимости
  	--dry-run — Выполнение команды в режиме сухого выполнения
  	--env-file stringArray — Укажите альтернативный файл окружения.
  -f,       --file stringArray — Создание конфигурационных файлов.
  	--parallel int — Управление максимальным параллелизмом, -1 для неограниченного (по умолчанию -1)
  	--profile stringArray — Укажите профиль для включения
  	--progress string — Установка типа вывода прогресса (auto, tty, plain, quiet) (по умолчанию "auto")
  	--project-directory string — Укажите альтернативный рабочий каталог (по умолчанию: путь к первому указанному файлу Compose)
  -p,      --project-name string — Имя проекта

Команды:
  build — Построить или перестроить сервисы
  config — Разбор, разрешение и отображение файла compose в каноническом формате
  cp — Копирование файлов/папок между контейнером сервиса и локальной файловой системой
  create — Создает контейнеры для сервиса.
  down — Остановка и удаление контейнеров, сетей
  events — Получение событий реального времени от контейнеров.
  exec — Выполнение команды в запущенном контейнере.
  images — Список образов, используемых созданными контейнерами.
  kill — Принудительная остановка контейнеров службы.
  logs — Просмотр вывода данных из контейнеров.
  ls — Список запущенных проектов compose
  pause — Приостановить работу служб
  port — Вывести публичный порт для привязки портов.
  ps — Список контейнеров
  pull — Вытащить образы сервисов
  push — Выталкивать образы сервисов
  restart — Перезапуск контейнеров служб
  rm — Удаляет остановленные контейнеры сервисов
  run — Выполнить одноразовую команду на сервисе.
  start — Запуск служб
  stop — Остановить службы
  top — Отображение запущенных процессов
  unpause — Отключить службы
  up — Создание и запуск контейнеров
  version — Показать информацию о версии Docker Compose
  wait — Блокировать до тех пор, пока не остановится первый контейнер с сервисами.

Выполните команду 'docker compose COMMAND --help' для получения дополнительной информации о команде.
```

[Назад к оглавлению](#оглавление)


### Пример управления несколькими контейнерами:

В нижеприведенном примере файла `docker-compose.yml` описывается инфраструктура состоящая из трех контейнеров: 
- веб приложения на php `(php-app)`, 
- базы данных на postgress `(app-db)` и 
- реализации кэша на redis `(app-redis)`. 

`php-app` зависит от двух других контейнеров, и не сможет работать или запуститься без них. Поэтому в описании `php-app` имеется параметр `depends_on` - который предписывает контейнеру `php-app` запускаться только после запуска `app-db` и `app-redis`. 

Так-же имеются две сети: 
- одна для внутренних взаимодействий между приложением, базой данных и кэшем — бэкэнд `(localnet)`, 
- и сеть для взаимодействия приложения с пользователями  — фронтэнд `(internet)`. 
```yaml
version: '3.6'
services:
  php-app:
    image: php:apache
    container_name: app
    ports:
      - '80:80'
    restart: unless-stopped
    depends_on:
      - app-db
      - app-redis
    networks:
      - internet
      - localnet

  app-db:
    image: postgres
    container_name: app-postgres
    restart: unless-stopped
    environment:
      - 'POSTGRES_PASSWORD=P@ssword'
    networks:
      - localnet

  app-redis:
    image: redis
    container_name: app-redis
    restart: unless-stopped
    networks:
      - localnet

networks:
  internet:
    name: internet
    driver: bridge
  localnet:
    name: localnet
    driver: bridge
```

[Назад к оглавлению](#оглавление)


## Практичные примеры:

### Пример запуска Nextcloud:

Данная инсталляция приведена для примера. Для установки **Nextcloud** в продуктовую среду рекомендуется перейти на страницу Nextcloud в **Докерхаб**:
[https://hub.docker.com/_/nextcloud](https://hub.docker.com/_/nextcloud)
и ознакомиться с более гибкими вариантами и параметрами установки и настройки Nextcloud для более безопасной и более быстрой работы движка.

`docker-compose.yml`:
```yaml
version: '3.5'
services:
  db:
    image: mariadb:10.5
    restart: always
    command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW
    volumes:
      - db:/var/lib/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=P@ssw0rd
      - MYSQL_PASSWORD=P@ssw0rd
      - MYSQL_DATABASE=nextcloud
      - MYSQL_USER=nextcloud

  app:
    image: nextcloud
    restart: always
    ports:
      - 80:80
    volumes:
      - nextcloud:/var/www/html
    environment:
      - MYSQL_PASSWORD=P@ssw0rd
      - MYSQL_DATABASE=nextcloud
      - MYSQL_USER=nextcloud
      - MYSQL_HOST=db

volumes:
  nextcloud:
  db:
```
Далее в браузере нужно открыть окно приветствия Nextcloud по адресу `localhost` или по адресу сервера, на котором установлен запущен контейнер, и приступить к его настройке.


[Назад к оглавлению](#оглавление)

### Пример запуска Wordpress:

Данная инсталляция также приведена для примера. Для установки **Wordpress** в продуктовую среду рекомендуется перейти на страницу Wordpress в **Докерхаб**:
[https://hub.docker.com/_/wordpress](https://hub.docker.com/_/wordpress), и ознакомиться с более гибкими вариантами и параметрами установки и настройки Wordpress для более безопасной и более быстрой работы движка.

`docker-compose.yml`:
```yaml
version: '3.5'
services:
  wordpress:
    image: wordpress
    restart: always
    ports:
      - 80:80
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: user
      WORDPRESS_DB_PASSWORD: P@ssw0rd
      WORDPRESS_DB_NAME: wordpress
    volumes:
      - wordpress:/var/www/html

  db:
    image: mysql:5.7
    restart: always
    environment:
      MYSQL_DATABASE: wordpress
      MYSQL_USER: user
      MYSQL_PASSWORD: P@ssw0rd
      MYSQL_ROOT_PASSWORD: rootP@ssw0rd
    volumes:
      - db:/var/lib/mysql

volumes:
  wordpress:
  db: 
```

В браузере, по адресу `localhost` или по адресу хоста, на котором запущен контейнер нужно открыть окно приветствия WordPress, и приступить к его настройке.


[Назад к оглавлению](#оглавление)

## **Очистка и сброс Docker Compose**

Со временем, при развертывании многоконтейнерных приложений — накапливаются неиспользуемые контейнеры, анонимные тома, зависшие образы и кэш, которые занимают значительное место на диске. 

Основными причинами очистки **Docker Compose** могут являться: 

- **Рост заполненности хранилища** — если контейнер не настроен должным образом, он может расширяться до тех пор, пока не заполнит всю доступную емкость диска на хосте; 
- **Восстановление начального состояния** — при отладке или тестировании нового кода или приложений появляется мусор, а тестируемая среда исключает устаревшие артефакты. Очистка обеспечивает начальные условия.
- **Очистка скопившегося беспорядка** — зависшие образы, потерянные тома, неиспользуемые сети и устаревшие контейнеры загромождают Docker и систему. Очистка устраняет сложность.
- **Освобождение ресурсов** — остановленные контейнеры, кэшированные образы и неиспользуемые тома и сети тратят память, отнимают ресурсы процессора и диска. Очистка позволяет перераспределить ресурсы для критических рабочих процессов.
- **Полная очистка** — позволяет избавится от остатков старого приложения, начать с нуля перед развертыванием основной версии.

Перед запуском очистки **Docker Compose** необходимо провести несколько "предполетных" проверок:

- **Резервное копирование томов данных** — необходимо скопировать важные данные контейнера во внешнее хранилище перед удалением томов, т.к. возможна случайная потеря данных.
- **Остановка зависимых служб** — если запущенные службы зависят от контейнеров, перед очисткой их необходимо отключить.
- **Проверка предполагаемого объема очистки** — необходимо внимательно проверить что будет удалено перед каждым шагом удаления, понять последствия.
- **Проверка использования диска** — нужно проверить выходные данные docker system df и docker volume ls перед удалением образов и томов.
- **Тэгирование артефактов** — желательно отметить образы, контейнеры и тома специальными тегами для более легкого целенаправленного удаления. Не нужно полагаться на идентификаторы.

#### Шаг 1. Останов и удаление контейнеров:

Останов и удаление контейнеров, определенных в `docker-compose.yml`
```bash
docker-compose down
```

Удаление контейнеров по их ID:
```bash
docker rm $(docker ps -aq)
```
В `docker ps -aq` перечислены все идентификаторы контейнеров, которые передаются в `docker rm` для удаления, при этом удаляются не только контейнеры **compose**, но и все остальные *остановленные* контейнеры.

Для выборочного удаления — можно перечислить имена контейнеров:
```bash
docker rm $(docker ps -aqf name=web_container)
```

#### Шаг 2. Удаление  сетей:

Проверка сетей для безопасной очистки:
```bash
docker network ls
```

Удаление всех сетей, которые *не используются* существующими контейнерами:
```bash
docker network rm $(docker network ls -q) 
```

#### Шаг 3. Удаление томов Docker:

Проверка использованного места:
```bash
docker volume ls
```

Удаление ВСЕХ именнованных и анонимных томов Docker. 
> ВНИМАНИЕ: это приведет к удалению данных приложений и баз данных, если не будут созданы резервные копии!
```bash
docker volume rm $(docker volume ls -q)
```

Можно также использовать следующие подходы:

Удаление безымянных томов:
```bash
docker volume prune
```

Удаление тома по имени:
```bash
docker volume rm my-data
```

Также при создании тома, можно *ограничить* его по размеру. Это следует делать разумно, т.к. тома содержат ценные данные.

#### Шаг 4. Удаление образов контейнеров:

Удаление ВСЕХ образов — нужно соблюдать осторожность, чтобы не удалить нужные контейнеры
```bash
docker image rm $(docker image ls -aq)
```

Для выборочного удаления образов можно использовать удаление по *тегу* или 
```bash
docker image rm image:tag
docker image rm image_id
```

Также можно использовать:

Удаление только кэша сборки `(--build)`:
```bash
docker builder prune
```

Удаления завизсших `(dangling)` образов без тегов:
```bash
docker image prune
```

Можно использовать политики переназначения тэгов образов, чтобы избежать устаревших артефактов и мониторинг для обнаружения быстрого роста заполнения  дисков.

#### Шаг 5. Очистка системы:

После удаления контейнеров, сетей, томов и образов, нужно удалить все другие неиспользуемые артефакты:
```bash
docker system prune
```

Это позволит:
- Удалить остановленные контейнеры
- Удалить зависшие образы
- Удалить неиспользуемые сети
- Удалить кэш сборки

#### Шаг 6. Удаление проекта Compose:

На этом этапе **Docker** чист. Для полного сброса следует удалить каталог проекта **Compose**, содержащий `docker-compose.yml`. Затем можно восстановить развертывание **Docker Compose** из заведомо исправного состояния с помощью системы управления версиями **Git** или шаблонов Compose. Это гарантирует очистку от мусора и артефактов.

Аккуратное развертывание **Docker Compose** повышает производительность и стабильность. Чтобы тщательно очистить и перезагрузить среды Docker Compose нужно следовать предложенным выше советам. 

Резюмируя, можно кратко еще раз обозначить **основные правила очистки и сброса Docker Compose**:

- **Разумное удаление данных** — создание и использование резервных копий томов, проверка их наличия перед удалением.
- **Удаление артефактов по отдельности** — детализация контейнеров, томов и изображений.
- **Понимание последствий очистки и общее понимание ситуации** — представление что будет удалено и к чему это приведет перед каждым шагом очистки.
- **Регулярная очистка** — планирование периодических очисток, для ограничения роста использования диска.
- **Полная очистка** — для обеспечения согласованности в среде Docker Compose нужна периодическая очистка и пересборка ее с нуля.
- **Наведение порядка** — удаление остановленных контейнеров, зависших образов и неиспользуемых томов.

[Назад к оглавлению](#оглавление)


## **Portainer. Управление Docker в графическом режиме**

Требования:

**Ubuntu 22.04 LTE** с установленным **Docker** и **Docker Compose**. 

Страница с мануалом установки:

https://docs.portainer.io/start/install-ce 	

Данная ссылка ведет на установку версии **Portainer Community Edition**, для установки  **Business Edition** - нужно убрать часть `-ce`.

Есть различные варианты установки. В данном примере использована простая одиночная установка на убунту бесплатной версии - Community Edition. Основой служит команда установки:
```bash
docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
```
Для удобства создается `docker-compose.yml`:
```yaml
version: '3.3'
services:
  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    environment:
      - TZ=Asia/Bishkek 	# Установка временной зоны TimeZone
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock 	# Важный параметр. Необходимо смонтировать сокеты докера именно в таком виде, иначе Portainer не сможет работать с Docker.
      - /home/aliadm/docker/portainer/portainer_data:/data 	# В отличии от приведенной выше команды docker и для удобства переноса portainer на другой хост, здесь, для хранения настроек portainer используется не именной каталог, а смонтированный в удобное место.
    ports:
      - '8000:8000'
      - '9443:9443'
    restart: always
```

Запуск Portainer:
```bash
docker compose up -d
```

### Настройка Portainer:

В браузере по адресу `https://localhost:9443` или `https://<ip хоста>:9443` производится настройка Portainer. Для настройки нужно:

- Задать пароль admin’a из 12 символов. Далее пароль можно изменить в настройках пользователя. 
- Снять или оставить галочку “Allow collection of anonymous statistics” для отправления анонимной статистики.
- Далее интерфейс интуитивно понятен и не отличается от типовых подобных интерфейсов UX/UI, и позволяет стандартные функции, некоторые из которых доступны только в платной **Business Edition** версии, однако для базовых операций - функциональности вполне хватает в бесплатной **Community Edition**.
- Интерес представляют шаблоны **(templates)** стандартных базовых контейнеров, находящиеся в **local/App Templates**. Здесь представлены: 
  - стандартный **Docker Image Registry** и контейнер для кэширования **Registry** - на случай создания своего, **частного реестра docker**.  
  - базовый **Ubuntu**, 
  - платформа **NodeJS**, 
  - три **вэб-сервера**, 
  - различные **базы данных**, 
  - **вэб движки** и т.д. 
  - Так-же имеются стэки контейнеров, например **WordPress** c **MySQL**.

---

### Пример создания контейнера **Nginx** из шаблона:
- Выбрать **Nginx** из списка, 
- в открывшемся шаблоне дать контейнеру **имя**, 
- указать **сеть**, 
- выбрать **способы управления** контейнером - только администраторами, или предоставить управление определенным пользователям и группам польователей.
- Далее нажав **deploy** - можно развернуть контейнер с *настройками по умолчанию*.

Контейнер будет развернут с **настройками по умолчанию**, однако можно его пока не разворачивать, а продолжить **настройку более тонких параметров**:
- Нажав **Show advanced options** - продолжить настраивать дополнительные параметры:
  - Настроить **Port** и **Volume Mapping** - см. описание выше. 
  - Добавить записи в файл `/etc/hosts` — **Hosts file entries**. (Используется для соответствия IP-адресов именам хостов в операционной системе. В контексте Docker, это может быть полезным для настройки разрешения имен хостов внутри контейнера, например, если нужно сделать несколько контейнеров в сети доступными друг для друга по именам хостов, а не только по IP-адресам.)
  - Добавить метки **Add label** — метаданные к Docker-объектам, таким как образы, контейнеры, сети и тома.  
- **Метки** могут использоваться: 
  - **для группировки и классификации контейнеров**, например среда выполнения (production, development), роль сервиса и т.д.  
  - **в сценариях автоматизации**, например, для автоматической масштабируемости или управления жизненным циклом контейнера
  - **могут служить документацией к контейнеру**, предоставляя информацию о версии, авторе, цели использования и других характеристиках.
- Задать **hostname** контейнера, в одноименном поле. 
  - Параметр используется для установки **имени хоста** (`hostname`) внутри контейнера. Имя хоста представляет собой идентификатор машины в сети и может быть использовано в различных сценариях для идентификации самого контейнера и взаимодействия с другими узлами в сети. 
  - Может быть использовано для обращения к самому себе, кроме того, значение **hostname** может быть *динамически устанавливаемым*, что полезно, например, при автоматизации создания и запуска контейнеров.
- Далее нужно нажать **Deploy the container** для создания контейнера.

---

Создание любого докер объекта, будь то **контейнер**, **сеть** или **том volume** не используя шаблоны - интуитивно просто и понятно в интерфейсе: 
- Для начала нужно перейти на **вкладку требуемой сущности** — выбрав из меню сущностей справа. 
- Далее, после нажатия кнопки **"Добавить сущность"**, например **"Add Container"** — заполнить необходимые поля ввода требуемой информацией. 
- Добавлять или не добавлять различные параметры. 
- По завершении настройки — нажать **кнопку деплоя сущности (Deploy)**.

В процессе использования **Portainer** - очень удобно использовать **Стеки - Stacks**, которые являются ничем иным как **Docker Compose** файлами. Они остаются статичными, позволяют содержать параметры сразу нескольких контейнеров в одном файле. 

**Portainer** предлагает четыре вида создания **Стека**: 
- **Web editor** — создание или копипаста **Docker Compose файла** в редакторе. 
- **Upload** — загрузка **Docker Compose файла** с компьютера пользователя. 
- **Repository** — загрузка **Docker Compose файла** из своего или любого репозитория. При включенной функции автоматического обновления **(Automatic Updates)** — удобно использовать для автоматизации,  но требует повышенного внимания при изменении оригинального **Docker Compose файла** в репозитории. 
- **Custom template** — использование шаблона. 

### Пример деплоя блог - платформы Ghost посредством Стека:

- Нужно зайти в меню **Stacks** и нажать **Add stack**. 
- Далее после создания **имени** будущего стека — нужно выбрать один из методов создания стека. 
- При выборе варианта **Web editor** — нужно перейти на страницу репозитория **Ghost**:   
[https://hub.docker.com/_/ghost](https://hub.docker.com/_/ghost) 
- Найти содержание **файла Docker Compose** для **Ghost**. 
- Путем копипасты перенести это содержание в открывшемся в **Portainer** окне редактора **Web editor**:
```yaml
version: '3.1'

services:

  ghost:
    image: ghost:5-alpine
    restart: always
    ports:
      - 8081:2368
    environment:
      # see https://ghost.org/docs/config/#configuration-options
      database__client: mysql
      database__connection__host: db
      database__connection__user: root
      database__connection__password: example
      database__connection__database: ghost
      # this url value is just an example, and is likely wrong for your environment!
      url: http://192.168.1.240:2368
    # contrary to the default mentioned in the linked documentation, this image defaults to NODE_ENV=production (so development mode needs to be explicitly specified if desired)
      #NODE_ENV: development
    volumes:
      - ghost:/var/lib/ghost/content

  db:
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: example
    volumes:
      - db:/var/lib/mysql

volumes:
  ghost:
  db:
```

- Далее нужно отредактировать некоторые параметры - **порт** со стороны хоста, **переменные окружения**, **тома volumes** в нужную для себя сторону, и нажать кнопку **деплоя**. 
- Подождать пока скачаются образы, создадутся контейнеры, развертывается база данных. 
- Далее можно в браузере переходить на настроенный ранее (редактирование портов) адрес. 
- **Ghost** установлен и работает.

> **Совет:** в **Portainer** лучше всего для работы использовать **Стеки - Stacks**.

### Подключение других серверов с Docker: 

Для удобства управления **Docker** инфраструктурой, в  **Portainer** есть возможность добавлять другие сервера входящие в инфраструктуру, с установленной технологией Docker. 

Для этого нужно перейти в меню окружающей среды **Environments**, нажать **Add environment** и выбрать один из многих способов подключения.

### Пример подключения сервера через Portainer Agent:
- Нужно выбрать способ **Docker Standalone**, 
- далее нажать **Start Wizard**, 
- в окне ниже **скопировать команду**, которую нужно запустить на подключаемом сервере, и которая устанавливает **агента**. 
- Установить на подключаемом сервере **агента**, путем запуска скопированной прежде команды. 
- Узнать **IP-адрес** сервера, **порт**, который настраивается как один из параметров вышеописанной команды установки агента. 
- Далее можно проверить работу **агента** путем вызова списка запущенных контейнеров — `docker ps`. **Portainer_agent** — должен быть запущен.
- В окне подключения сервера через **Portainer Agent** — дать имя подключаемому серверу и указать выше обозначенные **IP-адрес** и **порт** для подключения, который настраивается как один из аргументов команды запуска агента. 
- Далее остается нажать кнопку для запуска соединения **Connect**, и в **дашборде "Home"** - можно увидеть подключенный сервер со всей Docker инфраструктурой присутствующей на нем. 

Управление инфраструктурой удаленного сервера происходит аналогично управлению в вышеописанной панели управления **Home/local** — локального хоста.

Подключенные серверы можно объединять я группы или под общими тегами — что еще более упрощает управление Docker инфраструктурой.

Одно из преимуществ **Portainer** состоит в том, что его устанавливать и использовать все его удобства и возможности - можно гораздо позже начала существования Docker инфраструктуры. Другими словами, для всей полноты использования функционала **Portainer**, нет условия его использования с самого старта инфраструктуры, его можно подключить в любой момент ее существования, без каких-либо ограничений, которые могли бы возникнуть. 

**Portainer** управляет уже созданными до его появления контейнерами без каких-либо ограничений.

В общем - в Portainer’e, нужно понять всего одно его условие: для тех кто знает командную строку докера - разобраться в Portainer’e будет не сложно. Но не наоборот! Поэтому если вдруг, дорогой читатель решил кушать пиццу с середины - то См выше с самого начала. В любом знании важен фундамент. :) 


[Назад к оглавлению](#оглавление)

---

# **PS:** Небольшой справочник по командам Docker
> Прим. перев.: Aymen El Amri, руководящий компанией eralabs и создавший обучающий курс «Безболезненный Docker», опубликовал свой Docker Cheat Sheet — шпаргалку по основным командам Docker. Git-репозиторий этого документа на GitHub уже набрал 1000+ stars и несколько сторонних контрибьюторов, что подтвердило его актуальность и пользу.

Представленные здесь команды описаны минимально (с акцентом на читаемость как есть) и включают в себя установку Docker, работу с реестрами и репозиториями, контейнерами, образами, сетью, Docker Swarm. Ниже представлен перевод шпаргалки в её состоянии на 2 сентября 2023 года, с дополнениями из комментариев ниже.

## Установка Docker
Linux
```bash
curl -sSL https://get.docker.com/ | sh
```

Mac  
Скачайте dmg по этой ссылке:
```bash
https://download.docker.com/mac/stable/Docker.dmg
```

Windows  
Используйте MSI-инсталлятор:
```bash
https://download.docker.com/win/stable/InstallDocker.msi
```

[Назад к оглавлению](#оглавление)


## Реестры и репозитории Docker
Вход в реестр
```bash
docker login
docker login localhost:8080
```
Выход из реестра
```bash
docker logout
docker logout localhost:8080
```

Поиск образа
```bash
docker search nginx
docker search nginx -- filter stars=3 --no-trunc busybox
```

Pull (выгрузка из реестра) образа
```bash
docker pull nginx
docker pull eon01/nginx localhost:5000/myadmin/nginx
```

Push (загрузка в реестр) образа
```bash
docker push eon01/nginx
docker push eon01/nginx localhost:5000/myadmin/nginx
```


[Назад к оглавлению](#оглавление)

## Первые действия с контейнерами

Создание контейнера
```bash
docker create -t -i eon01/infinite --name infinite
```

Первый запуск контейнера
```bash
docker run -it --name infinite -d eon01/infinite
```

Переименование контейнера
```bash
docker rename infinite infinity
```

Удаление контейнера
```bash
docker rm infinite
```

Обновление контейнера
```bash
docker update --cpu-shares 512 -m 300M infinite
```


[Назад к оглавлению](#оглавление)

## Запуск и остановка контейнеров
Запуск остановленного контейнера
```bash
docker start nginx
```

Остановка
```bash
docker stop nginx
```

Перезагрузка
```bash
docker restart nginx
```

Пауза (приостановка всех процессов контейнера)
```bash
docker pause nginx
```

Снятие паузы
```bash
docker unpause nginx
```

Блокировка (до остановки контейнера)
```bash
docker wait nginx
```

Отправка SIGKILL (завершающего сигнала)
```bash
docker kill nginx
```

Отправка другого сигнала
```bash
docker kill -s HUP nginx
```

Подключение к существующему контейнеру
```bash
docker attach nginx
```

[Назад к оглавлению](#оглавление)


## Получение информации о контейнерах
Работающие контейнеры
```bash
docker ps
docker ps -a
```

Логи контейнера
```bash
docker logs infinite
```

Информация о контейнере
```bash
docker inspect infinite
docker inspect --format '{{ .NetworkSettings.IPAddress }}' $(docker ps -q)
```

События контейнера
```bash
docker events infinite
```

Публичные порты
```bash
docker port infinite
```

Выполняющиеся процессы
```bash
docker top infinite
```

Использование ресурсов
```bash
docker stats infinite
```

Изменения в файлах или директориях файловой системы контейнера
```bash
docker diff infinite
```


[Назад к оглавлению](#оглавление)

## Управление образами
Список образов
```bash
docker images
```

Создание образов
```bash
docker build .
docker build github.com/creack/docker-firefox
docker build - < Dockerfile
docker build - < context.tar.gz
docker build -t eon/infinite .
docker build -f myOtherDockerfile .
curl example.com/remote/Dockerfile | docker build -f - .
```

Удаление образа
```bash
docker rmi nginx
```

Загрузка репозитория в tar (из файла или стандартного ввода)
```bash
docker load < ubuntu.tar.gz
docker load --input ubuntu.tar
```

Сохранение образа в tar-архив
```bash
docker save busybox > ubuntu.tar
```

Просмотр истории образа
```bash
docker history
```

Создание образа из контейнера
```bash
docker commit nginx
```

Тегирование образа
```bash
docker tag nginx eon01/nginx
```

Push (загрузка в реестр) образа
```bash
docker push eon01/nginx
```


[Назад к оглавлению](#оглавление)

## Сеть
Создание сети
```bash
docker network create -d overlay MyOverlayNetwork
docker network create -d bridge MyBridgeNetwork
docker network create -d overlay \
  --subnet=192.168.0.0/16 \
  --subnet=192.170.0.0/16 \
  --gateway=192.168.0.100 \
  --gateway=192.170.0.100 \
  --ip-range=192.168.1.0/24 \
  --aux-address="my-router=192.168.1.5" --aux-address="my-switch=192.168.1.6" \
  --aux-address="my-printer=192.170.1.5" --aux-address="my-nas=192.170.1.6" \
  MyOverlayNetwork
```

Удаление сети
```bash
docker network rm MyOverlayNetwork
```

Список сетей
```bash
docker network ls
```

Получение информации о сети
```bash
docker network inspect MyOverlayNetwork
```

Подключение работающего контейнера к сети
```bash
docker network connect MyOverlayNetwork nginx
```

Подключение контейнера к сети при его запуске
```bash
docker run -it -d --network=MyOverlayNetwork nginx
```

Отключение контейнера от сети
```bash
docker network disconnect MyOverlayNetwork nginx
```


[Назад к оглавлению](#оглавление)

## Очистка Docker
Удаление работающего контейнера
```bash
docker rm nginx
```

Удаление контейнера и его тома (volume)
```bash
docker rm -v nginx
```

Удаление всех контейнеров со статусом exited
```bash
docker rm $(docker ps -a -f status=exited -q)
```

Удаление всех остановленных контейнеров
```bash
docker container prune
docker rm `docker ps -a -q`
```

Удаление контейнеров, остановленных более суток назад
```bash
docker container prune --filter "until=24h"
```

Удаление образа
```bash
docker rmi nginx
```

Удаление неиспользуемых (dangling) образов
```bash
docker image prune
docker rmi $(docker images -f dangling=true -q)
```

Удаление неиспользуемых (dangling) образов даже с тегами
```bash
docker image prune -a
```

Удаление всех образов
```bash
docker rmi $(docker images -a -q)
```

Удаление всех образов без тегов
```bash
docker rmi -f $(docker images | grep "^<none>" | awk "{print $3}")
```

Остановка и удаление всех контейнеров
```bash
docker stop $(docker ps -a -q) && docker rm $(docker ps -a -q)
```

Удаление неиспользуемых (dangling) томов

```bash
docker volume prune
docker volume rm $(docker volume ls -f dangling=true -q)
```

Удаление неиспользуемых (dangling) томов по фильтру
```bash
docker volume prune --filter "label!=keep"
```

Удаление неиспользуемых сетей
```bash
docker network prune
```

Удаление всех неиспользуемых объектов
```bash
docker system prune
```

По умолчанию для Docker 17.06.1+ тома не удаляются. Чтобы удалились и они тоже:
```bash
docker system prune --volumes
```


[Назад к оглавлению](#оглавление)

## Docker Swarm
Установка Docker Swarm
```bash
curl -ssl https://get.docker.com | bash
```

> Прим. перев.: в Docker версий 1.12.0+ ничего дополнительно устанавливать не требуется, т.к. Docker Swarm встроен в Docker Engine в виде специального режима (Swarm mode).

Инициализация Swarm
```bash
docker swarm init --advertise-addr 192.168.10.1
```

Подключение рабочего узла (worker) к Swarm
```bash
docker swarm join-token worker
```

Подключение управляющего узла (manager) к Swarm
```bash
docker swarm join-token manager
```

Список сервисов
```bash
docker service ls
```

Список узлов
```bash
docker node ls
```

Создание сервиса
```bash
docker service create --name vote -p 8080:80 instavote/vote
```

Список заданий Swarm
```bash
docker service ps
```

Масштабирование сервиса
```bash
docker service scale vote=3
```

Обновление сервиса
```bash
docker service update --image instavote/vote:movies vote
docker service update --force --update-parallelism 1 --update-delay 30s nginx
docker service update --update-parallelism 5--update-delay 2s --image instavote/vote:indent vote
docker service update --limit-cpu 2 nginx
docker service update --replicas=5 nginx
```

> P.S.
Прим. перев.: Напомню, что оригинальная (англоязычная) версия Docker Cheat Sheet доступна и обновляется в Git-репозитории (https://github.com/eon01/DockerCheatSheet). Автор будет рад исправлениям/пополнениям от сообщества.

[Назад к оглавлению](#оглавление)


## Упражнения. 
Автор проводит тренинги и внутреннее обучение в командах. Обычно рекомендуются такие упражнения:

**Установите Docker** на рабочий компьютер.  
  
Возьмите готовый **Docker image** с **Docker Hub** с **базой данных** и запустите на его основе контейнер. Это можно сделать по инструкции, которую производитель **image** выкладывает на **Docker Hub**. Затем подключитесь к запущенной БД каким-нибудь клиентом и убедитесь, что всё работает.  

Напишите простенький сервис **REST API** и **Docker-файл** для упаковки сервиса в образ, подглядывая в референсы или книгу. Ваша задача — *разобраться в теории, получить **Docker image** и проставить теги*.

Из полученного ранее образа **создайте** и **запустите контейнер**. Вам придётся разобраться с: 
- параметрами команды **Docker run**, 
- настройками портов, 
- передачей переменных окружению, 
- монтированием и основными параметрами. 
- Также стоит научиться подключаться к контейнеру, 
- выполнять **bash-команды** и смотреть логи приложения.

Усложните тестовый сервис, научив его работать с базой данных. Затем разверните контейнеры с сервисом и базой данных и соедините их внутренней сетью. Простое и в то же время очень полезное упражнение, на котором **очень часто возникают затруднения на собеседованиях**.

Переходим к **Docker Compose**. Посмотрите, как написать **YAML** и создать *группу контейнеров*, как соединять их в сеть и работать с маунтами.

**Опубликуйте** свой **Docker image** в **Docker Hub**.  
На одном аккаунте можно бесплатно публиковать только один образ, но есть **GitLab**, где *нет таких ограничений*. Правда, он устроен немного сложнее, новичок может запутаться. Ещё в том же **GitLab** можно создать *приватный registry-режим* и публиковать проекты **без ограничений**.

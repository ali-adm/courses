## Оглавление:

- [Оглавление:](#оглавление)
- [Настройка Git на сервере Ubuntu](#настройка-git-на-сервере-ubuntu)
- [Как переключить локальный каталог с одного удаленного репозитория на другой](#как-переключить-локальный-каталог-с-одного-удаленного-репозитория-на-другой)
- [Как добавить ветку в существующий репозиторий](#как-добавить-ветку-в-существующий-репозиторий)
- [Как заменить содержимое удаленного репозитория, содержимым из локального](#как-заменить-содержимое-удаленного-репозитория-содержимым-из-локального)
- [Удаление комита из оригинального репозитория](#удаление-комита-из-оригинального-репозитория)
- [Восстановление данных после использвания --force](#восстановление-данных-после-использвания---force)
  - [Способ 1. Проверка истории коммитов](#способ-1-проверка-истории-коммитов)
  - [Способ 2. Изучение .git объекта](#способ-2-изучение-git-объекта)
  - [Способ 3. Поиск на GitHub](#способ-3-поиск-на-github)
  - [Примечание](#примечание)
- [Действия при HEAD detached (после восстановления данных Способ 1)](#действия-при-head-detached-после-восстановления-данных-способ-1)
  - [Восстановление из состояния detached HEAD](#восстановление-из-состояния-detached-head)
  - [Альтернатива (если ты нацелился на main):](#альтернатива-если-ты-нацелился-на-main)
- [Просто запушить текущее состояние в удалённую ветку (после восстановления данных Способ 1)](#просто-запушить-текущее-состояние-в-удалённую-ветку-после-восстановления-данных-способ-1)


## Настройка Git на сервере Ubuntu

1. Создать или скопировать SSH-ключи на сервер, если ты хочешь использовать SSH для подключения к GitHub.
2. Добавить SSH-ключ в аккаунт на GitHub.

Шаги:

1. **Проверь, есть ли SSH-ключи на сервере**:
   ```bash
   ls ~/.ssh
   ```
   Если там нет ключей, создай их:
   ```bash
   ssh-keygen -t ed25519 -C "your_email@example.com"
   ```

2. **Проверь права доступа:**  
   Если ты скопировал ключи, необходимо задать права доступа к ним:
   ```bash 
   chmod 600 ~/.ssh/id_ed25519
   chmod 644 ~/.ssh/id_ed25519.pub
   ```
   
   Если ключи есть, проверь права доступа:
   ```bash
   ls -l ~/.ssh/
   ```

   Должно получиться:
   ```bash
   -rw------- 1 aliadm aliadm 411 Apr 25  2024 id_ed25519
   -rw-r--r-- 1 aliadm aliadm 103 Apr 25  2024 id_ed25519.pub
   ```

3. **Добавь SSH-ключ в агент**:
   ```bash
   eval "$(ssh-agent -s)"
   ssh-add ~/.ssh/id_ed25519
   ```

4. **Скопируй публичный ключ**:
   ```bash
   cat ~/.ssh/id_ed25519.pub
   ```
   И добавь его в GitHub в разделе Settings → SSH and GPG keys.

5. **Если репозиторий уже инициализирован**:   
   выполни команду для смены удалённого URL на SSH:
    ```bash
    git remote set-url origin git@github.com:ali-adm/chatbot-ui.git
    ```

6. **Если Git-репозиторий не был инициализирован**:   
   можно это сделать с помощью:
    ```bash
    git init
    git remote add origin git@github.com:ali-adm/chatbot-ui.git
    ```

7. **Проверь соединение с GitHub**:
   ```bash
   ssh -T git@github.com
   ```

8. **Убедись, что remote настроен на SSH, а не HTTPS**:
   ```bash
   git remote set-url origin git@github.com:ali-adm/chatbot-ui.git
   ```
9.  **Текущая ветка main не имеет вышестоящей ветки**:  
    Чтобы отправить текущую ветку и установить внешнюю ветку как вышестоящую для этой ветки, используй
   ```bash
   git push --set-upstream origin main
   ```
   Либо просто
   ```bash
   git push -u origin main
   ```
10. **Если появится сообщение**  
    о том, что нужно слить внешние изменения, и `git pull` - не работает используй сначала
   ```bash
   git pull --set-upstream origin main
   ```
   Затем используй команды из предыдущего пункта.

Теперь ты сможешь пушить изменения на GitHub через SSH.

[Назад к оглавлению](#оглавление)


## Как переключить локальный каталог с одного удаленного репозитория на другой

Чтобы сменить удалённый репозиторий на свой, сделай следующее:

1. **Посмотреть текущие удалённые репозитории**:
   ```bash
   git remote -v
   ```

2. **Удалить старый удалённый репозиторий**:
   ```bash
   git remote remove origin
   ```

3. **Добавить свой репозиторий**:
   ```bash
   git remote add origin https://github.com/yourusername/your-repo.git
   ```

4. **Либо переключи remote на SSH, а не HTTPS**:
   ```bash
   git remote set-url origin git@github.com:yourusername/your-repo.git
   ```

5. **Теперь пушь изменения в свой репозиторий**:
   ```bash
   git push -u origin main
   ```
   Замените `main` на нужную ветку.

6. Если появится сообщение о том, что нужно слить внешние изменения, и `git pull` - yне работает используй сначала
   ```bash
   git pull --set-upstream origin main
   ```
   Затем используй команды из предыдущего пункта.

[Назад к оглавлению](#оглавление)


## Как добавить ветку в существующий репозиторий

Чтобы запушить изменения из ветки `legacy` на тот же репозиторий, где у тебя уже есть ветка `main` с новой версией, нужно сделать следующее:

1. Убедись, что ты работаешь в ветке `legacy`. Выполни команду:
   ```bash
   git checkout legacy
   ```

2. Добавь свой удаленный репозиторий (если ещё не добавил). Например:
   ```bash
   git remote add origin https://github.com/username/repository.git
   ```

3. Чтобы не перепутать с веткой `main`, можешь пушить ветку `legacy` под тем же именем:
   ```bash
   git push origin legacy
   ```

Если же ты хочешь обновить ветку `main` из текущей ветки `legacy`:
1. Переключись на ветку `main`:
   ```bash
   git checkout main
   ```

2. Смерджи изменения из ветки `legacy` в `main`:
   ```bash
   git merge legacy
   ```

3. После этого можешь запушить изменения в ветку `main`:
   ```bash
   git push origin main
   ```

Таким образом ты обновишь либо ветку `legacy`, либо сольешь её изменения в `main`.

[Назад к оглавлению](#оглавление)


## Как заменить содержимое удаленного репозитория, содержимым из локального

Чтобы удалить все содержимое ветки, например `legacy` в удалённом репозитории и заменить его новым содержимым из локальной ветки `legacy`, выполните следующие шаги:

1. **Переключитесь на локальную ветку `legacy`:**
   Убедитесь, что находитесь на ветке `legacy` в локальном репозитории:

   ```bash
   git checkout legacy
   ```

2. **Удалите всё содержимое из ветки `legacy` (локально):**
   Удалите все файлы и каталоги из рабочей директории:

   ```bash
   git rm -r *
   ```

   Это удалит все файлы из индекса, но оставит ветку и её историю.

3. **Добавьте новые файлы (если они есть):**
   Добавьте новые файлы или содержимое, которые нужно запушить в ветку:

   ```bash
   git add .
   ```

4. **Закоммитьте изменения:**
   Сделайте коммит, который будет содержать удаление старого и добавление нового содержимого:

   ```bash
   git commit -m "Удалено старое содержимое и добавлено новое"
   ```

5. **Запушьте изменения на удалённую ветку `legacy`:**

   Чтобы перезаписать удалённую ветку полностью, используйте опцию `--force`:

   ```bash
   git push origin legacy --force
   ```

   Важно: **Опция `--force` перезапишет историю удалённой ветки**. Убедитесь, что никто не работает с этой веткой в удалённом репозитории, чтобы избежать потери данных.

Теперь удалённая ветка `legacy` будет содержать только те данные, которые вы запушили из локальной ветки.

[Назад к оглавлению](#оглавление)


## Удаление комита из оригинального репозитория

Чтобы удалить коммит из оригинального репозитория, тебе нужно сделать следующее:

1. **Перейти в нужную ветку** (если ты не на ней):
   ```bash
   git checkout main
   ```
   (или замените `main` на имя своей ветки)

2. **Вернуться к предыдущему коммиту**:
   ```bash
   git reset --hard HEAD~1- 
   ```

3. **Сделать force push**:
   ```bash
   git push origin main --force
   ```
   Это перезапишет историю коммитов в оригинальном репозитории.

**Внимание!** Force push может перезаписать изменения, сделанные другими пользователями, так что используйте его с осторожностью.

[Назад к оглавлению](#оглавление)

## Восстановление данных после использвания --force

Если ты случайно стер локальные файлы, когда использовал `git push --force`, но до этого добавил их в коммиты и эти коммиты не были переписаны удалением или другим конфликтом, есть несколько способов их восстановить:

### Способ 1. Проверка истории коммитов

1. **Проверь историю коммитов:**

   Ты можешь просмотреть историю всех коммитов, чтобы увидеть, сохранилась ли твоя работа:

   ```bash
   git reflog
   ```

   Эта команда покажет все действия, которые ты выполнял в локальном репозитории, включая те, которые были сделаны перед `push --force`.

2. **Восстанови из предыдущего коммита:**

   Если ты видишь коммит с необходимыми изменениями, сделай `checkout` этого коммита или сбрось ветку на этот коммит:

   ```bash
   git checkout <commit_hash>
   ```

   Если нужно вернуть всю ветку к этому коммиту:

   ```bash
   git reset --hard <commit_hash>
   ```

### Способ 2. Изучение .git объекта

1. **Проверь объекты в .git:**

   Смотри в директорию `.git`, чтобы убедиться, что в ней есть `refs` и `objects`, которые могут содержать потерянные данные. Это может потребовать ручных обходов (`git fsck --full`), но это сложнее поддаётся объяснению без доступа к точным данным.

2. **Проверь использования особых команд Git для восстановления:**

   Git имеет инструменты типа `git fsck` и `git reflog` для диагностики и восстановления объектов, хотя это довольно продвинутые опции.

### Способ 3. Поиск на GitHub

1. **Проверь историю на GitHub:**

   Если ты уже пушил эти изменения в GitHub раньше, посмотри их историю изменений. Это поможет вернуть изменения, если их уже не станет в локальном репозитории.

2. **Клонируй удалённую версию:**

   Если там есть нужный коммит, ты можешь просто клонировать с удаленного репозитория и продолжить от работы с этой версии проекта.

### Примечание

Если никаких изменений не было закоммичено до `push --force`, и соответствующие изменения были потеряны из-за изменения истории репозитория, то их будет трудно восстановить. Также имей в виду, использовать `--force` безопаснее, если ты уверен, что эти изменения не затронут незакоммиченные файлы — это должна быть мера крайней необходимости.

[Назад к оглавлению](#оглавление)

## Действия при HEAD detached (после [восстановления данных Способ 1](#способ-1-проверка-истории-коммитов))

Отлично, что ты смог восстановить файлы! Сейчас твоя голова находится в состоянии `detached HEAD`. Это значит, что ты не на ветке, а на конкретном коммите. Чтобы вернуться к обычной работе и запушить изменения, тебе нужно выполнить несколько шагов:

### Восстановление из состояния detached HEAD

1. **Создай и перейди на новую ветку (если нужны старые изменения):**

   Чтобы сохранить текущее состояние, создадим новую ветку:

   ```bash
   git checkout -b восстановление
   ```

   Это создаст и переключит тебя на новую ветку с именем `восстановление`, основанную на текущем состоянии.

2. **Проверь, что ты на новой ветке:**

   Убедись, что ты на новой ветке:

   ```bash
   git branch
   ```

   Ты должен увидеть `восстановление` как активную ветку (отмечена `*`).

3. **Слияние с основной веткой (если нужно):**

   Если `main` в удалённой репозитории не обладает нужными изменениями, и ты хочешь слиять изменения:

   ```bash
   git checkout main
   git merge восстановление
   ```

4. **Запушь изменения:**

   Теперь, когда ты на `main` или на своём восстановленном изменении:

   ```bash
   git push origin main
   ```

Если всё сделано правильно, теперь твой локальный репозиторий будет синхронизирован с удалённым, отражая все восстановленные изменения.

### Альтернатива (если ты нацелился на main):

1. **Если ты уверен, что все изменения нужны в `main`:**

   ```bash
   git branch -f main 876f098  # Обновит указатель main, чтобы указывал на текущий коммит
   git checkout main
   ```

   Запушь все изменения:

   ```bash
   git push -f origin main
   ```

   *Примечание*: `-f` (`--force`) аккуратно пересматривает, если кто-то другой может быть затронут этими изменениями.

Следуя этим шагам, у тебя должны быть все изменения передачи в удаленный репозиторий на GitHub. 

[Назад к оглавлению](#оглавление)


## Просто запушить текущее состояние в удалённую ветку (после [восстановления данных Способ 1](#способ-1-проверка-истории-коммитов))

Если ты хочешь просто запушить текущее состояние в удалённую ветку `main`, тогда давай следовать этим шагам:

1. **Переключись на ветку `main`:**

   Если ты хочешь использовать текущее состояние и потерять все остальные изменения в этой ветке, ты можешь принудительно сбросить ветку `main` на текущий коммит:

   ```bash
   git checkout main  # Переключись на ветку main
   git reset --hard 876f098  # Принудительно сбрось ветку main на нужный коммит (876f098)
   ```

2. **Запушь изменения в `main`:**

   После сброса можешь запушить изменения в удалённую ветку с `--force`, так как ты изменяешь историю ветки:

   ```bash
   git push -f origin main
   ```

Эти действия принудительно обновят удалённую ветку `main` на GitHub, чтобы она соответствовала твоему локальному состоянию. Будь внимателен с `--force`, так как это действие может перезаписать историю коммитов на удалённой ветке для других пользователей.

[Назад к оглавлению](#оглавление)


## Git и Github

## Оглавление:

- [Git и Github](#git-и-github)
- [Оглавление:](#оглавление)
- [Установка Git:](#установка-git)
- [Первоначальная настройка Git](#первоначальная-настройка-git)
- [Настройка SSH ключей:](#настройка-ssh-ключей)
  - [Получение ssh-ключей](#получение-ssh-ключей)
  - [Настройка ssh config](#настройка-ssh-config)
  - [Добавление публичного ключа на GitHub](#добавление-публичного-ключа-на-github)
- [Сменить адрес удалённого репозитория](#сменить-адрес-удалённого-репозитория)
- [Создание Git-репозитория](#создание-git-репозитория)
- [Работа с Git и Github](#работа-с-git-и-github)
  - [Информация о работе с ветками](#информация-о-работе-с-ветками)
- [Работа с репозиторием](#работа-с-репозиторием)
  - [Изменение файлов репозитория](#изменение-файлов-репозитория)
  - [Сравнение репозиториев](#сравнение-репозиториев)
  - [Операции отмены](#операции-отмены)
  - [Перезапись последнего коммита](#перезапись-последнего-коммита)
  - [Отмена индексации файла](#отмена-индексации-файла)
  - [Синхронизация репозиториев](#синхронизация-репозиториев)
  - [Указатель HEAD](#указатель-head)
  - [Синхронизация репозиториев продолжение](#синхронизация-репозиториев-продолжение)
  - [Разрешение конфликтов](#разрешение-конфликтов)
  - [Продолжение работы с репозиторием](#продолжение-работы-с-репозиторием)
- [Варианты упрощения команд](#варианты-упрощения-команд)
- [Заключение](#заключение)


**Origin** — это локальное имя (псевдоним, короткое имя) для удалённого (не локального) репозитория в Git, задаваемое по умолчанию при клонировании репозитория. Это удобный способ ссылаться на URL удалённого репозитория при выполнении операций, таких как fetch, pull, и push.

Добавление нового удаленного репозитория с именем upstream, вместо origin:
```bash
git remote add upstream https://github.com/user-name/repo-name.git
```

Изменение имени с origin на new-origin:
```bash
git remote rename origin new-origin
```

Удаление удаленного репозитория:
```bash
git remote remove new-origin
```

## Установка Git:

Есть несколько способов установки Git, даже если он уже есть в системе — нужно его обновить до последней версии. 

```bash
git --version  # проверка версии Git
```
```bash
sudo dnf install git-all  # установка Git на RHEL или CentOS и др.
sudo apt install git  # установка Git на Debian, Ubuntu и др.
git --version  # установка на Mac — если Git не установлен, будет предложено установить его.
```

При установке на Windows нужно скачать дистрибутив с сайта https://git-scm.com/download/win.

Есть еще установка из исходников, но здесь она рассматриваться не будет, в интернете есть много информации по этому поводу.

[Назад к оглавлению](#оглавление)


## Первоначальная настройка Git

Git настраивается один раз. Далее, при обновлении Git — настройки сохраняются, но при необходимости, их можно поменять в любой момент, выполнив те же команды снова.

В состав Git входит утилита **git config**, которая позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git, а также его внешний вид. Эти параметры могут быть сохранены в трёх местах:

1. *Системный уровень:* файл `[path]/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске **git config** указать параметр `--system`, то параметры будут читаться и сохраняться именно в этот файл. Так как этот файл является системным, то для внесения изменений в него, потребуются права суперпользователя. 

2. *Глобальный уровень:* файл `~/.gitconfig` или `~/.config/git/config` хранит настройки текущего пользователя. Этот файл используется при указании параметра `--global` и применяется ко всем репозиториям, с которыми вы работаете в текущей системе.

3. *Локальный уровень*: файл `config` в каталоге Git (т. е. `.git/config`) репозитория, который вы используете в данный момент, хранит настройки конкретного репозитория. Читать и писать в этот файл, можно с помощью параметра `--local`, но это значение по умолчанию. Нужно находиться где-то в репозитории Git, чтобы эта опция работала правильно.

Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в `.git/config` перекрывают соответствующие значения в `[path]/etc/gitconfig`.

Чтобы посмотреть все установленные настройки и узнать где именно они заданы, используется команда:
```bash
git config --list --show-origin
```

Первое, что следует сделать после установки Git — указать имя и адрес электронной почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена в передаваемые коммиты, и не может быть далее изменена:
```bash
git config --global user.name John Doe
git config --global user.email johndoe@example.com
```

Если указана опция `--global`, то эти настройки достаточно сделать только один
раз, поскольку в этом случае Git будет использовать эти данные для всего, что делается в системе. Если для каких-то отдельных проектов нужно указать другое имя или электронную почту, можно выполнить эту же команду без параметра `--global` в каталоге с нужным проектом.

Если нужно набрать сообщение в Git, по умолчанию используется стандартный редактор системы, которым обычно является `Vim`. Если нужно использовать другой текстовый редактор, например, `Emacs`, нужно выполнить следующую команду:
```bash
git config --global core.editor emacs
```

При инициализации `git init`, по умолчанию создается ветка с именем `master`. Можно задать другое имя, для создания ветки по умолчанию:
```bash
git config --global init.defaultBranch main  # задание по умолчанию ветки main
```

Для проверки используемой конфигурации:
```bash
git config --list
```

Для получения справки, есть три способа открыть страницу руководства по любой команде Git:
```bash
git help <команда>
git <команда> --help
man git-<команда>
```

Для вывода краткой инструкции по команде можно использовать:
```bash
git <команда> -h
```

[Назад к оглавлению](#оглавление)


## Настройка SSH ключей:

- https://habr.com/ru/articles/755036/
- https://qna.habr.com/q/560765

### Получение ssh-ключей

Если уже имеется пара ключей, которые можно использовать для доступа к удалённым репозиториям, нужно убедиться, что файл с приватным ключом имеет права доступа `rw-------` и при необходимости нужно установить их командой:
```bash
chmod 600 ~/.ssh/personal_key
```

Если ещё нет пары ssh-ключей (приватного и публичного), их необходимо сгенерировать при помощи утилиты `ssh-keygen`:
```bash
ssh-keygen -t ed25519
```

Через флаг `-t` задается алгоритм, на основе которого будут сгенерированы ключи. GitHub, GitLab и Yandex рекомендуют использовать **ed25519**.

Название файла, в который будет сохранен ключ, можно оставить по умолчанию.

Далее опционально можно задать пароль на генерируемый ключ. Если это сделать — ssh будет требовать пароль при каждом использовании ключа. Чтобы не вводить пароль каждый раз, нужно настроить `ssh-agent` (https://www.ssh.com/academy/ssh/agent) — менеджер ключей для ssh.

После чего в терминал будет выведено "изображение" ключа из ASCII-символов (красивое), а в папке `~/.ssh/` появятся два файла: `id_ed25519` и `id_ed25519.pub` с **приватным** и **публичным** ключами соответственно. Для удобства работы эти файлы можно переименовать:
```bash
mv ~/.ssh/id_ed25519 ~/.ssh/personal_key
mv ~/.ssh/id_ed25519.pub ~/.ssh/personal_key.pub
```

[Назад к оглавлению](#оглавление)


### Настройка ssh config

Чтобы ssh мог автоматически использовать правильные ключи при работе с удалёнными репозиториями, необходимо настроить `~/.ssh/config`. Если его нет — то создать файл, и добавить в него следующие строки:
```bash
  Host github.com
  HostName github.com
  User git
  IdentityFile ~/.ssh/personal_key
  IdentitiesOnly yes
```

Где `gihub.com` - url сервиса, указывается одинаковым в `Host` и `HostName`; `~/.ssh/personal_key` - путь до файла с приватным ключом, который необходимо использовать для подключения. Аналогичные настройки можно произвести и для иных сервисов (например, GitLab'a), добавив соответствующие строки в файл конфигурации.

### Добавление публичного ключа на GitHub

Для того чтобы GitHub (или иной сервис) мог авторизовать подключение, необходимо указать в настройках аккаунта **публичный ssh-ключ**, который будет использоваться для доступа к репозиториям (также можно указать несколько ключей).

На **github.com** эта процедура делается следующим образом:

- `"Settings"` -> `"SSH and GPG keys"` (https://github.com/settings/keys).
- `"New SSH key"`
- В поле `"Key"` вставить содержимое файла `personal_key.pub` (либо `id_ed25519.pub`, если файлы не переименовывали).
- `"Add SSH key"`.

Во всех остальных сервисах действия будут аналогичными.

При первом подключении по ssh необходимо будет добавить github.com (либо адрес того сервиса, который используется) в список доверенных хостов:

`Are you sure you want to continue connecting (yes/no/[fingerprint])?` -> `yes`

Готово! Теперь можно использовать **SSH** для доступа к удалённым репозиторям. При использовании протокола **ssh** пути до удалённых репозиториев будут отличаться от путей, которые соответствуют протоколу **https**.

Чтобы клонировать (`git clone`) репозиторий с **GitHub** по `ssh`, нужно выбрать вкладку `SSH` в меню клонирования репозитория, после чего использовать указанный путь аналогично обычному пути по **https**.

[Назад к оглавлению](#оглавление)


## Сменить адрес удалённого репозитория

Если уже есть репозиторий, синхронизация которого с удалённым сервером происходила по протоколу **https**, а теперь нужно использовать **ssh**, необходимо сменить адрес удалённого репозитория, выполнив следующую команду в локальном репозитории:
```bash
git remote set-url branch-name git@serviceurl:user-name/repo-name.git
```

Где `serviceurl` - url сервиса, на котором находится удалённый репозиторий (github.com, gitlab.com и т.д).

Проверить, что изменения прошли корректно, можно путем выполнения команды
`git remote -v` в локальном репозитории. Если в выводе содержатся строки вида, с путями до удалённого репозитория, значит, всё сделано правильно:
```bash
branch-name   git@serviceurl:user-name/repo-name.git (fetch)
branch-name   git@serviceurl:user-name/repo-name.git (push)
```

Либо выполнить
```bash
ssh -T git@github.com
```

Если соединение успешно, появится приветственное сообщение от GitHub.

[Назад к оглавлению](#оглавление)


## Создание Git-репозитория

Получить репозиторий Git можно одним из двух способов: 

1. Можно взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git:
```bash
cd /home/user/my_project  # перейти в локальный каталог
git init  # инициация Git (создается каталог .git, содержащий все необходимые файлы репозитория — структуру Git репозитория)
git add .  # добавление всех файлов в текущем каталоге в индекс Git
git commit -m “Initial project version”  # создание коммита
```

2. Можно клонировать существующий репозиторий Git из любого места:
```bash
git clone <url>
```

при этом, Git получает копию практически всех данных, которые есть на сервере. При выполнении `git clone` с сервера забирается (`pulled`) каждая версия каждого файла из истории проекта. Фактически, если серверный диск выйдет из строя, можно использовать любой из клонов на любом из клиентов, для того, чтобы вернуть сервер в то состояние, в котором он находился в момент клонирования.

Например при использовании:
```bash
git clone https://github.com/user-name/repo-name
```

Git создает каталог `repo-name`, инициализирует в нем подкаталог `.git`, скачивает все данные для этого репозитория и извлекает рабочую копию последней версии. Для того, чтобы клонировать репозиторий в каталог с именем, отличающимся от `repo-name`, необходимо указать желаемое имя, как параметр командной строки:
```bash
git clone https://github.com/user-name/repo-name new-repo-name
```

В Git реализовано несколько транспортных протоколов:
```bash
git clone git://github.com/username/repo-name  # https
git clone git@github.com:user-name/repo-name.git  # ssh
```

[Назад к оглавлению](#оглавление)


## Работа с Git и Github

Важно понимать, что локальные ветки репозитория могут не соответствовать веткам на удаленном (дальнем)  репозитории.

Проверка своей ветки:
```bash
git branch
```

### Информация о работе с ветками

Чтобы узнать, в каком репозитории ты находишься на локальном компьютере, можно выполнить следующую команду в терминале:
```bash
git remote -v
```

Эта команда покажет привязанные удаленные репозитории для текущего проекта, включая URL-адрес репозитория на GitHub.

Проверка всех веток, включая удаленные (remote):
```bash
git branch -a
```

Эта команда выполняется после `git fetch --all` (получение данных обо всех ветках из всех удалённых репозиториев, БЕЗ внесения изменений в локальное рабочее дерево или текущую ветку). Ветки, начинающиеся с `remotes/`, например, `remotes/origin/branch-name`, являются удалёнными ветками, доступными в локальном репозитории.

Переключение на нужную ветку:
```bash
git checkout branch-name
```

Более современная и предпочтительная (позволяет избежать ошибок и разночтений) команда переключения:
```bash
git switch branch-name
```

Создание новой ветки и переключение на неё (switch — предпочтительнее):
```bash
git checkout -b new-branch
git switch -c new-branch
```

Создание новой локальной ветки, которая отслеживает удалённую ветку:
```bash
git checkout -b local-branch-name origin/remote-branch-name
```

Создание локальной ветки с тем же именем, что и у удалённой ветки, и установка ее для отслеживания изменений удалённой ветки (*отслеживание ветки* - это когда `git push` и `git pull` работают без указания имени ветки и дополнительных параметров):
```bash
git checkout --track origin/remote-branch-name
```

Переименование ветки:
```bash
git branch -m old-branch new-branch
```

Опубликование ветки (отправить локально созданную ветку в удалённый репозиторий, делая ее доступной для других):
```bash
git push repo-name branch-name
```

Отправка локальной ветки `branch-name` в удалённый репозиторий `origin` и установление отслеживания.
```bash
git push -u origin branch-name
```

Установка отслеживания между локальной веткой и удалённой (напомним, что *отслеживание ветки* - это когда `git push` и `git pull` работают без указания имени ветки и дополнительных параметров):
```bash
git push -u repo-name branch-name
git push --set-upstream repo-name branch-name
```

Установка ветки `branch-name` для отслеживания ветки `branch-name` в удалённом репозитории `origin`.
```bash
git branch -u origin/branch-name branch-name
```

Автоматическое создание локальной ветки с тем же именем, что и у удалённой ветки, и установка ее для отслеживания изменений удалённой ветки.
```bash
git checkout --track origin/remote-branch-name
```

Просмотр отслеживаемых веток:
```bash
git branch -vv
```

Удаление (в смысле стереть) локальной ветки:
```bash
git branch -d branch-name
git branch -D branch-name
```

Удаление удаленной (в смысле стереть расположенную на дальнем репозитории) ветки:
```bash
git push repo-name --delete branch-name
```

В случае удаления (стирания) ветки, нужно сначала убедиться, что ветка больше не нужна вам или вашей команде, особенно если это касается удаленных (расположенных на дальнем репозитории) веток. Так-же нужно убедиться, что все необходимые изменения из удаляемой ветви были интегрированы в другие ветки.

Удаление удалённых веток не влияет на локальные копии этих веток у других пользователей. Они должны вручную удалить локальные копии у себя, если это необходимо.

В некоторых системах контроля версий, таких как GitHub, удалённые ветки также могут быть восстановлены через веб-интерфейс в течение некоторого времени после удаления, предоставляя дополнительную безопасность.

[Назад к оглавлению](#оглавление)


## Работа с репозиторием

Команда `git clone git@github.com:user-name/repo-name.git`  не просто скопировала репозиторий чтобы использовать его локально, но и настроила соответствующим образом Git: 

Создан каталог `.git`, скачаны все данные репозитория, скачаны все изменения, которые были в репозитории, репозиторий на GitHub настроен как удаленный (remote) для локального репозитория

Готов полноценный локальный репозиторий Git, в котором можно работать. Обычно последовательность работы следующая:

Перед началом работы, синхронизация локального содержимого с GitHub командой 
```bash
git pull
```

### Изменение файлов репозитория

- Добавление изменённых файлов (*индексация*) в `staging` командой `git add`
- Фиксация изменений через коммит командой `git commit -m "commit text"`
- Передача локальных изменений в репозиторий на GitHub командой `git push`

При работе с удаленным репозиторием, важно обратить особое внимание на первый и последний шаги:
- *Первый шаг* – обновление локального репозитория `git pull`
- *Последний шаг* – загрузка изменений на GitHub `git push` (непосредственно перед выполнением этой команды — рекомендуется сделать `git pull`)

[Назад к оглавлению](#оглавление)


### Сравнение репозиториев

Чтобы узнать изменения в удаленном репозитории перед выполнением `git pull`, нужно выполнить последовательно следующие действия и команды:

Чтобы получить последние изменения из удаленного репозитория, выполните команду для обновления информации об удаленном репозитории:
```bash
git fetch
```

Просмотр разницы между локальной и удаленной ветками - какие изменения были внесены в удалённую ветку по сравнению с локальной (если работа производится в другой ветке - то нужно заменить main на название текущей ветки):
```bash
git diff main origin/main
```

Просмотр журнала коммитов, отсутствующих в локальной ветке: чтобы увидеть список коммитов, которые были добавлены в удаленную ветку, но еще не присутствуют в вашей локальной ветке, используйте
```bash
git log main..origin/main
```

Просмотр краткого списка коммитов:
```bash
git log --oneline main..origin/main
```

Проверка статуса ветки - чтобы получить информацию о том, насколько локальная ветка отстает или опережает удаленную ветку, нужно выполнить:
```bash
git status -uno
```

Заключительный шаг: после проверки изменений, если вы уверены, что хотите синхронизировать свою локальную ветку с удаленной, выполните `git pull` (по желанию).

[Назад к оглавлению](#оглавление)


### Операции отмены

Есть несколько основных способов отмены сделанных изменений. 

> **Осторожно!** — Не все операции отмены в свою очередь можно отменить! Это одна из редких областей Git, где неверными действиями можно необратимо удалить результаты своей работы. 
> 
> Так-же нужно понимать, что всё, что не было включено в коммит и потеряно — скорее всего, потеряно навсегда!

**Отмена изменений в файле.**

Откат к последнему коммиту: чтобы откатиться к последнему локальному коммиту, и восстановить файлы, можно сделать следующее:

Шаги:

1. Проверить историю коммитов: сначала убедитесь, что коммит с нужной структурой файлов всё ещё в локальной истории.
```bash
git log --oneline
```

Нужно найти коммит с нужной структурой файлов. Если это последний коммит, то всё отлично.

2. Откат к последнему локальному коммиту: если коммит есть в истории, можно выполнить команду для отката:
   
```bash
git reset --hard <commit_hash>
```
Где `<commit_hash>` — это хеш нужного коммита (можно взять из команды `git log`).

Если это последний коммит (или если нужно откатиться к самому последнему коммиту), можно просто выполнить:
```bash
git reset --hard HEAD
```

3. Проверка состояния репозитория. Убедитесь, что файлы вернулись и структура восстановлена. Для этого можно посмотреть текущее состояние:
```bash
git status
```

4. Принудительный пуш (push) на удалённый репозиторий. Так как на удалённом репозитории структура отличается, нужно **принудительно** запушить локальные изменения (эта команда перезапишет изменения на удалённом репозитории твоими локальными коммитами, включая новую структуру файлов):
   
   ```bash
   git push --force
   ```

 Таким образом:

- `git reset --hard HEAD` - откатывает все изменения и возвращает репозиторий к последнему коммиту, полностью восстанавливая состояние файлов.
- `git push --force` - принудительно пушит изменения, игнорируя возможные расхождения с удалённым репозиторием.

> **Важно:** Принудительный пуш (`--force`) может перезаписать историю коммитов на удалённом репозитории, поэтому убедитесь, что текущая локальная версия — именно та, которую вы хотите сохранить.

Эти шаги должны помочь восстановить файлы и структуру, а также запушить их на удалённый репозиторий.

[Назад к оглавлению](#оглавление)


### Перезапись последнего коммита

Используется когда слишком рано сделан коммит, если забыли добавить какие-то файлы или комментарий к коммиту. В таком случае нужно внести необходимые изменения, добавить их в *индекс* (`Staging`) и сделать коммит еще раз, указав параметр `--amend`:
```bash
git commit --amend
```

Запустится редактор, который будет содержать сообщение предыдущего коммита. Далее — нужно отредактировать, или оставить без изменений комментарий к коммиту, и выйти из редактора с сохранением. 

Важно понимать что параметр `--amend` работает в индексе (`Staging Area`) — области подготовки изменений для следующего коммита, и перезапишет первоначальный коммит. 

В результате всё выглядит так, будто первоначальный коммит никогда не существовал. Смысл такого изменения коммитов — в добавлении незначительных правок в последние коммиты, в целях избежания засорения истории.

### Отмена индексации файла 

Используется при ошибочном добавлении файлов в Индекс. Например после `git add .` — нужно исключить один или несколько файлов из `Staging Area`, для этого используется:
```bash
git reset HEAD file.name …
```

Троеточие `…` означает то, что команда может применяться к одному файлу или к нескольким файлам одновременно. Команда не затрагивает сам файл, и поэтому относительно безопасна. 

> **Важно:** к команде `git reset`, с другими параметрами нужно относится с осторожностью, т.к. при ее использовании можно безвозвратно потерять результаты своей работы.

В новых версия Git появилась альтернативная команда:
```bash
git restore --staged file.name …
```

Для того чтобы вернуть файл (или несколько) к тому состоянию, которое было в последнем коммите, нужно выполнить команду `checkout`, или альтернативную ей `restore`:
```bash
git checkout -- file.name …
git restore file.name …
```

Откатить файл (или несколько) до определенного коммита можно командой:
```bash
git checkout <commit-hash> -- file.name …
```

При использовании `git restore`, нужно сначала откатить индекс `Staging Area` до нужного коммита:
```bash
git restore --source <commit-hash> --staged file.name …
```
И затем восстановить файл:
```bash
git restore file.name … 
```

Можно использовать полный или сокращенный хеш коммита. **Команда является опасной**, т.к. изменения, сделанные в файле после указанного коммита, будут потеряны, команда заменит файл версией из последнего коммита. Альтернативой использования опасных команд могут является возможности ветвления и припрятывания изменений в репозитории.

[Назад к оглавлению](#оглавление)


### Синхронизация репозиториев

- `git diff` показывает, какие изменения были внесены с момента последнего коммита в локальном репозитории. Если добавить изменения, внесенные в файлы, в индекс (`staging`) командой `git add` и ещё раз выполнить команду `git diff`, то она ничего не покажет. Чтобы показать отличия между `staging` и последним коммитом, надо добавить параметр `git diff --staged`.

- `git log -p` -  позволяет отобразить отличия, которые были внесены каждым коммитом, более короткий вариант вывода можно вывести с флагом `git log --stat`.

- `git log -s -2` - выведет в терминал краткие сведения о последних двух коммитах.

- `git log -p origin/branch-name` - покажет, какие изменения вы собираетесь добавлять в репозиторий на GitHub

- Для синхронизации локального репозитория с содержимым удалённого репозитория существуют несколько команд с разными механизмами действия, основные из них — `git fetch`, `git merge` и `git pull`:

- `git fetch` - загружает данные из удаленного репозитория в локальный, не пытаясь сливать изменения или модифицировать файлы в вашем рабочем каталоге.

- После выполнения `git fetch`, можно посмотреть какие коммиты были добавлены в удалённую ветку (если используется `vim`, по умолчанию, то выход из журнала - `q`):
```bash
git log HEAD..repo-name/branch-name
```

### Указатель HEAD

Здесь стоит сделать отступление, и обозначить понятие `HEAD` в Git, поскольку понимание `HEAD` и связанных с ним объектов критически важно для эффективной работы с Git, так как они играют ключевую роль в навигации по истории проекта, управлении изменениями и подготовке к коммитам.

Еще это понятие центральное для работы с Git, поскольку большинство команд, изменяющих состояние репозитория, используют `HEAD` как отправную точку.

В Git `HEAD` *обозначает указатель на текущий коммит в рабочей копии репозитория*, то есть указатель на коммит, который является последним в текущей ветке и на основе которого строится рабочее дерево файлов. 

**Назначение:** снимок последнего коммита, родитель следующего.

**Как используется HEAD:**

- При коммитах: когда вы делаете коммит, Git создаёт новый коммит с текущим состоянием индекса (области подготовки) и перемещает `HEAD` (а также указатель текущей ветки) на этот новый коммит.

- При слиянии: команда `git merge` объединяет изменения из другой ветки в ветку, указываемую `HEAD`.

- При перебазировании: `git rebase` переносит коммиты из одной ветки в другую, изменяя базу ветки, на которую указывает `HEAD`.

- При сбросе: `git reset` перемещает `HEAD` (и, возможно, текущую ветку) на указанный коммит, опционально изменяя индекс и рабочий каталог.

- При проверке версии: `git checkout "commit"` или `git switch "commit"` перемещает `HEAD` на указанный коммит или ветку, изменяя рабочий каталог к состоянию этого коммита.

**Схожие объекты:**

- Индекс (`Staging Area`): назначение - снимок следующего намеченного коммита — область подготовки изменений для следующего коммита. Сюда добавляются файлы, которые вы хотите включить в коммит, с помощью git add.

- `ORIG_HEAD`: cохраняет предыдущее состояние `HEAD` перед опасными операциями, например, перед слиянием или сбросом. Это позволяет легко отменить изменения, если что-то пошло не так.

- `FETCH_HEAD`: cохраняет состояние последнего коммита из удалённого репозитория, полученного с помощью `git fetch`. Это позволяет сливать или перебазировать локальную ветку на основе последних изменений из удалённого репозитория.

- Теги (`tags`): указатели на определенные коммиты, обычно используются для маркировки релизов. Полезный инструмент для того, чтобы не заблудиться в куче коммитов.

[Назад к оглавлению](#оглавление)


### Синхронизация репозиториев продолжение

Возвращаемся к `git fetch`. 
- Эту команду полезно использовать, поскольку она предоставляет способ оставаться информированным о развитии проекта и планировать свои действия, не внося при этом никаких изменений в свой рабочий код.
- Позволяет видеть изменения, не рискуя непреднамеренно перезаписать свою работу.
- Позволяет лучше спланировать свои действия по интеграции изменений, особенно если предстоят конфликты слияния.
- Позволяет быть в курсе последних изменений в проекте без необходимости изменять свой локальный код.

Получить данные для конкретной ветки — следующая команда загрузит изменения только для указанной ветки `branch-name` из удалённого репозитория `origin`:
```bash
git fetch origin branch-name
```

После выполнения команды `git fetch`, можно проверить существующие ветки и их статус — список всех веток (локальных и удалённых) и их последние коммиты:
```bash
git branch -av
```

Посмотреть историю коммитов в ветке `branch-name`:
```bash
git log branch-name
```

Сравнить текущую ветку с удалённой (откроется журнал с изменениями, выход - `q`), эта команда покажет различия между текущим `HEAD` (текущий коммит активной локальной ветки) и последним коммитом в удалённой ветке:
```bash
git diff HEAD origin/branch-name
```

В выводе `git diff`, символы `@@ -43,19 +45,21 @@` представляют собой контекстную информацию о том, что происходит с участками кода при сравнении двух версий файлов. Эти строки называются *"hunk headers"* и содержат важные указания о различиях между старыми и новыми версиями файлов.
- `@@` — это маркер начала нового блока изменений (hunk);
- `-43,19` — показывает, что в оригинальном файле изменения начинаются со строки 43 и затрагивают 19 строк.
- `+45,21` — показывает, что в новом файле соответствующие изменения начинаются со строки 45 и затрагивают 21 строку.

Если нужно сохранить локальные изменения, но временно отложить их для выполнения операций с удалённым репозиторием, можно использовать `git stash`. Это позволит сохранить текущие изменения в стеке (`stash`), выполнить `git pull` для получения последних обновлений, а затем восстановить изменения:
```bash
git stash  # сохранение локальных изменений
git pull  # получение обновлений 
git stash pop  # возврат к сохраненным изменениям
```

Команда слияния `git merge` позволяет объединить изменения двух различных веток. Например, после завершения работы над фичей в отдельной ветке `feature` — можно слить эту ветку с `develop` или `main`, чтобы интегрировать новую функциональность в основной код проекта.
```bash
git checkout main  # переключение на ветку main
git merge feature  # слияние ветки feature в ветку main
```

Также эта команда позволяет обновить локальную ветку. Если ветка, над которой идет работа — отстала от `main` или `develop` (например, в ней нет последних обновлений), можно выполнить `git merge`, чтобы внести обновления, сохраняя при этом изменения.

- Как это работает: `git merge` создает новый коммит слияния, который объединяет истории двух веток. Ветка, в которую происходит слияние, сохраняет свою историю, и к ней добавляется новый коммит, который соединяет с веткой-источником.
- Когда использовать: слияние используется если нужно сохранить историю всех коммитов и важно видеть точные точки, где ветки сливались. Это полезно для командной работы, где важно видеть полный путь изменений.

`git rebase` — еще один способ интеграции изменений из одной ветки в другую, но  оставляет другой след в истории коммитов: перемещает или "переписывает" коммиты с одной ветки на другую. Команда берет все коммиты из текущей ветки и применяет их поверх другой ветки. В результате создается линейная история.
```bash
git checkout feature  # переключение на ветку feature
git rebase main  # перезапись всех коммитов ветки feature поверх коммитов  ветки main
```

- Когда использовать: `git rebase` используется если нужно сохранить чистую и линейную историю изменений. Это полезно для интеграции изменений из одной ветки в другую, чтобы избежать дополнительных коммитов слияния.

Чтобы увидеть полную историю коммитов, включая коммиты слияния, нужно использовать:
```bash
git log --graph --oneline --all
git pull
```

Команды интеграции имеют примерно следующий вывод, после их применения:
```bash
place/your/project> git fetch
remote: Enumerating objects: 27, done.  #  удалённый репозиторий определил, что есть 27 объектов (файлы, коммиты, теги и т.д.), которые нужно обработать.
remote: Counting objects: 100% (23/23), done.  # из этих 27 объектов, 23 являются новыми или измененными, которые удалённый репозиторий решил отправить локальному репозиторию. Счет объектов завершен на 100%.
remote: Compressing objects: 100% (9/9), done. # Из 23 объектов, 9 были сжаты для передачи. Сжатие завершено на 100%.
remote: Total 18 (delta 9), reused 18 (delta 9), pack-reused 0  # Всего 18 объектов были переданы, из них 9 объектов были изменены (delta). Все 18 объектов использованы, и ни один из объектов не был повторно использован из предыдущих пакетов.
Unpacking objects: 100% (18/18), 3.80 KiB | 0 bytes/s, done.  # Локальный репозиторий распаковывает все 18 объектов. Это процесс завершен, и суммарный объём данных составил 3.80 KiB.
From github.com:ali-adm/UPSASupport  # Сообщение о том, что данные были получены из удалённого репозитория с URL github.com:ali-adm/UPSASupport.
0f3af33..4d2597b  tol    	-> origin/tol  # Эта строка указывает на изменения в ветке tol. Локальная ветка origin/tol обновлена с коммита 0f3af33 до коммита 4d2597b.
```

**Дельта** (`delta`): это разница между двумя версиями данных. В Git дельты используются для представления изменений между версиями файлов. Это позволяет Git эффективно хранить и передавать данные, минимизируя объем передаваемых данных. Использование дельт уменьшает размер репозитория и ускоряет операции, такие как `fetch` и `push`, за счет передачи только изменений. 

[Назад к оглавлению](#оглавление)


### Разрешение конфликтов

В процессе слияния Git пытается автоматически разрешить различия между ветками. Если это невозможно, Git сообщает какие файлы конфликтуют, и предлагает ручное разрешение конфликтов, что является ключевым моментом в совместной работе над кодом и дает полный контроль над тем, какие изменения принимаются, и позволяет точно разрешить конфликты:
```bash
git fetch
git merge origin/main  # или git merge origin/branch-name
git mergetool
```

Где `mergetool` — инструмент слияния. Например псевдографический `vimdiff`, или графические `meld` или `p4merge`.

Перед использованием инструмента слияния, нужно его настроить — указать git каким инструментом пользоваться:
```bash
git config --global merge.tool tool-name
```

Интеграция `Meld` с Git в качестве примера:

Чтобы настроить Git (на windows) для использования `Meld` в качестве инструмента для слияния и сравнения нужно загрузить (https://meldmerge.org/) и установить Meld. Далее  нужно выполнить команды:
```bash
git config --global diff.tool meld  # установка Meld в кач-ве инструмента сравнения
git config --global difftool.meld.path "C:/Путь/к/Meld/Meld.exe"
git config --global difftool.prompt false
git config --global merge.tool meld  # установка Meld в кач-ве инструмента слияния
git config --global mergetool.meld.path "C:/Путь/к/Meld/Meld.exe"
git config --global mergetool.prompt false
```

Сравнение файлов между различными коммитами, ветками или рабочим каталогом:
```bash
git difftool commit1 commit2 file
git difftool HEAD^ HEAD file.txt
```

Решение конфликтов слияния:
```bash
git mergetool
```

В конфликтующем фалйе - Git помечает места где возник конфликт специальными маркерами. Они выглядят примерно так:

<<<<<<< HEAD
// Версия локального кода
=======
// Версия кода из удаленного репозитория
>>>>>>> branch-name

Нужно решить, какая версия кода (или возможно комбинация обеих) должна остаться. Также нужно удалить маркеры конфликта (`<<<<<<<`, `=======`,` >>>>>>>`) и сохранить файл после того, как будет решен каждый конфликт. 

Иногда нужно полностью перенести состояние удалённой ветки в локальную, и тогда можно пересоздать локальную ветку:
```bash
git checkout main  # переключение на main, или другую базовую ветку
git branch -D feature-branch-name  # удаление feature-branch-name
git fetch  # обновление локального репозитория
git checkout -b feature-branch-name origin/feature-branch-name  # пересоздание ветки по образу удаленной (remote). Эти действия полезны когда локальная ветка сильно отстала от удаленной, и проще начать с чистого состояния.
```

После изменения или правки файлов, а так-же после решения конфликтов настало время добавления изменений в индекс `Stage Area` для следующего коммита, путем выполнения:
```bash
git add .  # точка обозначает “все файлы в каталоге”, либо
git add file-name
```

[Назад к оглавлению](#оглавление)


### Продолжение работы с репозиторием

После разрешения конфликтов и добавления файлов в индекс (`git add .`), можно добавлять коммит - `git commit`. Git откроет редактор для ввода сообщения коммита для слияния. Можно оставить автоматически сгенерированное сообщение или ввести своё, после чего сохранить и закрыть файл.

Либо можно добавить коммит сразу с комментарием:
```bash
git commit -m "В кавычках сообщение к коммиту"
```

Желательно всегда делать информативные сообщения в коммитах, это нужно в перую очередь для того, чтобы потом в будущем было понятно что это был за коммит, какие изменения он нёс. Особенно это актуально для командной работы.

Теперь, после добавления коммита, можно безопасно работать! Так-же можно сделать:
- `git pull` - и убедиться что больше нет разницы с удаленным репозиторием, или
- `git push` - чтобы отправить разрешенные изменения на удаленный сервер.

При завершении работы с файлами, нужно опять их добавить в индекс, после чего сделать коммит, и отправить изменения на репозиторий: 
```bash
git add .  # добавить все файлы в директории в индекс
git commit -m "Комментарий"  # добавить коммит с комментарием
git push  # отправить файлы на удаленный репозиторий
```

При соблюдении этой инструкции можно коллективно работать с репозиторием не нарушая его общей структуры и логики. Либо изменяя структури и/или логику - но документируя это понятными коментариями, для себя в будущем, или для других, кто так-же работает в этом репозитории - в настоящем или в будущем.

[Назад к оглавлению](#оглавление)


### Варианты упрощения команд

В Git не часто встречаются особо громоздкие выражения, поэтому следующие сведения носят больше академический характер. Например есть несколько способов упростить работу с `git commit`, чтобы не писать длинную (`git commit -m`) команду каждый раз. К ним относятся:

- **Алиасы (alias)** в Git:
```bash
git config --global alias.ci "commit -m"
```

Теперь можно коммитить так:
```bash
git ci "Комментарий"
```

- **Алиасы в терминале (bash/zsh)**:

Можно ещё больше упростить ввод команд, создав алиас в терминале для ещё более коротких команд. Пример (в `.bashrc` или `.zshrc`):
```bash
alias gcm='git commit -m'
```

После этого можно коммитить так:
```bash
gcm "Комментарий"
```

- **Система хук-скриптов**:
Можно использовать хук в Git для автокоммита с фиксированным сообщением, но это может быть не так гибко.

[Назад к оглавлению](#оглавление)


### Заключение

Данный гайд содержит необходимый минимум для работы с GinHub, и может быть применим, в большей степени, для работы с другими системами контроля версий (Git) - GitLab и др.

Как было сказано выше, при соблюдении этой инструкции можно коллективно работать с удаленным репозиторием не нарушая его общей структуры и логики. Либо изменяя структури и/или логику - но документируя это понятными коментариями, для себя в будущем, или для других, кто так-же работает, или будет работать с этим репозиторием - в настоящем или в будущем.
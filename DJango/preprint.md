# Django 
[Источник](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Introduction)

- [Django](#django)
  - [Введение](#введение)
    - [Как выглядит код Django?](#как-выглядит-код-django)
    - [Отправка запроса в правильное view (urls.py)](#отправка-запроса-в-правильное-view-urlspy)
    - [Обработка запроса (views.py)](#обработка-запроса-viewspy)
    - [Определение данных модели (models.py)](#определение-данных-модели-modelspy)
    - [Запросы данных (views.py)](#запросы-данных-viewspy)
    - [Вывод данных (HTML-шаблоны)](#вывод-данных-html-шаблоны)
    - [Что ещё можно сделать?](#что-ещё-можно-сделать)
    - [Резюме](#резюме)
  - [Setting up a Django development environment](#setting-up-a-django-development-environment)
    - [Обзор среды разработки Django](#обзор-среды-разработки-django)
    - [Разновидности установки Django](#разновидности-установки-django)
    - [Установка Python 3](#установка-python-3)
    - [Использование Django внутри виртуальной среды Python](#использование-django-внутри-виртуальной-среды-python)
    - [Установка ПО виртуальной среды](#установка-по-виртуальной-среды)
    - [Создание и использование виртуальной среды](#создание-и-использование-виртуальной-среды)
    - [Установка Django, проверка установки](#установка-django-проверка-установки)
    - [Заключение](#заключение)
  - [Django: сайт местной библиотеки](#django-сайт-местной-библиотеки)
    - [Обзор руководства](#обзор-руководства)
    - [Сайт местной библиотеки](#сайт-местной-библиотеки)
  - [Django 2: создание скелета](#django-2-создание-скелета)
    - [Обзор](#обзор)
    - [Создание проекта](#создание-проекта)
    - [Создание приложения Каталог](#создание-приложения-каталог)
    - [Регистрация папки с приложением](#регистрация-папки-с-приложением)
    - [Настройка базы данных](#настройка-базы-данных)
    - [Другие настройки проекта](#другие-настройки-проекта)
    - [Подключение URL-адреса](#подключение-url-адреса)
    - [Тестирование работы скелета](#тестирование-работы-скелета)
    - [Запуск сайта](#запуск-сайта)
  - [Django 3: использование моделей](#django-3-использование-моделей)
    - [Обзор](#обзор-1)
    - [Проектирование моделей LocalLibrary](#проектирование-моделей-locallibrary)
    - [Модель для начинающих](#модель-для-начинающих)
    - [Определение модели](#определение-модели)
    - [Поля](#поля)
    - [Общие аргументы поля](#общие-аргументы-поля)
    - [Общие типы полей](#общие-типы-полей)
    - [Метаданные](#метаданные)
    - [Методы](#методы)
    - [Управление моделью](#управление-моделью)
    - [Определение моделей LocalLibrary](#определение-моделей-locallibrary)
    - [Модель жанра](#модель-жанра)
    - [Модель книги](#модель-книги)
    - [Модель BookInstance](#модель-bookinstance)
    - [Модель автора](#модель-автора)
    - [Повторно выполнить миграцию базы данных](#повторно-выполнить-миграцию-базы-данных)
    - [Языковая модель - вызов](#языковая-модель---вызов)
    - [Итог](#итог)
  - [Django 4: административная панель Django](#django-4-административная-панель-django)
    - [Обзор](#обзор-2)
    - [Регистрация моделей](#регистрация-моделей)
    - [Создание суперпользователя](#создание-суперпользователя)
    - [Вход в админ-панель и её использование](#вход-в-админ-панель-и-её-использование)
    - ["Продвинутая" конфигурация](#продвинутая-конфигурация)
    - [Регистрация класса ModelAdmin](#регистрация-класса-modeladmin)
    - [Настройка отображения списков](#настройка-отображения-списков)
    - [Добавление фильтров списка](#добавление-фильтров-списка)
    - [Формирование макета с подробным представлением](#формирование-макета-с-подробным-представлением)
    - [Управление отображаемыми и вложенными полями](#управление-отображаемыми-и-вложенными-полями)
    - [Разделение на секции/Выделение подробного представления](#разделение-на-секциивыделение-подробного-представления)
    - [Встроенное редактирование связанных записей](#встроенное-редактирование-связанных-записей)
    - [Проверьте себя](#проверьте-себя)
    - [Заключение](#заключение-1)
  - [Django 5: cоздание домашней страницы](#django-5-cоздание-домашней-страницы)
    - [Обзор](#обзор-3)
    - [Определяем URL-адреса страниц](#определяем-url-адреса-страниц)
    - [Создание главной страницы сайта](#создание-главной-страницы-сайта)
    - [URL-преобразование](#url-преобразование)
    - [Отображения (на основе функций)](#отображения-на-основе-функций)
    - [Шаблон](#шаблон)
    - [Расширение шаблонов](#расширение-шаблонов)
    - [Базовый шаблон сайта LocalLibrary](#базовый-шаблон-сайта-locallibrary)
    - [Индексный шаблон (шаблон главной страницы сайта)](#индексный-шаблон-шаблон-главной-страницы-сайта)
    - [Ссылка на статические файлы их шаблонов](#ссылка-на-статические-файлы-их-шаблонов)
    - [Построение URL-адресов](#построение-url-адресов)
    - [Как теперь все это выглядит?](#как-теперь-все-это-выглядит)
    - [Проверьте себя](#проверьте-себя-1)
    - [Итог](#итог-1)
  - [Django 6: отображение списков и детальной информации](#django-6-отображение-списков-и-детальной-информации)
    - [Обзор](#обзор-4)
    - [Страница со списком книг](#страница-со-списком-книг)
    - [Преобразования URL-адресов](#преобразования-url-адресов)
    - [Отображение (на основе базового класса)](#отображение-на-основе-базового-класса)
    - [Переопределение методов в классах отображения](#переопределение-методов-в-классах-отображения)
    - [Создание шаблона Отображения Списка](#создание-шаблона-отображения-списка)
    - [Условные ветвления](#условные-ветвления)
    - [Цикл For](#цикл-for)
    - [Доступ к переменным](#доступ-к-переменным)
    - [Обновление базового шаблона](#обновление-базового-шаблона)
    - [Страница с подробной информацией о книге](#страница-с-подробной-информацией-о-книге)
    - [URL-преобразования](#url-преобразования)
    - [Отдельный пример с регулярными выражениями](#отдельный-пример-с-регулярными-выражениями)
    - [Передача дополнительных настроек в ваши преобразования URL-адресов](#передача-дополнительных-настроек-в-ваши-преобразования-url-адресов)
    - [Отображение (на основе класса)](#отображение-на-основе-класса)
    - [Создание шаблона детальной информации](#создание-шаблона-детальной-информации)
    - [Как это теперь выглядит?](#как-это-теперь-выглядит)
    - [Постраничный вывод (Pagination)](#постраничный-вывод-pagination)
    - [Отображения](#отображения)
    - [Шаблоны](#шаблоны)
    - [Как это выглядит?](#как-это-выглядит)
    - [Проверьте себя](#проверьте-себя-2)
    - [Итоги](#итоги)
  - [Django 7: сессии](#django-7-сессии)
    - [Обзор](#обзор-5)
    - [Что такое сессии?](#что-такое-сессии)
    - [Подключение сессий](#подключение-сессий)
    - [Применение сессий](#применение-сессий)
    - [Хранение данных сессии](#хранение-данных-сессии)
    - [Простой пример — получение числа визитов](#простой-пример--получение-числа-визитов)
  - [Django 8: аутентификация и авторизация пользователя](#django-8-аутентификация-и-авторизация-пользователя)
    - [Обзор](#обзор-6)
    - [Подключение аутентификации](#подключение-аутентификации)
    - [Создание пользователей и групп](#создание-пользователей-и-групп)
    - [Настройка представлений проверки](#настройка-представлений-проверки)
    - [Проектирование URLs](#проектирование-urls)
    - [Каталог шаблонов](#каталог-шаблонов)
    - [Шаблон аутентификации](#шаблон-аутентификации)
    - [Шаблон выхода](#шаблон-выхода)
    - [Шаблон сброса пароля](#шаблон-сброса-пароля)
    - [Форма сброса пароля](#форма-сброса-пароля)
    - [Сброс пароля](#сброс-пароля)
    - [Сброс пароля по email](#сброс-пароля-по-email)
    - [Подтверждение на сброс пароля](#подтверждение-на-сброс-пароля)
    - [Сброс пароля завершён](#сброс-пароля-завершён)
    - [Тестирование новых страниц аутентификации](#тестирование-новых-страниц-аутентификации)
    - [Тестирование проверки подлинности пользователей](#тестирование-проверки-подлинности-пользователей)
    - [Пример - перечисление книг текущего пользователя](#пример---перечисление-книг-текущего-пользователя)
    - [Модели](#модели)
    - [Admin](#admin)
    - [Займите несколько книг](#займите-несколько-книг)
    - [Займ в представлении](#займ-в-представлении)
    - [URL-адрес для заёмных книг](#url-адрес-для-заёмных-книг)
    - [Шаблон для заёмных книг](#шаблон-для-заёмных-книг)
    - [Добавить список на боковую панель](#добавить-список-на-боковую-панель)
    - [На что это похоже?](#на-что-это-похоже)
    - [Права доступа](#права-доступа)
    - [Шаблоны](#шаблоны-1)
    - [Представления](#представления)
    - [Испытайте себя](#испытайте-себя)
    - [Подводим итоги](#подводим-итоги)
  - [Django 9: работа с формами](#django-9-работа-с-формами)
    - [Обзор](#обзор-7)
    - [Формы HTML](#формы-html)
    - [Процесс управления формой в Django](#процесс-управления-формой-в-django)
    - [HTML-форма обновления книги. Класс Form и функция отображения](#html-форма-обновления-книги-класс-form-и-функция-отображения)
    - [Класс Form](#класс-form)
    - [Объявление класса формы Form](#объявление-класса-формы-form)
    - [Поля формы](#поля-формы)
    - [Валидация](#валидация)
    - [Копирование класса формы](#копирование-класса-формы)
    - [Конфигурация URL-адресов](#конфигурация-url-адресов)
    - [Отображение](#отображение)
    - [Шаблон](#шаблон-1)
    - [Другие варианты применения переменной шаблона form](#другие-варианты-применения-переменной-шаблона-form)
    - [Тестирование страницы](#тестирование-страницы)
    - [Как теперь все это выглядит?](#как-теперь-все-это-выглядит-1)
    - [Класс ModelForm](#класс-modelform)
    - [Обобщённые классы отображения для редактирования](#обобщённые-классы-отображения-для-редактирования)
    - [Отображения](#отображения-1)
    - [Шаблоны](#шаблоны-2)
    - [Тестирование страницы](#тестирование-страницы-1)
    - [Проверьте себя](#проверьте-себя-3)
    - [Итоги](#итоги-1)
  - [Django 10: тестрование приложений Django](#django-10-тестрование-приложений-django)
    - [Обзор](#обзор-8)
    - [Типы тестирования](#типы-тестирования)
    - [Что Django предоставляет для тестирования?](#что-django-предоставляет-для-тестирования)
    - [Что вы должны тестировать?](#что-вы-должны-тестировать)
    - [Обзор структуры тестов](#обзор-структуры-тестов)
    - [Как запускать тесты](#как-запускать-тесты)
    - [Ещё больше тестовой информации](#ещё-больше-тестовой-информации)
    - [Запуск определённых тестов](#запуск-определённых-тестов)
    - [Тестирование LocalLibrary](#тестирование-locallibrary)
    - [Формы](#формы)
    - [Отображения](#отображения-2)
    - [Отображения и регистрация пользователей](#отображения-и-регистрация-пользователей)
    - [Тестирование форм и отображений](#тестирование-форм-и-отображений)
    - [Шаблоны](#шаблоны-3)
    - [Другие рекомендованные инструменты для тестирования](#другие-рекомендованные-инструменты-для-тестирования)
    - [Домашняя работы](#домашняя-работы)
    - [Итоги](#итоги-2)
  - [Django 11: разворачивание сайта на сервере](#django-11-разворачивание-сайта-на-сервере)
    - [Что такое окружение развёртывания?](#что-такое-окружение-развёртывания)
    - [Выбор хостинг провайдера](#выбор-хостинг-провайдера)
    - [Подготовка веб-сайта к публикации](#подготовка-веб-сайта-к-публикации)
    - [Пример: Установка LocalLibrary на Heroku](#пример-установка-locallibrary-на-heroku)
    - [Почему Heroku?](#почему-heroku)
    - [Как работает Heroku?](#как-работает-heroku)
    - [Создание репозитория приложения на Github](#создание-репозитория-приложения-на-github)
    - [Обновить приложение для Heroku](#обновить-приложение-для-heroku)
    - [Настройка Базы Данных](#настройка-базы-данных-1)
    - [Обслуживание статических файлов в производстве](#обслуживание-статических-файлов-в-производстве)
    - [settings.py](#settingspy)
    - [WhiteNoise](#whitenoise)
    - [Получить аккаунт в heroku](#получить-аккаунт-в-heroku)
    - [Установка клиента](#установка-клиента)
    - [Создание и загрузка веб-сайта](#создание-и-загрузка-веб-сайта)
    - [Управление аддонами](#управление-аддонами)
    - [Настройка переменных конфигурации](#настройка-переменных-конфигурации)
    - [Отладка](#отладка)
    - [Итоги](#итоги-3)
    - [Безопасность веб-приложения Django](#безопасность-веб-приложения-django)

## Введение

**Django** — это высокоуровневый Python веб-фреймворк, который позволяет быстро создавать безопасные и поддерживаемые веб-сайты. Созданный опытными разработчиками, Django берёт на себя большую часть хлопот веб-разработки, поэтому вы можете сосредоточиться на написании своего веб-приложения без необходимости изобретать велосипед. Он бесплатный и с открытым исходным кодом, имеет растущее и активное сообщество, отличную документацию и множество вариантов как бесплатной, так и платной поддержки.

**Django** помогает писать программное обеспечение, которое будет:

- **Полным** (философия «Всё включено»)
- **Разносторонним** (создание любого типа сайтов, работа с любой клиентской средой, доставка контента в любом формате, может быть расширен сторонними компонентами)
- **Безопасным** (управление учётными записями, хэши паролей, защита от многих уязвимостей - SQL-инъекции, межсайтовый скриптинг, подделка межсайтовых запросов и кликджекинг)
- **Масштабируемым** (**"shared-nothing"** архитектура - чёткое разделение частей означает, что Django может масштабироваться при увеличении трафика, путём добавления оборудования на любом уровне: серверы кеширования, серверы баз данных или серверы приложений )
- **Удобным в сопровождении** (используется принцип **«Don't Repeat Yourself»** - **DRY**, «не повторяйся», группирует связанный код в модули шаблона MVC)
- **Переносным** (мультиплатформа)

**Django** «умеренно гибкий». Он предоставляет набор компонентов для обработки большинства задач веб-разработки и один (или два) предпочтительных способа их использования. Однако такая архитектура Django означает, что вы обычно можете выбирать из нескольких различных опций или при необходимости добавлять поддержку для совершенно новых.

[Назад к Django](#django)

### Как выглядит код Django?

На традиционном информационном веб-сайте веб-приложение ожидает HTTP-запросы от веб-браузера (или другого клиента). Когда запрос получен, приложение разрабатывает то, что необходимо на основе URL-адреса и, возможно, данных в POST или GET запросах. В зависимости от того, что требуется, далее он может читать или записывать информацию из базы данных или выполнять другие задачи, необходимые для удовлетворения запроса. Затем приложение вернёт ответ веб-браузеру, часто динамически создавая HTML-страницу для отображения в браузере, вставляя полученные данные в HTML-шаблон.

Веб-приложения, написанные на Django, обычно группируют код, который обрабатывает каждый из этих шагов, в отдельные файлы:

![Блок-схема работы Django](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Introduction/basic-django.png)

- **URLs:** Хотя можно обрабатывать запросы с каждого URL-адреса с помощью одной функции, гораздо удобнее писать отдельную функцию для обработки каждого ресурса. URL-маршрутизатор используется для перенаправления HTTP-запросов в соответствующее представление на основе URL-адреса запроса. Кроме того, URL-маршрутизатор может извлекать данные из URL-адреса в соответствии с заданным шаблоном и передавать их в соответствующую функцию отображения (view) в виде аргументов.
- **View:** View (англ. «отображение») — это функция обработчика запросов, которая получает HTTP-запросы и возвращает ответы. Функция view имеет доступ к данным, необходимым для удовлетворения запросов, и делегирует ответы в шаблоны через модели.
- **Models:** Модели представляют собой объекты Python, которые определяют структуру данных приложения и предоставляют механизмы для управления (добавления, изменения, удаления) и выполнения запросов в базу данных.
- **Templates:** Template (англ. «шаблон») — это текстовый файл, определяющий структуру или разметку страницы (например HTML-страницы), с полями для подстановки, которые используются для вывода актуального содержимого. View может динамически создавать HTML-страницы, используя HTML-шаблоны и заполняя их данными из модели (model). Шаблон может быть использован для определения структуры файлов любых типов, не обязательно HTML.

> **Примечание:** Django реализует уровневую архитектуру "Model View Template (MVT)". Она имеет много общего с более известной архитектурой Model View Controller.

[Назад к Django](#django)

### Отправка запроса в правильное view (urls.py)

Сопоставитель URL-адресов обычно содержится в файле **urls.py**. В примере ниже сопоставитель (`urlpatterns`) определяет список сопоставлений между *маршрутами* (определёнными URL-*шаблонами*) и соответствующими функциями отображения (view). Если получен HTTP-запрос, который имеет URL-адрес, соответствующий определённому шаблону, то затем будет вызвана связанная функция отображения (view) и передана в запрос.
```py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('book/<int:id>/', views.book_detail, name='book_detail'),
    path('catalog/', include('catalog.urls')),
    re_path(r'^([0-9]+)/$', views.best),
]
```

Объект `urlpatterns` является списком функций `path()` и/или `re_path()` (в Python списки определяются с помощью квадратных скобок, внутри которых элементы разделены запятыми и могут содержать [необязательную завершающую запятую](https://docs.python.org/2/faq/design.html#why-does-python-allow-commas-at-the-end-of-lists-and-tuples). Например: `[item1, item2, item3,]`).

Первый аргумент в обоих методах - маршрут (шаблон), который будет сопоставлен. В методе `path()` угловые скобки используются для определения частей URL-адреса, которые будут захвачены и переданы в функцию отображения (view) в качестве именованных аргументов. Функция `re_path()` использует гибкий подход к сопоставлению с шаблоном, известный как регулярное выражение. Мы поговорим об этом в следующей статье!

Второй аргумент — это ещё одна функция, которая будет вызываться при сопоставлении шаблона. Обозначение `views.book_detail` указывает, что функция называется `book_detail()` и может быть обнаружена в модуле с именем `views` (т.е. внутри файла с именем `views.py`).

[Назад к Django](#django)

### Обработка запроса (views.py)

Отображения (views) — это сердце веб-приложения, принимающего HTTP-запросы от веб-клиентов и возвращающего HTTP-ответы. Между этим они используют другие ресурсы фреймворка для доступа к базам данных, шаблонам визуализации и т. д.

В приведённом ниже примере показана минимальная функция представления `index()`, которая могла быть вызвана нашим сопоставителем URL-адресов в предыдущем разделе. Как и все функции отображения (view), она получает объект `HttpRequest` в качестве параметра (`request`) и возвращает объект `HttpResponse`. В этом случае мы ничего не делаем с запросом, и наш ответ просто возвращает жёстко запрограммированную строку. Мы покажем вам запрос, который делает что-то более интересное в следующем разделе.
```py
## filename: views.py (Django view functions)

from django.http import HttpResponse

def index(request):
    # Получить HttpRequest — параметр запроса
    # Выполнить операции, используя информацию из запроса.
    # Вернуть HttpResponse
    return HttpResponse('Hello from Django!')
```

> **Примечание:** Немного о Python:
> 
>[Модули Python](https://docs.python.org/3/tutorial/modules.html) это библиотеки функций, сохранённые в различных файлах, которые мы можем использовать в нашем коде. Здесь мы импортируем только объект `HttpResponse` из модуля `django.http` чтобы использовать его в нашем отображении (view): `from django.http import HttpResponse`. Также есть другие способы импортирования некоторых или всех объектов модуля.
>
>Функции объявляются с помощью ключевого слова `def`, как показано выше, с именованными параметрами, перечисленными в скобках после имени функции; строка завершается двоеточием. Заметьте, что следующие строки содержат отступы. Отступы важны, так как они определяют, какие строки кода находятся внутри конкретного блока (обязательные отступы — это ключевая особенность Python и одна из причин, почему код на Python так легко читать).

Отображения (view) обычно содержатся в файле **views.py**.

[Назад к Django](#django)

### Определение данных модели (models.py)

Веб-приложения Django обрабатывают и запрашивают данные через объекты Python, называемые моделями. Модели определяют структуру хранимых данных, включая типы полей и, возможно, их максимальный размер, значения по умолчанию, параметры списка выбора, текст справки для документации, текст меток для форм и т. д. Определение модели не зависит от используемой базы данных — ваши модели будут работать в любой из них. После того как вы выбрали базу данных, которую хотите использовать, вам не нужно напрямую обращаться к ней — вы просто пишете свою структуру модели и другой код, а Django выполняет всю «грязную работу» по обращению к базе данных за вас.

В приведённом ниже фрагменте кода показана очень простая модель Django для объекта `Team`. Класс `Team` наследуется от класса `models.Model`. Он определяет имя команды и командный уровень в качестве полей символов и задаёт максимальное количество символов, которые могут быть сохранены для каждой записи. `Team_level` может быть одним из нескольких значений, поэтому мы определяем его как поле выбора и предоставляем сопоставление между отображаемыми вариантами и хранимыми данными вместе со значением по умолчанию.
```py
# filename: models.py

from django.db import models

class Team(models.Model):
    team_name = models.CharField(max_length=40)

    TEAM_LEVELS = (
        ('U09', 'Under 09s'),
        ('U10', 'Under 10s'),
        ('U11', 'Under 11s'),
        ...  #список других командных уровней
    )
    team_level = models.CharField(max_length=3,choices=TEAM_LEVELS,default='U11')
```
> **Примечание:** Немного о Python:
> 
> Python поддерживает «объектно-ориентированное программирование», то есть стиль программирования, в котором мы организуем наш код в объекты, которые включают связанные данные и функции для работы с этими данными. Объекты также могут наследовать / расширять / выводить из других объектов, позволяя использовать одинаковое поведение между связанными объектами. В Python мы используем ключевое слово `class`, чтобы определить «скелет» для объекта. Мы можем создать несколько конкретных экземпляров типа объекта на основе модели в классе.
> 
> Так, например, мы имеем класс `Team`, который происходит от класса `Model`. Это означает, что эта модель будет содержать все методы модели, но мы также можем дать ей специализированные возможности. В нашей модели мы определяем поля нашей базы данных, в которой будем хранить данные, присваивая им конкретные имена. Django использует эти определения, включая имена полей, для создания основной базы данных.

[Назад к Django](#django)

### Запросы данных (views.py)

Модель Django предоставляет простой API запросов для поиска в базе данных. Поиск может осуществляться по нескольким полям одновременно, используя различные критерии (такие как exact («точный»), case-insensitive («без учёта регистра»), greater than («больше чем») и т. д.), и может поддерживать сложные выражения (например, вы можете указать поиск в командах U11, у которых есть имя команды, начинающееся с «Fr» или заканчивается на «al»).

Фрагмент кода показывает функцию view (обработчик ресурсов) для отображения всех команд U09. Выделенная жирным строка показывает, как мы можем использовать модель API-запросов для того, чтобы отфильтровать все записи, где поле `team_level` в точности содержит текст 'U09' (обратите внимание, как эти критерии передаются функции `filter()` в качестве аргумента с именем поля и типом соответствия, разделённым двойным подчёркиванием: **`team_level__exact`**).
```py
## filename: views.py

from django.shortcuts import render
from .models import Team

def index(request):
    list_teams = Team.objects.filter(team_level__exact="U09")
    context = {'youngest_teams': list_teams}
    return render(request, '/best/index.html', context)
```

Данная функция использует функцию `render()` для того, чтобы создать `HttpResponse`, который будет отправлен назад браузеру. Эта функция является *ярлыком*; она создаёт HTML-файл, комбинируя указанный HTML-шаблон и некоторые данные для вставки в шаблон (предоставляется в переменной с именем `«context»`). В следующем разделе мы покажем как данные вставляются в шаблон для создания HTML-кода.

[Назад к Django](#django)

### Вывод данных (HTML-шаблоны)

Системы шаблонов позволяют указать структуру выходного документа, используя заполнители для данных, которые будут вставлены при генерировании страницы. Шаблоны часто используются для создания HTML, но также могут создавать другие типы документов. Django «из коробки» поддерживает как собственную систему шаблонов, так и другую популярную библиотеку Python под названием Jinja2 (она также может быть использована для поддержки других систем, если это необходимо).

Фрагмент кода показывает, как может выглядеть HTML-шаблон, вызванный функцией `render()` из предыдущего раздела. Этот шаблон был написан с предположением, что во время отрисовки он будет иметь доступ к переменной списка, названной `youngest_teams` (содержащейся в контекстной переменной внутри функции `render()` выше). Внутри скелета HTML мы имеем выражение, которое сначала проверяет, существует ли переменная `youngest_teams`, а затем повторяет её в цикле `for`. При каждом повторе шаблон отображает значение `team_name` каждой команды в элементе `<li>`.
```html
## filename: best/templates/best/index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Home page</title>
</head>
<body>
  {% if youngest_teams %}
    <ul>
      {% for team in youngest_teams %}
        <li>{{ team.team_name }}</li>
      {% endfor %}
    </ul>
  {% else %}
    <p>No teams are available.</p>
  {% endif %}
</body>
</html>
```

[Назад к Django](#django)

### Что ещё можно сделать?

В предыдущих разделах показаны основные особенности, которые вы будете использовать почти в каждом веб-приложении: сопоставление URL-адресов, отображение, модели и шаблоны. Также Django предоставляет несколько других вещей:

- **Формы:** HTML-формы используются для сбора пользовательских данных для обработки на сервере. Django упрощает создание, проверку и обработку формы.
- **Аутентификация пользователя и разрешения:** Django включает надёжную систему аутентификации и авторизации пользователей, которая была построена с учётом безопасности.
- **Кеширование:** Создание динамического контента намного более интенсивно (и медленнее), чем обслуживание статического содержимого. Django обеспечивает гибкое кеширование, чтобы вы могли хранить всю или часть отображаемой страницы, для того, чтобы она не вызывалась повторно, за исключением случаев, когда это необходимо.
- **Админ-панель:** Административная панель в Django включена по умолчанию при создании приложения с использованием основного каркаса. Это упрощает управление админкой администраторам сайта для создания, редактирования и просмотра любых данных на вашем сайте.
- **Сериализация данных (преобразование в последовательную форму):** Django упрощает сериализацию и обслуживание ваших данных в таких форматах как XML или JSON. Это может быть полезно при создании веб-сервисов (веб-сайтов, которые исключительно служат для использования данных другими приложениями или сайтами и сами ничего не отображают) или при создании веб-сайта, на котором клиентский код обрабатывает весь рендеринг данных.

### Резюме

Поздравляем, вы завершили первый шаг в своём путешествии по Django! Теперь вы должны понимать основные преимущества Django, и примерно как может выглядеть каждая из основных частей приложения Django. Вы должны также изучить несколько вещей о языке программирования Python, включая синтаксис списков, функций и классов.

Вы уже видели код на Django выше, но в отличие от клиентского кода вам нужно настроить среду разработки для её запуска. Это наш следующий шаг.

[Назад к Django](#django)

## Setting up a Django development environment

Теперь, когда вы знаете, что такое Django, мы покажем вам, как настроить и протестировать среду разработки Django для Windows, Linux (Ubuntu) и Mac OS X - какую бы операционную систему вы не использовали, эта статья должна дать вам все, что необходимо для возможности начать разрабатывать приложения Django.

|Требования | Знание как открыть терминал / командную строку, как устанавливать программные пакеты в операционной системе вашего компьютера.
|-|--------
|Задача | Создать среду разработки для Django (1.10) и запустить её на вашем компьютере.

### Обзор среды разработки Django

В этом разделе объясняется, что входит в состав среды разработки, и даётся обзор некоторых параметров настройки и конфигурации. В оставшейся части статьи объясняется рекомендуемый метод установки среды разработки Django на Ubuntu, Mac OS X и Windows, и как вы можете её протестировать.

**Среда разработки** - это установка Django на вашем локальном компьютере, которую вы можете использовать для разработки и тестирования приложений Django до их развёртывания в производственной среде.

Основными инструментами, которые предоставляет сам Django, является набор скриптов Python для создания и работы с проектами Django, а также простой веб-сервер *разработки*, который можно использовать для тестирования локальных (то есть на вашем компьютере, а не на внешнем веб-сервере) веб-приложений Django на веб-браузере вашего компьютера.

Существуют и другие периферийные инструменты, являющиеся частью среды разработки, которые мы не будем освещать здесь. К ним относятся такие вещи, как текстовый редактор или IDE для редактирования кода, и инструмент управления исходным кодом, например Git, для безопасного управления различными версиями вашего кода. Мы предполагаем, что у вас уже установлен текстовый редактор.

[Назад к Django](#django)

### Разновидности установки Django

Django очень гибок с точки зрения способа и места установки и настройки. Django может быть:

- установлен на различных операционных системах,
- установлен из исходного кода, из Python Package Index (PyPi) и во многих случаях из любого менеджера пакетов,
- настроен на использование различных баз данных, которые должны быть установлены и настроены отдельно,
- запущен в основной системе окружения Python или в отдельном виртуальном окружении Python.
- Каждый из этих вариантов требует немного разной настройки и установки. Следующие подразделы объяснят некоторые аспекты вашего выбора. Далее мы покажем вам, как установить Django на некоторые операционные системы, и эта установка будет предполагаться на всём протяжении данного модуля.

> **Примечание:** Другие возможные способы установки можно найти в официальной документации Django. Мы ссылаемся на соответствующие документы.

- **Какие операционные системы поддерживаются?**

Веб-приложения Django можно запускать почти на любых машинах, которые поддерживают язык программирования Python 3, среди прочих: Windows, Mac OS X, Linux/Unix, Solaris. Почти любой компьютер имеет необходимую производительность для запуска Django во время разработки.

В этой статье мы предоставляем инструкции для Windows, Mac OS X, and Linux/Unix.

- **Какую версию Python стоит использовать?**

Мы рекомендуем использовать самую последнюю доступную версию - на момент написания статьи это Python 3.6.

> **Примечание:** Python 2.7 не может быть использован вместе с Django 2.0 (последние поддерживаемые серии для Python 2.7 - Django 1.11.x).

- **Откуда можно скачать Django?**

Для загрузки Django можно воспользоваться 3 источниками:

- The Python Package Repository (PyPi), при помощи инструмента pip. Это лучший способ получения последней стабильной версии Django.
- Использование версии из менеджера пакетов вашего компьютера. Такие дистрибутивы Django, собранные для конкретных операционных систем, предлагают знакомый механизм установки. Однако обратите внимание на то, что пакетные версии могут быть достаточно старыми и установлены только в системную среду Python (что может отличаться от ваших желаний).
- Установка из исходного кода. Вы можете получить и установить последний выпуск Django из исходного кода. Этот способ не рекомендован для новичков, но необходим в случае, когда вы готовы начать вносить собственный вклад в проект Django.

Данный материал описывает способ установки Django из PyPi с целью получения последней стабильной версии.

- **Какую базу данных выбрать?**

Django поддерживает 4 основных базы данных (PostgreSQL, MySQL, Oracle и SQLite), также есть публичные библиотеки, которые предоставляют разные уровни поддержки других SQL и NoSQL баз данных. Мы рекомендуем вам выбрать одинаковую БД для обеих рабочей и разрабатываемой сред (несмотря на то, что Django нивелирует множество различий баз данных при помощи Object-Relational Mapper (ORM), всё равно возможны потенциальные проблемы, которых лучше избегать.

Для данной статьи (и большей части модуля) мы будем использовать базу данных SQLite, которая сохраняет свои данные в файл. SQLite предназначен для использования в качестве облегчённой базы данных и не может поддерживать высокий уровень параллелизма. Это, однако, отличный выбор для приложений, которые в основном предназначены только для чтения.

> **Примечание:** Django сконфигурирован для использования SQLite по умолчанию, при создании вашего проекта с использованием стандартных инструментов (django-admin). Это отличный выбор для начала работы, потому что он не требует дополнительной настройки.

- **Глобальная установка или установка в виртуальную среду Python?**

Если вы устанавливаете Django в среду по умолчанию (глобальную), то будете способны сфокусироваться на одной версии Django на вашем компьютере. Это может быть проблемой в случае, если вы захотите создать новые веб-сайты (при помощи новой версии Django) во время поддержки веб-сайтов со старой версией.

По этой причине опытные разработчики Python / Django часто предпочитают вместо этого запускать свои приложения Python в независимых виртуальных средах Python. Это позволяет разработчикам иметь несколько разных сред Django на одном компьютере. Команда разработчиков Django сама рекомендует использовать виртуальные среды Python!

Этот модуль предполагает вашу установку Django в виртуальную среду, и мы покажем, как это сделать.

[Назад к Django](#django)

### Установка Python 3

Для использования Django вам необходимо установить Python 3 на свою операционную систему. Вам также понадобится инструмент [Python Package Index](https://pypi.python.org/pypi) — *pip3* — который используется для управления (установка, обновление и удаление) библиотек/пакетов Python, используемых Django и другими вашими приложениями Python.

Этот раздел коротко описывает то, как вы можете проверить имеющиеся версии и при необходимости установить новые для Ubuntu Linux 16.04, Mac OS X, and Windows 10.

> **Примечание:** В зависимости от платформы, вы можете иметь возможность установки Python/pip из собственного менеджера пакетов операционной системы или при помощи других инструментов. Для большинства платформ вы можете скачать необходимые установочные файлы из https://www.python.org/downloads/ и установить их при помощи соответствующего специфичного для платформы метода.

- **Ubuntu 16.04**

Ubuntu Linux включает в себя Python 3 по умолчанию. Вы можете удостовериться в этом, выполнив следующую команду в терминале:
```bash
python3 -V
 Python 3.5.2
```

Однако, инструмент Python Package Index, при помощи которого вам нужно будет установить пакеты для Python 3 (включая Django), по умолчанию не установлен. Вы можете установить pip3 через терминал bash при помощи:
```bash
sudo apt-get install python3-pip
```

- **Mac OS X**

Mac OS X "El Capitan" не включает Python 3. Вы можете удостовериться в этом, выполнив следующую команду в терминале:
```bash
python3 -V
 -bash: python3: command not found
```

Вы можете легко установить Python 3 (вместе с инструментом pip3) с [python.org](https://www.python.org/):

1. Скачайте нужный установочный файл:
   - Перейдите в https://www.python.org/downloads/
   - Нажмите на кнопку **Скачать Python 3.6.4** (точная основная версия может отличаться).
2. Найдите файл при помощи *Finder*, дважды кликните по нему и следуйте подсказкам по установке.

Удостовериться в успешной установке вы можете проверкой на наличие Python 3, как показано ниже:
```bash
python3 -V
 Python 3.5.20
```

Подобным образом вы можете проверить установку pip3, отобразив список доступных пакетов:
```bash
pip3 list
```

- **Windows 10**

Windows не включает Python по умолчанию, но вы можете легко установить его (вместе с инструментом pip) с [python.org](https://www.python.org/):

1. Скачайте нужный установочный файл:
    - Перейдите в https://www.python.org/downloads/
    - Нажмите на кнопку **Скачать Python 3.6.4** (точная основная версия может отличаться).
2. Установите Python, дважды кликнув на скачанный файл и следуя инструкциям по установке.

После этого вы сможете подтвердить успешную установку Python путём выполнения следующего текста в командной строке:
```bash
py -3 -V
 Python 3.5.2
```

Установщик Windows включает в себя pip3 (менеджер пакетов Python) по умолчанию. Вы можете отобразить список установленных пакетов, как показано далее:
```bash
pip list
```

> **Примечание:** Установщик должен сделать все, что необходимо для корректной работы указанной команды. Однако, если вы видите сообщение о том, что Python не может быть найден, вам может потребоваться добавить его в системный путь.

[Назад к Django](#django)

### Использование Django внутри виртуальной среды Python

Для создания виртуальных сред мы будем использовать библиотеки [virtualenvwrapper](https://virtualenvwrapper.readthedocs.io/en/latest/index.html) (Linux и macOS X) и [virtualenvwrapper-win](https://pypi.python.org/pypi/virtualenvwrapper-win) (Windows), которые в свою очередь обе используют инструмент [virtualenv](https://github.com/mdn/archived-content/tree/main/files/en-us/mozilla/virtualenv). Инструмент обёртки предоставляет совместимый интерфейс для управления интерфейсами на всех платформах.

### Установка ПО виртуальной среды

- **Установка виртуальной среды для Ubuntu**

После установки Python и pip вы можете установить *virtualenvwrapper* (который включает в себя *virtualenv*). Вы можете либо воспользоваться официальной инструкций по установке [отсюда](http://virtualenvwrapper.readthedocs.io/en/latest/install.html), либо следовать следующим инструкциям:

Установите инструмент при помощи pip3:
```bash
sudo pip3 install virtualenvwrapper
```

Затем добавьте следующие строки в конец файла загрузки программной оболочки (shell) (это скрытый файл в вашей домашней директории с именем **.bashrc**). Они устанавливают расположение виртуальных сред, расположение каталога разрабатываемого проекта и расположение установленного с этим пакетом скрипта.
```bash
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
export VIRTUALENVWRAPPER_VIRTUALENV_ARGS=' -p /usr/bin/python3 '
export PROJECT_HOME=$HOME/Devel
source /usr/local/bin/virtualenvwrapper.sh
```

Затем перезагрузите файл загрузки, выполнив в терминале следующую команду:
```bash
source ~/.bashrc
```

В этот момент вы должны увидеть запуск группы скриптов, как показано ниже:
```bash
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/premkproject
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/postmkproject
...
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/preactivate
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/postactivate
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/get_env_details
```

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualenv`.

- **Установка виртуальной среды для macOS X**

Установка *virtualenvwrapper* на macOS X почти идентична Ubuntu (и снова вы можете воспользоваться либо [официальными](http://virtualenvwrapper.readthedocs.io/en/latest/install.html), либо следующими инструкциями).

Установите инструмент при помощи *pip3*:
```bash
sudo pip3 install virtualenvwrapper
```

Затем добавьте следующие строки в конец вашего файла загрузки программной оболочки:
```bash
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
export PROJECT_HOME=$HOME/Devel
source /usr/local/bin/virtualenvwrapper.sh
```

> **Примечание:** Переменная `VIRTUALENVWRAPPER_PYTHON` указывает на обычное расположение Python3. Если virtualenv не работает во время тестирования, то вам следует проверить, находится ли интерпретатор Python в нужном расположении (и затем поменять его соответствующим образом в значении переменной).

Эти строки такие же, как в случае с Ubuntu, но файл загрузки в вашей домашней директории назван иначе - **.bash_profile**.

> **Примечание:** Если вы не можете найти и изменить .bash_profile при помощи Finder, то можно также открыть его при помощи редактора терминала nano.
>
> Команды в этом случае выглядят примерно так:
> ```bash
> cd ~ # Navigate to my home directory
> ls -la #List the content of the directory. You should see .bash_profile
> nano .bash_profile # Open the file in the nano text editor, within the terminal
> # Scroll to the end of the file, and copy in the lines above
> # Use Ctrl+X to exit nano, Choose Y to save the file.
> ```

После этого перезагрузите файл загрузки путём выполнения следующей команды в терминале:
```bash
source ~/.bash_profile
```

В этот момент вы должны увидеть запуск группы скриптов (те же скрипты, что и в случае установки на Ubuntu).

Теперь вы должны иметь возможность создания новой виртуальной среды при помощи команды `mkvirtualenv`.

- **Установка виртуальной среды для Windows 10**

Установка [virtualenvwrapper-win](https://pypi.python.org/pypi/virtualenvwrapper-win) ещё более проста, чем установка *virtualenvwrapper*, потому что вам не нужно настраивать расположения сохранения информации о виртуальной среде инструментом (эти значения заданы по умолчанию). Все, что вам нужно сделать, это запустить следующую команду в командной строке:
```bash
pip3 install virtualenvwrapper-win
```

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualen`.

[Назад к Django](#django)

### Создание и использование виртуальной среды

После установки *virtualenvwrapper* и *virtualenvwrapper-win* работа с виртуальными средами становится одинаковой для всех платформ.

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualenv`. Во время запуска команды вы увидите установку виртуальной среды (конкретные результаты команды очень зависят от платформы). После выполнения команды активируется новая виртуальная среда — заметить это вы можете по тому, что началом ввода будет название виртуальной среды в круглых скобках (как показано ниже).
```bash
$ mkvirtualenv my_django_environment
Running virtualenv with interpreter /usr/bin/python3 ...
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/t_env7/bin/get_env_details
(my_django_environment) ubuntu@ubuntu:~$
```

Теперь вы находитесь внутри виртуальной области и можете установить Django и начать разработку.

> **Примечание:** С этого момента в этой статье (и всем модуле) пожалуйста учитывайте, что любые команды запускаются в виртуальной среде Python, как та, что мы показали выше.

- **Использование виртуальной среды**

Есть ещё несколько полезных команд, которые вам следует знать (в документации по инструменту их гораздо больше, но эти вы будете использовать регулярно):

- `deactivate` — Выход из текущей виртуальной среды Python
- `workon` — Список доступных виртуальных сред
- `workon name_of_environment` — Активация конкретной виртуальной среды Python
- `rmvirtualenv name_of_environment` — Удаление конкретной виртуальной среды.

[Назад к Django](#django)

### Установка Django, проверка установки

После создания виртуальной среды и вызова `workon` для входа в неё вы можете использовать *pip3* для установки Django.
```bash
pip3 install django
```

Вы можете проверить установку Django, выполнив следующую команду (она просто проверяет, что Python может найти модуль Django):
```bash
# Linux/Mac OS X
python3 -m django --version
 1.10.10

# Windows
py -3 -m django --version
 1.10.10
```

> **Примечание:** Для Windows вы запускаете скрипты Python 3 с префиксом команды py -3, в то время как для Linux/Mac OSX префикс - python3.

>> **Предупреждение: Важно:** В оставшейся части материала используется вариант команды Linux для вызова Python 3 (python3) . Если вы работаете в Windows, то просто замените этот префикс на: py -3

- **Проверка вашей установки**

Указанная выше проверка работает, но не представляет особого интереса. Более интересная проверка заключается в создании шаблона проекта и проверки его работы. Для её выполнения перейдите в командной строке/терминале в место, где планируете сохранять приложения Django. Создайте папку для теста и перейдите в неё.
```bash
mkdir django_test
cd django_test
```

Затем вы можете создать шаблон сайта *"mytestsite"* при помощи инструмента **django-admin**. После создания сайта вы можете перейти в папку, где найдёте основной скрипт для управления проектами с именем **manage.py**.

```bash
django-admin startproject mytestsite
cd mytestsite
```

Мы можем запустить веб-сервер разработки из этой папки при помощи **manage.py** и команды `runserver`, как показано ниже.
```bash
$ python3 manage.py runserver
Watching for file changes with StatReloader
Performing system checks…

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
March 01, 2022 - 01:19:16
Django version 4.0.2, using settings 'mytestsite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

> **Примечание:** Указанная команда демонстрирует выполнение для Linux/Mac OS X. В настоящий момент вы можете проигнорировать предупреждения о "13 непримененных миграциях"!

Как только сервер запущен, вы можете посмотреть сайт, перейдя по следующему адресу в вашем браузере: `http://127.0.0.1:8000/`. Вы должны увидеть, что сайт выглядит следующим образом:

![Django site](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/development_environment/django_skeleton_website_homepage.png)

### Заключение
Теперь у вас на компьютере установлена и запущена среда разработки Django.

В разделе проверки вам коротко был показан способ создания нового сайта на Django при помощи `django-admin startproject` и его запуск в вашем браузере при помощи веб-сервера разработки (`python3` `manage.py` `runserver`). В следующей статье мы подробнее рассмотрим этот процесс создания простого, но полноценного веб-приложения.

[Назад к Django](#django)

## Django: сайт местной библиотеки

Первая статья в цикле объясняет и разбирает пример сайта "местная библиотека".

|Необходимо: | Прочитайте [вступление](#введение). Для последующих статей вам так же потребуется настроить [среду разработки](#создание-и-использование-виртуальной-среды).
|---|--- 
|Цель: | Представить читателю пример веб-приложения, которое будет использоваться в нашем руководстве и показать, какие темы будут изучены в этом цикле статей.

### Обзор руководства
Добро пожаловать на руководство MDN "Сайт местной библиотеки" по фреймворку Django, который может использоваться для управления архивом библиотеки.

В цикле статей мы научимся:

- При помощи Django создавать прототип сайта.
- Запускать и останавливать сервер для разработки.
- Создавать модели для представления данных.
- Использовать админ-панель Django для управления сайтом
- Создавать представления для того, чтобы формировать из данных ответы на различные запросы и превращать их в HTML разметку, которая будет отображаться в браузере.
- Создавать маршруты, чтобы определённые URL адреса ассоциировались сервером с определёнными представлениями
- Создавать авторизацию пользователей и сессии, чтобы управлять доступом к сайту.
- Работать с формами.
- Тестировать ваше веб-приложение.
- Эффективно использовать средства безопасности Django.
- Размещать ваш сайт в Сети.

С некоторыми темами вы уже сталкивались, а про некоторые только знаете, что они существуют. По окончанию цикла статей вы должны будете иметь достаточно знаний, чтобы разрабатывать несложные сайты на Django для своих целей.

### Сайт местной библиотеки

Это название сайта, который мы создадим и будем улучшать, в течение этого цикла статей. Как можно догадаться, цель этого сайта в том, чтобы представить небольшой онлайн каталог маленькой местной библиотеки, где пользователи смогут загружать доступные книги и управлять своими профилями.

Этот пример был выбран потому, что его можно масштабировать, чтобы рассказать настолько детально или поверхностно, насколько это требуется, о почти любой особенности Django. Что более важно, этот пример позволяет показать последовательный путь по самым важным функциям фреймворка Django:

- В самом начале, мы создадим библиотеку, в которой пользователи смогут только просматривать доступные книги. Это позволит нам исследовать операции, которые присутствуют почти на каждом сайте: чтение и отображение информации из базы данных.
- По мере продвижения, на сайте станут использоваться более продвинутые возможности Django. Например, мы сможем расширить библиотеку и позволить пользователям резервировать книги, чтобы показать как использовать формы и авторизацию.

Несмотря на то, что это довольно обширный пример, проект называется сайтом местной библиотеки потому, что мы надеемся показать минимум достаточной информации, которая поможет вам быстро научиться разрабатывать на Django. Поэтому мы будем хранить данные о книгах, копиях книг, авторах и другую ключевую информацию. Однако мы не будем хранить другую информацию, которая могла бы быть полезной библиотеке, или создавать обширную инфраструктуру для поддержки нескольких сайтов библиотек или другие особенности "крупных библиотек".

- **Я застрял, где мне взять код?**

По мере усложнения руководства, мы будем предоставлять необходимый код, который можно скопировать и вставить, а так же будет и другой код, который, мы надеемся, вы улучшите самостоятельно.

Если вы застряли, то можете найти полноценную версию сайта на [Github](https://github.com/mdn/django-locallibrary-tutorial).

- **Подводя итоги**

Теперь вы знаете чуть больше о сайте, который мы будем разрабатывать, и теперь самое время создать скелет нашего сайта.

[Назад к Django](#django)

## Django 2: создание скелета

Это вторая статья из нашего [руководства по Django](#django-сайт-местной-библиотеки), которая показывает, как можно создать "скелет" сайта, как фундамент, на котором можно строить всё остальное: настройки, ссылки, модели, контроллеры и представления.

|Необходимо: |[Настройка окружения](#setting-up-a-django-development-environment). Прочитать первую статью [руководства по Django](#django-сайт-местной-библиотеки).
|----|----
|Цель: |Научиться использовать инструменты Django для создания новых веб-сайтов.

### Обзор

Эта статья показывает, как можно создать "скелет"(прототип) сайта, который затем можно расширить при помощи различных настроек, url адресов, моделей, представлений, и шаблонов (эти темы будут объясняться в последующих статьях).

Алгоритм следующий:

1. Использовать `django-admin` для создания папки проекта, шаблонов остальных файлов, и скрипта для управления проектом (**manage.py**).

2. Использовать **manage.py** для *создания одного или нескольких* приложений.

> **Примечание:** Сайт может состоять из одной или нескольких различных частей, например: основная часть, блог, вики, раздел загрузок, и так далее. Философия Django подталкивает разработчиков создавать эти части, как разные **приложения**, которые, если понадобится, могут быть использованы повторно в других проектах.

3. Зарегистрировать в настройках эти приложения, чтобы использовать их в проекте.

4. Настроить маршруты url адресов для каждого из приложений.

Для [Сайта местной библиотеки](#django-сайт-местной-библиотеки) папка сайта и проекта будет называться *locallibrary*, и у нас будет одно приложение с названием *catalog*. Верхняя структура проекта будет следующей:
```bash
locallibrary/         # Папка сайта
    manage.py         # Скрипт для управления проектов (создан manage.py)
    locallibrary/     # Папка сайта/проекта (создана manage.py)
    catalog/          # Папка приложения (также создана manage.py)
```

Следующие разделы статьи разложат по полочкам этапы создания "скелета", и покажут вам, как можно проверить сделанные изменения. В конце статьи мы обсудим некоторые другие настройки сайта, которые можно назначить на этом этапе.

[Назад к Django](#django)

### Создание проекта

Для начала откройте командную строку/терминал, перейдите в ту папку, куда вы хотите поместить проект Django(лучше в папке профиля пользователя `C:\Users\user_name`, при запуске командной строки используется именно эта директория), и создайте папку для вашего нового сайта (в данном случае: *locallibrary*). Затем войдите в эту папку, используя команду cd:
```bash
mkdir locallibrary
cd locallibrary
```

Создайте новую папку, используя команду `django-admin startproject` как в примере ниже, и затем зайдите в созданную папку.
```bash
  django-admin startproject locallibrary .
cd locallibrary
```

Команда `django-admin` создаст файловую структуру, как в примере ниже:
```bash
locallibrary/
    manage.py
    locallibrary/
        settings.py
        urls.py
        wsgi.py
```

Подпапка проекта *locallibrary* это ключевая директория нашего проекта:

- **settings.py** содержит в себе все настройки проекта. Здесь мы регистрируем приложения, задаём размещение статичных файлов, настройки базы данных и так далее.
- **urls.py** задаёт ассоциации url адресов с представлениями. Несмотря на то, что этот файл может содержать все настройки url, обычно его делят на части, по одной на приложение, как будет показано далее.
- **wsgi.py** используется для налаживания связи между вашим Django приложением и веб-сервером. Вы можете воспринимать его, как утилиту.

Скрипт **manage.py** используется для создания приложений, работы с базами данных и для запуска отладочного сервера.

[Назад к Django](#django)

### Создание приложения Каталог

Выполнив предыдущие шаги, запустите следующую команду для создания приложения *catalog*, который будет размещён внутри папки locallibrary (команду необходимо выполнять из папки, в которой находится **manage.py**):
```bash
python3 manage.py startapp catalog
```

> **Примечание:** Приведённая выше команда справедлива для GNU Linux/Mac OS. На Windows команда должна иметь вид: `py -3 manage.py startapp catalog`
>
>Если вы работаете под Windows, заменяйте команду `python3` на `py -3` в этой и следующих статьях.

Эта команда создаст новую папку и наполнит её файлами различных частей приложения (выделенные **полужирным** ниже). Большинство файлов названы, исходя из их назначения (например контроллеры(views) должны находится во **views.py**, модели в **models.py**, тесты в **tests.py**, настройки административной части в **admin.py**, регистрация приложения в **apps.py**) и уже содержат некоторый шаблонный код для работы с вышеназванными объектами.

Обновлённая директория должна выглядеть следующим образом:
```bash
locallibrary/
    manage.py
    locallibrary/
    catalog/
        admin.py
        apps.py
        models.py
        tests.py
        views.py
        __init__.py
        migrations/
```

Кроме перечисленных выше файлов были созданы:

- Папка *migrations* используется, чтобы хранить"миграции" — файлы, которые позволяют вам автоматически обновлять базу данных по мере изменения моделей.
- `__init__.py` — пустой файл для того, чтобы Django и Python распознавали папку как [Python модуль](https://docs.python.org/3/tutorial/modules.html#packages) и позволяет нам использовать его объекты внутри других частей проекта.
> **Примечание:** Заметили, что некоторых файлов не хватает? В то время, как там нашли себе место файлы для контроллеров(views) и моделей(models), файлов для настройки url соотносителя, шаблонов, и статичных файлов создано не было. Далее мы покажем, как их создать (они не обязательны для каждого сайта, но нужны в данном примере).

[Назад к Django](#django)

### Регистрация папки с приложением

После создания приложения, нам нужно зарегистрировать его в проекте, чтобы различные утилиты затрагивали его своим действием (например при добавлении моделей в базу данных). Приложения регистрируются добавлением их названий в список `INSTALLED_APPS` в настройках проекта(который, как мы помним, называется **settings.py**).

Откройте файл **locallibrary/locallibrary/settings.py** и найдите в нём список `INSTALLED_APPS`. Затем добавьте новую строку в конец списка, как показано ниже.
```bash
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'catalog.apps.CatalogConfig',
]
```

Новая строка указывает на файл конфигурации приложения (`CatalogConfig`), который был создан в **/locallibrary/catalog/apps.py**, когда вы создали приложение.

Примечание: Легко заметить, что в `INSTALLED_APPS` уже подключено большое количество приложений (и объектов `MIDDLEWARE`, ниже в файле конфигурации). Они добавляют поддержку [админ-панели Django](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site) и, как следствие, огромное количество функциональности (включая сессии, аутентификацию и прочее).

[Назад к Django](#django)

### Настройка базы данных

На этом шаге обычно указывают базу данных для будущего проекта — имеет смысл использовать для разработки и размещённого в Сети одну и ту же базу данных, по возможности, чтобы исключить различия в поведении. Про различные варианты вы можете прочитать в документации Django в разделе [Базы данных](#базы-данных).

Мы будем использовать базу данных SQLite для этого проекта, потому что не предполагаем большое количество одновременных запросов на неё, а ещё потому, что для её настройки совсем не надо ничего делать! Вы можете видеть, что база данных уже настроена в **settings.py** (подробная информация указана ниже):
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
```

Так как мы используем SQLite, то нам не нужно ничего делать.

[Назад к Django](#django)

### Другие настройки проекта

Файл **settings.py** так же применяется и для некоторых других настроек, но на данном шаге имеет смысл поменять разве что [TIME_ZONE](https://docs.djangoproject.com/en/1.10/ref/settings/#std:setting-TIME_ZONE) — это значение должно быть представлено строкой, указанной в [списке часовых поясов tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (колонка TZ в таблице, в строке временной зоны, которая вам нужна). Измените `TIME_ZONE` на одну из строк из таблицы, которая отвечает вашему часовому поясу. Например:
```python
TIME_ZONE = 'Asia/Bishkek'
```

В файле присутствует две настройки, которые не нужно менять сейчас, но о назначении которых следует знать:

- `SECRET_KEY`. Это секретный ключ, который используется Django для поддержки безопасности сайта. Если вы раскроете этот ключ в процессе разработки кому-либо, то необходимо будет его сменить (возможно считать его с какого-либо файла на сервере или переменной окружения) когда будете размещать проект на сервер.
- `DEBUG`. Включает подробные сообщения об ошибках, вместо стандартных HTTP статусов ответов. Должно быть изменено на `False` на сервере, так как эта информация очень много расскажет взломщикам.

[Назад к Django](#django)

### Подключение URL-адреса

При создании сайта, был создан файл сопоставления URL (**urls.py**) в корне проекта. Хотя можно использовать его для обработки всех URL адресов, более целесообразно подключать отдельные файлы сопоставлений для каждого приложения.

Откройте **locallibrary/locallibrary/urls.py** и обратите внимание на закомментированный текст, который объясняет суть происходящего.
```python
"""
locallibrary URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/1.10/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.conf.urls import url, include
    2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
"""
from django.urls import path
from django.contrib import admin

urlpatterns = [
    path('admin/', admin.site.urls),
]
```

URL соотношения хранятся в переменной `urlpatterns`, которая является списком функций `path()`. Каждая `path()` функция или ассоциирует шаблон URL_ *с контроллером(views) или же его с другим таким списком (во втором случае, первый URL становится "базовым" для других, которые определяются в дочернем списке). Список `urlpatterns` инициализирует список функции, которая, например, соотносит _admin/* с модулем `admin.site.urls` , который содержит собственный файл-соотноситель.

Добавьте строчки, приведённые ниже в низ файла **urls.py**, чтобы добавить новый элемент в список `urlpatterns`. Этот элемент содержит `url()` который направляет запросы с URL `catalog/` к модулю `catalog.urls` (файл с относительным путём **/catalog/urls.py**).
```python
# Используйте include() чтобы добавлять URL из каталога приложения
from django.urls import include
from django.urls import path
urlpatterns += [
     path('catalog/', include('catalog.urls')),
]
```

Теперь давайте перенаправим корневой URL нашего сайта (например `127.0.0.1:8000`) на URL `127.0.0.1:8000/catalog/`; это единственное приложение, которое мы собираемся использовать, поэтому это вполне разумно. Чтобы это использовать, нам понадобится специальная функция (`RedirectView`), которая принимает первым параметром новый относительный URL на который следует перенаправлять (`/catalog/`) когда указанный в функции `url()` адрес соотносится с адресом запроса (корневой URL, в данном случае).

Добавьте следующие строчки, тоже в конец файла:
```python
# Добавьте URL соотношения, чтобы перенаправить запросы с корневого URL, на URL приложения
from django.views.generic import RedirectView
urlpatterns += [
    path('', RedirectView.as_view(url='/catalog/', permanent=True)),
]
```

Django не размещает статические файлы(CSS, JavaScript, и изображения) по умолчанию, но это было бы крайне полезно на этапе разработки нашего сайта. В самом конце нашего URL соотносителя, можно включить размещение статических файлов.

Добавьте последнюю часть в конец файла:
```py
# Используйте static() чтобы добавить соотношения для статических файлов
# Только на период разработки
from django.conf import settings
from django.conf.urls.static import static

urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

> **Примечание:** Существуют различные способы дополнения списка `urlpatterns` (в примере мы просто добавляли объект, используя оператор `+=` чтобы чётко разделить изначальный и дописанный код). Вместо этого, мы могли бы добавить соотношения внутрь определения переменной:
>```py
>urlpatterns = [   path('admin/', admin.site.urls),
>path('catalog/', include('catalog.urls')),path('',
>RedirectView.as_view(url='/catalog/', permanent=True)), ] +
>static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
>```
>Кроме того, мы добавили import вниз файла (`from django.urls import include`) ,чтобы видеть, что мы добавили, но обычно все инструкции import добавляются в верхнюю часть файла.

Напоследок, создайте файл **urls.py** внутри папки **catalog**, и добавьте следующий код, чтобы определить (пустой) `urlpatterns`. Сюда мы будем добавлять наши URL соотношения, по мере разработки сайта.
```python
from django.urls import path
from . import views

urlpatterns = [

]
```

[Назад к Django](#django)

### Тестирование работы скелета

На этом, мы создали прототип сайта. Пока сайт ничего не умеет делать, но стоит запустить его, чтобы убедиться, что мы ничего не сломали.

До этого, нам предстоит впервые запустить *миграцию базы данных*. Это обновит нашу базу данных и добавит туда необходимые модели (и уберёт некоторые предупреждения, которые были бы показаны при попытке запуска).

- **Запуск миграций базы данных**

Django использует **Объектный Соотноситель Связей (ORM)** чтобы соотносить определения моделей в Django приложении со структурами данных, которые используются базой данных. Когда мы меняем наши модели, Django отслеживает изменения и может создать файлы миграций (в папке **/locallibrary/catalog/migrations/**) чтобы применить соответствующие структуры данных к базе, чтобы та соответствовала модели.

При создании сайта, Django автоматически добавил несколько моделей, чтобы мы могли их использовать в админ-панели (о которой мы поговорим позже). Выполните следующие команды, чтобы создать нужные таблицы в базе данных, соответствующие этим моделям (убедитесь, что вы находитесь в папке с **manage.py**):
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

> **Предупреждение:** Необходимо выполнять команды выше каждый раз, когда вы меняете модели таким образом, что структура таблицы изменится(включая добавления и удаления как отдельных полей, так и целых моделей).

Команда `makemigrations` *создаёт* (но не применяет) миграции для всех приложений, которые установлены в ваш проект (вы так же можете указать в конце имя конкретного приложения, чтобы создать миграции только для него). Это даёт вам возможность проверить код перед тем, как их применить — когда вы станете хорошо разбираться в Django, то сможете даже менять их!

Команда `migrate` применяет созданные миграции к базе (Django отслеживает, какие миграции были созданы для данной базы).

> **Примечание:** Посмотрите раздел [Миграции](https://docs.djangoproject.com/en/2.2/topics/migrations/) в документации Django чтобы получить информацию о менее распространённых командах для управления миграциями.

[Назад к Django](#django)

### Запуск сайта

Во время разработки, вы можете проверить свой сайт, разместив его на *встроенном отладочном сервере*, и просмотрев его в своём браузере.

> **Примечание:** Отладочный веб-сервер не настолько функционален и производителен, для постоянного размещения , но это самый простой способ запустить свой сайт на Django и проверить его на наличие ошибок. По умолчанию, он разместит сайт на вашем компьютере (`http://127.0.0.1:8000/`), но вы так же можете указать различные компьютеры в вашей сети для этой цели. Для получения большего количества информации загляните в раздел [django-admin и manage.py: отладочный сервер](https://docs.djangoproject.com/en/2.2/ref/django-admin/) документации Django.

Запустите веб-сервер, используя команду `runserver` (в той же папке, что и **manage.py**):
```bash
python3 manage.py runserver

 Performing system checks...

 System check identified no issues (0 silenced).
 September 22, 2016 - 16:11:26
 Django version 1.10, using settings 'locallibrary.settings'
 Starting development server at http://127.0.0.1:8000/
 Quit the server with CTRL-BREAK.
```

Когда сервер запустится, вы сможете посетить сайт по адресу `http://127.0.0.1:8000/` в вашем веб-браузере. Вы должны увидеть страницу с ошибкой, навроде этой:

![/catalog/](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/skeleton_website/django_404_debug_page.png)

Не волнуйтесь! Эта страница должна появиться и сообщить нам, что мы ещё не настроили ни одной страницы в модуле `catalogs.urls` (на который мы были перенаправлены запросили корневой URL сайта).

> **Примечание:** Показанная выше страница открывает нам одно из замечательных свойств Django — автоматические отчёты об ошибках. На экране с ошибкой отображается множество полезной информации, когда страница не найдена, или ошибка была вызвана кодом. В данном случае, мы видим, что запрошенный URL не соответствует ни одному шаблону (из указанных). Подобные отчёты будут выключены при DEBUG=False (когда мы разместим приложение в Сеть), в этом случае будет показана менее информативная, но более дружелюбная к пользователю страница(которую вам надо будет создать - прим. переводчика).

На данном этапе, мы поняли, что Django работает должным образом!

> **Примечание:** Вам следует перезапускать миграцию и заново тестировать сайт, после того как вы делаете важные изменения. Поверьте, это не займёт много времени!

- **Домашнее задание**

Папка **catalog/** содержит файлы контроллеров(views), моделей(models), и других частей приложения. Просмотрите эти файлы.

Как было написано выше, URL соотноситель для админ-панели был подключён в файле **urls.py**. Войдите в административную часть и посмотрите, что произойдёт (вы можете найти URL из соотношения выше).

- **Подводя итоги**

Теперь вы создали полноценный скелет веб-приложения, который теперь вы можете расширить url соотносителями, контроллерами(views) и моделями(models).

Теперь скелет [Сайта местной библиотеки](#django-сайт-местной-библиотеки) сделан и запущен, теперь самое время начать писать код, который научит сайт делать то, что он должен делать.

- **Смотрите также**

- [Пишем своё первое приложение на Django - часть 1](https://docs.djangoproject.com/en/2.2/intro/tutorial01/) (документация Django)
- [Приложения](https://docs.djangoproject.com/en/2.2/ref/applications/) (документация Django). содержит информацию о настройке приложений.

[Назад к Django](#django)

## Django 3: использование моделей

В этой статье показано, как определить модели для [LocalLibrary](#django-сайт-местной-библиотеки) сайта. Она объясняет, что такое модель, как она объявляется, и некоторые из основных типов полей. В ней также кратко показаны некоторые из основных способов доступа к данным модели.

|Предпосылки |[Django Tutorial Part 2: Creating a skeleton website](#django-2-создание-скелета).
|-----|----
|Задача: |Научиться проектировать и создавать свои собственные модели, выбирая подходящие поля.

### Обзор

Веб-приложения Django получают доступ и управляют данными через объекты Python, называемые моделями. Модели определяют структуру хранимых данных, включая типы полей и, возможно, их максимальный размер, значения по умолчанию, параметры списка выбора, текст справки для документации, текст меток для форм и т. д. Определение модели не зависит от основной базы данных - вы можете выбрать один из нескольких компонентов вашей настройки проекта. После того, как вы выбрали какую базу данных хотите использовать, вам не нужно напрямую работать с ней - вы просто пишете свою структуру модели и код, а Django делает всю грязную работу, связанную с базой данных за вас.

В этом учебнике показано, как определить и получить доступ к моделям на примере [LocalLibrary website](#django-сайт-местной-библиотеки).

### Проектирование моделей LocalLibrary

Перед тем, как вы начнёте программировать модели, стоит потратить несколько минут, чтобы подумать о том, какие данные нам нужно хранить, и о взаимоотношениях между разными объектами.

Мы знаем, что нам нужно хранить информацию о книгах (название, резюме, автор, язык, на котором написана книга, категория, ISBN) и что у нас может быть несколько доступных экземпляров (с уникальным глобальным идентификатором, статусом доступности и т. Д.). Нам может потребоваться хранить больше информации об авторе, чем просто их имя, и могут быть несколько авторов с одинаковыми или похожими именами. Мы хотим иметь возможность сортировать информацию на основе названия книги, автора, письменного языка и категории.

При проектировании ваших моделей имеет смысл иметь отдельные модели для каждого «объекта» (группа связанной информации). В этом случае очевидными объектами являются книги, экземпляры книг и авторы.

Вы также можете использовать модели для представления параметров списка выбора (например, как выпадающий список вариантов), вместо жёсткого кодирования выбора на самом веб-сайте - это рекомендуется, когда все варианты неизвестны заранее или могут измениться. Очевидные кандидаты на модели в этом случае включают жанр книги (например, «Научная фантастика», «Французская поэзия» и т. д.) И язык (английский, французский, японский).

Как только мы определились с нашими моделями и полями, нам нужно подумать об отношениях. Django позволяет вам определять отношения, как один к одному (`OneToOneField`), один ко многим (`ForeignKey`) и многие ко многим (`ManyToManyField`).

Диаграмма ассоциации UML, приведённая ниже показывает модели, которые мы определили в этом случае (в виде блоков). Как и выше, мы создали модели для книги (общие сведения о книге), экземпляр книги (статус конкретных физических копий книги, доступных в системе) и автора.Мы также решили создать модель для жанра, чтобы можно было создавать / выбирать значения через интерфейс администратора. Мы решили не иметь модель для BookInstance: status - мы жёстко закодировали значения (LOAN_STATUS), потому что мы не ожидаем их изменения. В каждом из полей вы можете увидеть имя модели, имена и типы полей, а также методы и их типы возврата.

На диаграмме также показаны зависимости между моделями, включая их *множители*. Множители представляют собой числа на диаграмме, показывающие минимум и максимум единиц каждой модели, которые могут присутствовать в этой связи. Например, соединительная линия между ящиками показывает, что книга и жанр связаны между собой. Цифры, близкие к модели жанра, показывают, что у книги может быть один или несколько жанров (сколько угодно), а числа на другом конце строки рядом с моделью книги показывают, что у жанра может быть ноль или более связанных книг.

![diargam](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Models/local_library_model_uml.png)

> **Примечание:** В следующем разделе приведён базовый пример, поясняющий, как модели определяются и используются. Когда вы его прочитаете, подумайте, как мы построим каждую из моделей на диаграмме выше.

[Назад к Django](#django)

### Модель для начинающих

В этом разделе представлен краткий обзор того, как определяется модель, и некоторые из наиболее важных полей и аргументы поля.

### Определение модели

Модели обычно определяются в приложении **models.py**. Они реализуются как подклассы `django.db.models.Model`, и могут включать поля, методы и метаданные. В приведённом ниже фрагменте кода показана «типичная» модель, названная `MyModelName`:
```py
from django.db import models
from django.urls import reverse

class MyModelName(models.Model):
    """Типичный класс модели, производный от класса Model."""

    # Поля
    my_field_name = models.CharField(max_length=20, help_text='Введите описание поля')
    # …

    # Метаданные
    class Meta:
        ordering = ['-my_field_name']

    # Methods
    def get_absolute_url(self):
        """Возвращает URL-адрес для доступа к определенному экземпляру MyModelName."""
        return reverse('model-detail-view', args=[str(self.id)])

    def __str__(self):
        """Строка для представления объекта MyModelName (например, в административной панели и т.д.)."""
        return self.my_field_name
```

В следующих разделах мы подробно рассмотрим каждый элемент внутри модели:

### Поля

Модель может иметь произвольное количество полей любого типа - каждый представляет столбец данных, который мы хотим сохранить в одной из наших таблиц базы данных. Каждая запись (строка) базы данных будет состоять из одного значения каждого поля. Давайте рассмотрим приведённый выше пример:
```py
my_field_name = models.CharField(max_length=20, help_text="Введите описание поля")
```

Наш вышеприведённый пример имеет одно поле, называемое `my_field_name`, типа `models.CharField` — что означает, что это поле будет содержать строки буквенно-цифровых символов. Типы полей назначаются с использованием определённых классов, которые определяют тип записи, которая используется для хранения данных в базе данных, а также критерии проверки, которые должны использоваться, когда значения получены из формы HTML (то есть, что составляет действительное значение). Типы полей также могут принимать аргументы, которые дополнительно определяют, как поле хранится или может использоваться. В этом случае мы даём нашему полю два аргумента:

- `max_length=20` — Указывает, что максимальная длина значения в этом поле составляет 20 символов.
- `help_text="Введите описание поля"` — предоставляет текстовую метку для отображения, чтобы помочь пользователям узнать, какое значение необходимо предоставить, когда это значение должно быть введено пользователем через HTML-форму.

Имя поля используется для обращения к нему в запросах и шаблонах. В полях также есть метка, которая задаётся как аргумент (`verbose_name`), либо выводится путём заглавной буквы первой буквы имени переменной поля и замены любых символов подчёркивания пробелом (например, `my_field_name` будет иметь метку по умолчанию *My field name*).

Порядок, в котором объявляются поля, будет влиять на их порядок по умолчанию, если модель отображается в форме (например, на сайте администратора), хотя это может быть переопределено.

[Назад к Django](#django)

### Общие аргументы поля

Следующие общие аргументы могут использоваться при объявлении многих / разных типов полей:

- [help_text:](https://docs.djangoproject.com/en/2.1/ref/models/fields/#help-text) Предоставляет текстовую метку для HTML-форм (например, на сайте администратора), как описано выше.
- [verbose_name:](https://docs.djangoproject.com/en/2.1/ref/models/fields/#verbose-name) Удобочитаемое имя для поля, используемого в поле метки. Если не указано, Django выведет по умолчанию подробное название от имени поля.
- [default:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#default) Значение по умолчанию для поля. Это может быть значение или вызываемый объект, и в этом случае объект будет вызываться каждый раз, когда создаётся новая запись.
- [null:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#null) Если True, Django будет хранить пустые значения как NULL в базе данных для полей, где это уместно (CharField вместо этого сохранит пустую строку). По умолчанию используется значение False.
- [blank:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#blank) Если True, поле может быть пустым в ваших формах. По умолчанию используется значение False, что означает, что проверка формы Django заставит вас ввести значение. Это часто используется с null = True, потому что если вы хотите разрешить пустые значения, вы также хотите, чтобы база данных могла представлять их соответствующим образом.
- [choices:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#choices) Группа вариантов для этого поля. Если это предусмотрено, по умолчанию соответствующий виджет формы будет полем выбора с этими вариантами вместо стандартного текстового поля.
- [primary_key:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#primary-key) Если True, задаёт текущее поле в качестве первичного ключа для модели (первичный ключ - это специальный столбец базы данных, предназначенный для однозначной идентификации всех разных записей таблицы). Если в качестве первичного ключа не указано поле, Django автоматически добавит для этой цели поле.

Есть много других вариантов - вы можете просмотреть [full list of field options here](https://docs.djangoproject.com/en/2.2/ref/models/fields/).

[Назад к Django](#django)

### Общие типы полей

Следующие общие аргументы могут использоваться при объявлении многих / разных типов полей:

- [CharField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.CharField) Используется для определения строк фиксированной длины от короткой до средней. Вы должны указать max_length для хранения данных.
- [TextField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.TextField) используется для больших строк произвольной длины. Вы можете указать `max_length` для поля, но это используется только тогда, когда поле отображается в формах (оно не применяется на уровне базы данных).
- [IntegerField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.IntegerField) это поле для хранения значений (целого числа) и для проверки введённых значений в виде целых чисел в формах.
- [DateField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.DateField) и [DateTimeField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.DateTimeField) используются для хранения / представления дат и информации о дате / времени (как Python datetime.date и datetime.datetime, соответственно). Эти поля могут дополнительно объявлять (взаимоисключающие) параметры `auto_now=True` (для установки поля на текущую дату каждый раз, когда модель сохраняется), auto_now_add (только для установки даты, когда модель была впервые создана) и по умолчанию (чтобы установить дату по умолчанию, которую пользователь может переустановить).
- [EmailField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.EmailField) используется для хранения и проверки адресов электронной почты.
- [FileField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.FileField) и [ImageField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ImageField) используются для загрузки файлов и изображений соответственно (`ImageField` просто добавляет дополнительную проверку, что загруженный файл является изображением). Они имеют параметры для определения того, как и где хранятся загруженные файлы.
- [AutoField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.AutoField) - это особый тип IntegerField, который автоматически увеличивается. Первичный ключ этого типа автоматически добавляется в вашу модель, если вы явно не укажете его.
- [ForeignKey](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ForeignKey) Используется для указания отношения «один ко многим» к другой модели базы данных (например, автомобиль имеет одного производителя, но производитель может делать много автомобилей). «Одна» сторона отношения - это модель, содержащая ключ.
- [ManyToManyField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ManyToManyField) используется для определения отношения «многие ко многим» (например, книга может иметь несколько жанров, и каждый жанр может содержать несколько книг). В нашем приложении для библиотек мы будем использовать их аналогично ForeignKeys, но их можно использовать более сложными способами для описания отношений между группами. Они имеют параметр on_delete, чтобы определить, что происходит, когда связанная запись удаляется (например, значение `models.SET_NULL` просто установило бы значение NULL)

Существует много других типов полей, включая поля для разных типов чисел (большие целые числа, малые целые числа, дробные), логические значения, URL-адреса, slugs, уникальные идентификаторы и другие «связанные с временем» сведения (продолжительность, время и т. д.). Вы можете просмотреть [full list here](https://docs.djangoproject.com/en/1.10/ref/models/fields/#field-types).

[Назад к Django](#django)

### Метаданные

Вы можете объявить метаданные на уровне модели для своей модели, объявив класс Meta, как показано на рисунке.
```py
class Meta:
    ordering = ["-my_field_name"]
    ...
```

Одной из наиболее полезных функций этих метаданных является управление сортировка записей, возвращаемых при запросе типа модели. Вы можете сделать это, указав соответствия названия полей для сортировки, как показано выше. Порядок будет зависеть от типа поля (поля символов отсортированы в алфавитном порядке, а поля даты отсортированы в хронологическом порядке). Как показано выше, вы можете префикс имени поля минус-символом (`-`), чтобы изменить порядок сортировки.

Например, если мы решили сортировать книги по умолчанию:
```py
ordering = ["title", "-pubdate"]
```

Книги будут отсортированы по алфавиту по названию, от A-Z, а затем по дате публикации внутри каждого названия, от самого нового до самого старого.

Другим распространённым атрибутом является verbose_name, подробное имя для класса в единственной и множественной форме:
```py
verbose_name = "BetterName"
```

Другие полезные атрибуты позволяют создавать и применять новые «разрешения доступа» для модели (разрешения по умолчанию применяются автоматически), разрешить упорядочение на основе другого поля или объявить, что класс является «абстрактным» (базовый класс, для которого вы не можете создавать записи, и вместо этого будет создан для создания других моделей). Многие другие параметры метаданных управляют тем, какая база данных должна использоваться для модели и как хранятся данные (это действительно полезно, если вам нужно сопоставить модель с существующей базой данных). Полный список опций метаданных доступен здесь: [Model metadata options](https://docs.djangoproject.com/en/2.2/ref/models/options/#model-meta-options) (Django документация).

### Методы

Модель также может иметь методы. Минимально в каждой модели вы должны определить стандартный метод класса для Python `__str __ ()`, чтобы вернуть удобочитаемую строку для каждого объекта. Эта строка используется для представления отдельных записей на сайте администрирования (и в любом другом месте, где вам нужно обратиться к экземпляру модели). Часто это возвращает поле названия или имени из модели.
```py
Copy to Clipboard
def __str__(self):
    return self.field_name
```

Другим распространённым методом включения в модели Django является `get_absolute_url ()`, который возвращает URL-адрес для отображения отдельных записей модели на веб-сайте (если вы определяете этот метод, тогда Django автоматически добавит кнопку «Просмотр на сайте» на экранах редактирования записей модели на сайте администратора). Типичный шаблон для `get_absolute_url ()` показан ниже.
```py
def get_absolute_url(self):
    """
    Returns the url to access a particular instance of the model.
    """
    return reverse('model-detail-view', args=[str(self.id)])
```

> **Примечание:** Предполагается, что вы будете использовать URL-адреса, например **/myapplication/mymodelname/2**, для отображения отдельных записей для вашей модели (где «2» - это идентификатор для определённой записи), вам нужно будет создать URL-карту, чтобы передать ответ и идентификатор «Образцовое представление модели» (которое будет выполнять работу, необходимую для отображения записи). Вышеуказанная функция `reverse ()` может «перевернуть» ваш URL-адрес (в приведённом выше примере с именем «model-detail-view»), чтобы создать URL-адрес правильного формата.
>
>Конечно, для выполнения этой работы вам всё равно придётся писать сопоставление URL-адрес, просмотр и шаблон!

Вы также можете определить любые другие методы, которые вам нравятся, и вызывать их из вашего кода или шаблонов (при условии, что они не принимают никаких параметров).

[Назад к Django](#django)

### Управление моделью

После того, как вы определили свои классы моделей, вы можете использовать их для создания, обновления или удаления записей и для запуска запросов для получения всех записей или отдельных подмножеств записей. Мы покажем вам, как это сделать в учебнике, когда мы определяем наши представления, с кратким обзором.

- **Создание и изменение записей**

Чтобы создать запись, вы можете определить экземпляр модели, а затем вызвать метод `save()`.

```py
# Create a new record using the model's constructor.
a_record = MyModelName(my_field_name="Instance #1")

# Save the object into the database.
a_record.save()
```

> **Примечание:** Если вы не указали какое-либо поле в качестве primary_key, новая запись будет выдаваться автоматически, с идентификатором имени поля. Вы можете запросить это поле после сохранения указанной выше записи, и оно будет иметь значение 1.

Вы можете получить доступ к полям в этой новой записи с использованием синтаксиса точек и изменить значения. Вы должны вызвать `save()`, чтобы сохранить изменённые значения в базе данных.
```py
Copy to Clipboard
# Access model field values using Python attributes.
print(a_record.id) #should return 1 for the first record.
print(a_record.my_field_name) # should print 'Instance #1'

# Change record by modifying the fields, then calling save().
a_record.my_field_name="New Instance Name"
a_record.save()
```

- **Поиск записей**

Вы можете искать записи, соответствующие определённым критериям, используя атрибут объектов модели (предоставляемый базовым классом).

> **Примечание:** Объяснение того, как искать записи, используя «абстрактную» модель и имена полей, может быть немного запутанным. В приведённом ниже обсуждении мы будем ссылаться на модель книги с полями названия и жанра, где жанр также является моделью с единственным именем в поле.

Мы можем получить все записи для модели как объект **QuerySet**, используя `objects.all()`. **QuerySet** - это итерируемый объект, означающий, что он содержит несколько объектов, которые мы можем перебирать / прокручивать.
```py
all_books = Book.objects.all()
```

Метод `filter()` Django позволяет отфильтровать возвращаемый **QuerySet** для соответствия указанному текстовому или числовому полю по конкретным критериям. Например, чтобы отфильтровать книги, содержащие слово «wild» («дикие») в заголовке, а затем подсчитать их, мы могли бы сделать следующее.
```py
wild_books = Book.objects.filter(title__contains='wild')
number_wild_books = Book.objects.filter(title__contains='wild').count()
```

Соответствующие поля и тип соответствия определяются в имени параметра фильтра, используя формат: `field_name__match_type` (обратите внимание на двойное подчёркивание между заголовком выше). Выше мы фильтруем заголовок с учётом регистра. Есть много других типов совпадений, которые вы можете сделать: `icontains` (без учёта регистра), `iexact` (точное совпадение без учёта регистра), `exact` (точное совпадение с учётом регистра ) и `in`, `gt` (больше), `startswith` и т.д. [Смотреть полный список](https://docs.djangoproject.com/en/2.2/ref/models/querysets/#field-lookups) (Django Docs, [EN]).

В некоторых случаях вам нужно будет фильтровать поле, которое определяет отношение «один ко многим» к другой модели (например, `ForeignKey`). В этом случае вы можете «индексировать» поля в связанной модели с дополнительными двойными подчёркиваниями. Так, например, чтобы фильтровать книги с определённым жанровым рисунком, вам нужно будет указывать имя в поле жанра, как показано ниже:
```py
books_containing_genre = Book.objects.filter(genre__name__icontains='fiction')  # Will match on: Fiction, Science fiction, non-fiction etc.
```

> **Примечание:** Вы можете использовать символы подчёркивания (`__`) для навигации по многим уровням отношений (ForeignKey / ManyToManyField) по своему усмотрению. Например, книга, имеющая разные типы, определяемая с использованием дополнительной связи «обложка», может иметь имя параметра: type__cover__name__exact = 'hard'.

Существует гораздо больше возможностей для запросов, включая обратные поиски от связанных моделей, цепочки фильтров, возврат меньшего набора значений и т. д. Для получения дополнительной информации см. [Making queries](https://docs.djangoproject.com/en/2.2/topics/db/queries/) (Django Docs, [EN]).

[Назад к Django](#django)

### Определение моделей LocalLibrary

В этом разделе мы начнём определять модели для библиотеки. Откройте **models.py** (в / locallibrary / catalog /). Шаблон в верхней части страницы импортирует модуль моделей, который содержит базовый класс модели `models.Model`, от которого наследуются наши модели.
```py
from django.db import models

# Create your models here.
```

### Модель жанра

Скопируйте приведённый ниже код модели `Genre` и вставьте его в нижнюю часть вашего файла **models.py**. Эта модель используется для хранения информации о категории книг - например, будь то художественная или документальная, роман или военно-историческая и т. д. Как уже упоминалось выше, мы создали жанр как модель, а не как свободный текст или список выбора, чтобы возможные значения могли управляться через базу данных, а не были закодированными.
```py
Copy to Clipboard
class Genre(models.Model):
    """
    Model representing a book genre (e.g. Science Fiction, Non Fiction).
    """
    name = models.CharField(max_length=200, help_text="Enter a book genre (e.g. Science Fiction, French Poetry etc.)")

    def __str__(self):
        """
        String for representing the Model object (in Admin site etc.)
        """
        return self.name
```

Модель имеет один `CharField` field (имя), которое используется для описания жанра (оно ограничено 200 символами и имеет некоторый `help_text`. В конце модели мы объявляем метод `__str__()`, который просто возвращает имя жанра, определённого конкретной записью. Verbose name не был определён, поэтому поле будет называться `Name` в формах.

[Назад к Django](#django)

### Модель книги

Скопируйте модель книги ниже и снова вставьте её в нижнюю часть файла. Модель книги представляет всю информацию о доступной книге в общем смысле, но не конкретный физический «экземпляр» или «копию» для временного использования. Модель использует CharField для представления названия книги и isbn (обратите внимание, как isbn указывает свой ярлык как «ISBN», используя первый неименованный параметр, поскольку в противном случае ярлык по умолчанию был бы «Isbn»). Модель использует TextField для summary, потому что этот текст, возможно, должен быть очень длинным.
```py
from django.urls import reverse #Used to generate URLs by reversing the URL patterns

class Book(models.Model):
    """
    Model representing a book (but not a specific copy of a book).
    """
    title = models.CharField(max_length=200)
    author = models.ForeignKey('Author', on_delete=models.SET_NULL, null=True)
    # Foreign Key used because book can only have one author, but authors can have multiple books
    # Author as a string rather than object because it hasn't been declared yet in the file.
    summary = models.TextField(max_length=1000, help_text="Enter a brief description of the book")
    isbn = models.CharField('ISBN',max_length=13, help_text='13 Character <a href="https://www.isbn-international.org/content/what-isbn">ISBN number</a>')
    genre = models.ManyToManyField(Genre, help_text="Select a genre for this book")
    # ManyToManyField used because genre can contain many books. Books can cover many genres.
    # Genre class has already been defined so we can specify the object above.

    def __str__(self):
        """
        String for representing the Model object.
        """
        return self.title


    def get_absolute_url(self):
        """
        Returns the url to access a particular book instance.
        """
        return reverse('book-detail', args=[str(self.id)])
```

Жанр представляет из себя `ManyToManyField`, так что книга может иметь несколько жанров, а жанр может иметь много книг. Автор объявляется через `ForeignKey`, поэтому в каждой книге будет только один автор, но у автора может быть много книг (на практике книга может иметь несколько авторов, но не в такой реализации!)

В обоих типах полей соответствующий класс модели объявляется как первый неименованный параметр, используя либо класс модели, либо строку, содержащую имя соответствующей модели. Вы должны использовать имя модели как строку, если связанный класс ещё не был определён в этом файле до того, как он будет указан! Другими параметрами, представляющими интерес для поля автора, являются `null=True`, которое позволяет базе данных хранить значение `Null` , если автор не выбран, и on_delete = models. `SET_NULL` установит значение автора в Null, если связанная с автором запись будет удалена.

Модель также определяет `__str __()`, используя поле заголовка книги для представления книги. Окончательный метод `get_absolute_url()` возвращает URL-адрес, который можно использовать для доступа к подробной записи для этой модели (для этого нам нужно будет определить сопоставление URL-адресов, в котором содержится подробная информация о книге, и определить связанное представление и шаблон ).

[Назад к Django](#django)

### Модель BookInstance

Затем скопируйте модель BookInstance (показано ниже) под другие модели. BookInstance представляет собой определённую копию книги, которую кто-то может брать взаймы, и включает информацию о том, доступна ли копия или в какой день она ожидается, «отпечаток» или сведения о версии, а также уникальный идентификатор книги в библиотеке. Теперь некоторые из полей и методов будут знакомы. Модель использует

- `ForeignKey` для идентификации связанной книги (в каждой книге может быть много копий, но в копии может быть только одна книга).
- `CharField`, для представления данных (конкретного выпуска) о книге.
```py
import uuid # Required for unique book instances

class BookInstance(models.Model):
    """
    Model representing a specific copy of a book (i.e. that can be borrowed from the library).
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, help_text="Unique ID for this particular book across whole library")
    book = models.ForeignKey('Book', on_delete=models.SET_NULL, null=True)
    imprint = models.CharField(max_length=200)
    due_back = models.DateField(null=True, blank=True)

    LOAN_STATUS = (
        ('m', 'Maintenance'),
        ('o', 'On loan'),
        ('a', 'Available'),
        ('r', 'Reserved'),
    )

    status = models.CharField(max_length=1, choices=LOAN_STATUS, blank=True, default='m', help_text='Book availability')

    class Meta:
        ordering = ["due_back"]


    def __str__(self):
        """
        String for representing the Model object
        """
        return '%s (%s)' % (self.id,self.book.title)
```

Мы дополнительно объявляем несколько новых типов полей:

- `UUIDField` используется для поля **id**, чтобы установить его как **primary_key** для этой модели. Этот тип поля выделяет глобальное уникальное значение для каждого экземпляра (по одному для каждой книги, которую вы можете найти в библиотеке).
- `DateField` используется для данных **due_back** (при которых ожидается, что книга появится после заимствования или обслуживания). Это значение может быть `blank` или `null` (необходимо, когда книга доступна). Метаданные модели (Class Meta) используют это поле для упорядочивания записей, когда они возвращаются в запросе.
- status - это `CharField`, который определяет список **choice/selection**. Как вы можете видеть, мы определяем кортеж, содержащий кортежи пар ключ-значение и передаём его аргументу выбора. Значение в **key/value** паре - это отображаемое значение, которое пользователь может выбрать, а ключи - это значения, которые фактически сохраняются, если выбрана опция. Мы также установили значение по умолчанию **«m»** (техническое обслуживание), поскольку книги изначально будут созданы недоступными до того, как они будут храниться на полках.

Модель `__str__()` представляет объект BookInstance, используя комбинацию его уникального идентификатора и связанного с ним заголовка книги.

> **Примечание:** Немного о Python:
> Значение, возвращаемое `__str__()`, является форматированной строкой. В строке мы используем `%S` для объявления 'placeholders'. После строки укажем `%`, а затем кортеж, содержащий значения, которые будут вставлены в заполнители. Если у вас просто один заполнитель, вы можете опустить кортеж - например, 'Моё значение:% S' % переменная.
>
> Обратите также внимание на то, что, хотя этот подход совершенно применим, но он более не является предпочтительным. Начиная с Python 3, вы должны использовать метод format, например. `'{0} ({1})'.format(self.id, self.book.title)`. Вы можете узнать больше об этом [здесь](https://www.python.org/dev/peps/pep-3101/).

### Модель автора

Скопируйте модель автора (показано ниже) под существующим кодом в **models.py**.

Теперь все поля/методы должны быть знакомы. Модель определяет автора как имя, фамилию, дату рождения и (необязательную) дату смерти. Он указывает, что по умолчанию `__str__()` возвращает имя в фамилии, порядковый номер первого имени. Метод `get_absolute_url()` отменяет сопоставление URL-адреса автора с целью получения URL-адреса для отображения отдельного автора.
```py
class Author(models.Model):
    """
    Model representing an author.
    """
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    date_of_birth = models.DateField(null=True, blank=True)
    date_of_death = models.DateField('Died', null=True, blank=True)

    def get_absolute_url(self):
        """
        Returns the url to access a particular author instance.
        """
        return reverse('author-detail', args=[str(self.id)])


    def __str__(self):
        """
        String for representing the Model object.
        """
        return '%s, %s' % (self.last_name, self.first_name)
```

### Повторно выполнить миграцию базы данных

Теперь все ваши модели созданы. Теперь переустановите миграцию базы данных, чтобы добавить их в свою базу данных.
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

### Языковая модель - вызов

Представьте себе, что местный благотворитель жертвует ряд новых книг, написанных на другом языке (скажем, фарси). Задача состоит в том, чтобы определить, как они будут лучше всего представлены на нашем веб-сайте библиотеки, а затем добавить их в модели.

Некоторые вещи, которые следует учитывать:

- Должен ли «язык» ассоциироваться с Book, BookInstance или каким-либо другим объектом?
- Должны ли быть представлены разные языки с использованием модели, свободного текстового поля или жёстко запрограммированного списка выбора?
После того, как вы решили, добавьте поле. Вы можете увидеть наше решение на Github [here](https://github.com/mdn/django-locallibrary-tutorial/blob/master/catalog/models.py).

### Итог

В этой статье мы узнали, как определять модели, а затем использовать эту информацию в разработке и внедрении соответствующих моделей для сайта LocalLibrary.

На этом этапе мы отвлечёмся от создания сайта и проверим **Django Administration site**. Этот сайт позволит нам добавить некоторые данные в библиотеку, которые мы можем отобразить с помощью наших (ещё не созданных) представлений и шаблонов.

Смотрите также
[Writing your first Django app, part 2](https://docs.djangoproject.com/en/1.10/intro/tutorial02/) (Django Docs)
[Making queries](https://docs.djangoproject.com/en/1.10/topics/db/queries/) (Django Docs)
[QuerySet API Reference](https://docs.djangoproject.com/en/1.10/ref/models/querysets/) (Django Docs)


[Назад к Django](#django)

## Django 4: административная панель Django

Теперь, когда модели для сайта [местной библиотеки](#django-сайт-местной-библиотеки) созданы, добавим некоторые "настоящие" данные о книгах, используя административную панель Django Admin. Для начала мы покажем, как зарегистрировать в ней модели, потом как войти и создать какие-нибудь данные. В конце статьи мы покажем некоторые способы дальнейшего улучшения вида админ-панели.

|Предусловия: |	Сначала завершите: [Руководство часть 3:](#django-3-использование-моделей) использование моделей.
|----|----
|Цель: | Уяснить преимущества и ограничения админ-панели Django, научиться использовать её для создания записей для наших моделей.

### Обзор

*Приложение* **Django admin** может использовать ваши модели для автоматического создания части сайта, предназначенной для создания, просмотра, обновления и удаления записей. Это может сэкономить вам много времени в процессе разработки, упрощая тестирование ваших моделей на предмет правильности данных. Оно также может быть полезным для управления данными на стадии публикации, в зависимости от типа веб-сайта. Проект Django рекомендует это приложение только для управления внутренними данными (т.е.для использования администраторами, либо людьми внутри вашей организации), так как модельно-ориентированный подход не обязательно является наилучшим интерфейсом для всех пользователей и раскрывает много лишних подробностей о моделях.

Все необходимые настройки, которые необходимо включить в admin приложение вашего веб-сайта, были сделаны автоматически, когда вы [создали каркас проекта](#django-2-создание-скелета) (информацию о необходимых актуальных зависимостях смотрите здесь - [Django docs](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/)) . В результате все, что необходимо сделать для того, чтобы добавить модели в приложение admin, это *зарегистрировать* их. В конце этой статьи мы представим краткую демонстрацию того, каким образом можно дополнительно настроить админ-панель для лучшего отображения данные наших моделей.

После регистрации моделей мы покажем как создать нового суперпользователя , войти на сайт от его имени и создать книги, авторов, экземпляры книг и жанры. Это будет полезным для тестирования представлений и шаблонов, которые мы начнём создавать в следующей части руководства.

### Регистрация моделей

Вначале откройте файл **admin.py** в папке приложения (**/locallibrary/catalog/admin.py**). Пока он выглядит так (заметьте, что он уже содержит импорт `django.contrib.admin`):

```py
from django.contrib import admin

# Register your models here.
```

Зарегистрируйте модели путём вставки следующего текста в нижнюю часть этого файла. Этот код просто импортирует модели и затем вызывает `admin.site.register` для регистрации каждой из них.
```py
from .models import Author, Genre, Book, BookInstance

admin.site.register(Book)
admin.site.register(Author)
admin.site.register(Genre)
admin.site.register(BookInstance)
```

> **Примечание:** В строках выше предполагается, что вы приняли вызов создать модель, отражающую естественный язык книги ([см. обучающую статью о моделях](#django-3-использование-моделей))!

Это самый простой способ регистрации модели или моделей. Админ-панель имеет множество настроек. Мы рассмотрим другие способы регистрации ваших моделей ниже.

[Назад к Django](#django)

### Создание суперпользователя

Для того, чтобы войти в админ-панель, нам необходимо иметь учётную запись пользователя со статусом *Staff (сотрудники)*. Для просмотра и создания записей, пользователю также понадобится разрешение для управления всеми нашими объектами. Вы можете создать учётную запись **"superuser"**, которая даёт полный доступ к сайту и все необходимые разрешения, используя **manage.py**.

Для создания суперпользователя вызовите следующую команду из той же папки, где расположен **manage.py**. Вас попросят ввести имя пользователя, адрес электронной почты и надёжный пароль.
```bash
python3 manage.py createsuperuser
```

После выполнения этой команды новый суперпользователь будет добавлен в базу данных. Теперь перезапустите сервер, чтобы можно было протестировать вход на сайт:
```bash
python3 manage.py runserver
```

### Вход в админ-панель и её использование

Для входа в админ-панель откройте ссылку `/admin` (например `http://127.0.0.1:8000/admin`) и введите логин и пароль вашего нового суперпользователя (вас перенаправят на login-страницу и потом обратно на /admin после ввода всех деталей).

В этой части сайта отображаются все наши модели, сгруппированные по установленному приложению. Вы можете кликнуть на названии модели, чтобы получить список всех связанных записей, далее можете кликнуть на этих записях, для их редактирования . Также можно непосредственно кликнуть на ссылку **Add**, расположенную рядом с каждой моделью, чтобы начать создание записи этого типа.

![admin panel](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_home.png)

Кликните на ссылке **Add** справа от *Books*, чтобы создать новую книгу (появится диалоговое окно как на картинке внизу). Заметьте, что заголовок каждого поля - это тип используемого виджета, и `help_text` (если есть) совпадает со значением, которое вы указали в модели.

Введите значение для полей. Вы можете создавать новых авторов или жанры, нажимая на значок "`+`", расположенный рядом с соответствующим полем (или выберите существующее значение из списков, если вы уже создали их). Когда вы закончили, нажмите на **SAVE, Save and add another**, или **Save and continue editing**, чтобы сохранить записи.

![add book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_add.png)

> **Примечание:** А сейчас, хотелось бы, чтобы вы добавили несколько книг, авторов и жанров (например, Фэнтези) в ваше приложение. Удостоверьтесь, что каждый автор и жанр включает пару различных книг (позже, когда мы реализуем представления "list" и "detail", это сделает их более интересными).

После того, когда книги добавлены, для перехода на главную страницу админ-панели кликните на ссылке **Home** в верхней части страницы. Потом кликните на ссылке **Books** для отображения текущего списка книг (или на одной из других ссылок, чтобы увидеть список соответствующей модели). После добавления нескольких книг список может выглядеть наподобие скриншота ниже. Отображается название каждой из книг. Его возвращает метод `__str__()` в модели Book, созданной в предыдущей статье.

![add books](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_list.png)

Для удаления книги из этого списка выберите чекбокс рядом с ней и действие *delete*... из выпадающего списка *Action*, а затем нажмите кнопку **Go**. Также можно добавить новую книгу, нажав на кнопку **ADD BOOK**.

Вы можете редактировать книгу, кликнув по ссылке с её названием. Страница редактирования книги, приведённая ниже, практически идентична странице добавления новой книги. Основные отличия - это заголовок страницы (*Change book*) и наличие кнопок **Delete**, **HISTORY** и **VIEW ON SITE**. Последняя присутствует, так как мы определили метод `get_absolute_url()` в нашей модели.

![edit book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_modify.png)

Теперь перейдите назад на страницу **Home** (используя ссылку *Home* в навигационной цепочке вверху страницы) и просмотрите списки **Author** и **Genre**. В них уже должно быть несколько элементов, созданных при добавлении новых книг. Если хотите, добавьте ещё.

Однако у вас не будет ни одного экземпляра книги, потому что они не создаются из модели `Book` (хотя можно создать книгу из модели `BookInstance` — такова природа поля `ForeignKey`). Для отображения страницы *Add book instance* (см. рисунок ниже) вернитесь на страницу *Home* и нажмите кнопку **Add**. Обратите внимание на длинный уникальный **Id** для идентификации конкретного экземпляра книги в библиотеке.

![book instance](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_bookinstance_add.png)

Создайте несколько экземпляров для каждой из ваших книг. Установите статус *Available (доступен*) для некоторых экземпляров и *On loan (выдан)* для остальных. Если статус экземпляра **not** *Available (недоступен)*, то также установите дату возврата (*Due back*).

Вот и все! Вы изучили как запустить и использовать админ-панель. Также были созданы записи для `Book`, `BookInstance`, `Genre` и `Author`, которые можно будет использовать после создания наших собственных представлений и шаблонов.

[Назад к Django](#django)

### "Продвинутая" конфигурация

Django выполняет неплохую работу по созданию базовой админ-панели используя информацию из зарегистрированных моделей:

- Каждая модель имеет список записей, каждая из которых идентифицируется строкой, создаваемой методом `__str__()` модели, и связана с представлением для её редактирования. По умолчанию, в верхней части этого представления находится меню действий, которое может быть использовано для удаления нескольких записей за раз
- Формы для редактирования и добавления записей содержат все поля модели, которые расположены вертикально в порядке их объявления в модели.

Можно настроить интерфейс пользователя для упрощения его использования. Некоторые доступные настройки:

- List views:
  - добавление дополнительных отображаемых полей или информации для каждой записи.
  - добавление фильтров для отбора записей по разным критериям (например, статус выдачи книги).
  - добавление дополнительных вариантов выбора в меню действий и места расположения этого меню на форме.

- Detail views
  - выбор отображаемых полей, их порядка, группирования и т.д.
  - добавление связанных полей к записи (например, возможности добавления и редактирования записей книг при создании записи автора).

В этом разделе рассмотрим некоторые изменения для совершенствования интерфейса пользователя нашей местной библиотеки, а именно: добавление дополнительной информации в списки моделей `Book` и `Author` , а также улучшение расположения элементов соответствующих представлений редактирования. Пользовательский интерфейс моделей `Language` and `Genre` изменять не будем, так как это не даст заметного улучшения, поскольку он содержит только по одному полю!

Полное руководство по всем возможным вариантам настройки админ-панели можно найти в The [Django Admin site](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/) (документация Django).

### Регистрация класса ModelAdmin

Для изменения отображения модели в пользовательском интерфейсе админ-панели, необходимо определить класс [ModelAdmin](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#modeladmin-objects) (он описывает расположение элементов интерфейса, где Model - наименование модели) и зарегистрировать его для использования с этой моделью.

Давайте начнём с модели Author. Откройте файл **admin.py** в каталоге приложения (**/locallibrary/catalog/admin.py**). Закомментируйте исходную регистрацию (используя префикс #) этой модели:
```js
# admin.site.register(Author)
```

Теперь добавьте новый класс `AuthorAdmin` и зарегистрируйте его как показано ниже:
```py
# Define the admin class
class AuthorAdmin(admin.ModelAdmin):
    pass

# Register the admin class with the associated model
admin.site.register(Author, AuthorAdmin)
```

Сейчас мы добавим классы `ModelAdmin` для моделей `Book`, и `BookInstance`. Нам снова нужно закомментировать исходную регистрацию:
```js
# admin.site.register(Book)
# admin.site.register(BookInstance)
```

В этот раз для создания и регистрации новых моделей используем декоратор `@register` (он делает то же самое, что и метод `admin.site.register()`):
```py
# Register the Admin classes for Book using the decorator

@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    pass

# Register the Admin classes for BookInstance using the decorator

@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    pass
```

Пока что все наши admin-классы пустые (см. "`pass`"), поэтому ничего не изменится! Добавим код для задания особенностей интерфейса моделей.

[Назад к Django](#django)

### Настройка отображения списков

Сейчас приложение *LocalLibrary* отображает всех авторов, используя имя объекта, возвращаемое методом `__str__()` модели. Это приемлемо, когда есть только несколько авторов, но, если их количество значительно, возможны дубликаты. Чтобы различить их или просто отобразить более интересную информацию о каждом авторе, можно использовать [list_display](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display) (для добавления дополнительных полей).

Замените класс `AuthorAdmin` кодом, приведённым ниже. Названия полей, которые будут отображаться в списке, перечислены в кортеже **list_display** в требуемом порядке (это те же имена, что и в исходной модели).
```py
Copy to Clipboard
class AuthorAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'date_of_birth', 'date_of_death')
```

Перезапустите сайт и перейдите к списку авторов. Указанные поля должны отображаться следующим образом:

![autors list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_author_list.png)

Для нашей модели `Book` добавим отображение полей `author` и `genre`. Поле `author` - это внешний ключ (`ForeignKey` ) связи один к одному, поэтому оно будет представлено значением `__str()__` для связанной записи. Замените класс `BookAdmin` на версию, приведённую ниже.
```py
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'display_genre')
```

К сожалению, мы не можем напрямую поместить поле genre в `list_display`, так как оно является `ManyToManyField` (Django не позволяет это из-за большой "стоимости" доступа к базе данных). Вместо этого мы определим функцию `display_genre` для получения строкового представления информации (вызов этой функции есть в `list_display`, её определение см. ниже).

> **Примечание:** Получение здесь значения поля `genre` возможно не самая хорошая идея вследствие "стоимости" операции базы данных. Мы показываем это, потому что вызов функций в ваших моделях может быть очень полезен по другим причинам, например, для добавления ссылки *Delete* рядом с каждым пунктом списка.

Добавьте следующий код в вашу модель `Book` (**models.py**). В нем создаётся строка из первых трёх значений поля `genre` (если они существуют) и `short_description`, которое может быть использовано в админ-панели.
```py
    def display_genre(self):
        """
        Creates a string for the Genre. This is required to display genre in Admin.
        """
        return ', '.join([ genre.name for genre in self.genre.all()[:3] ])
    display_genre.short_description = 'Genre'
```

После сохранения модели и обновления админ-панели, перезапустите её и перейдите на страницу списка *Books*. Вы должны увидеть список книг, наподобие приведённого ниже:

![books](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_book_list.png)

Модель `Genre` (и модель `Language`, если вы её определили) имеет единственное поле. Поэтому нет необходимости создания для них дополнительных моделей с целью отображения дополнительных полей.

> **Примечание:** Целесообразно, чтобы в списке модели `BookInstance` отображались хотя бы статус и ожидаемая дата возврата. Мы добавили это в качестве "испытания" в конце этой статьи!

[Назад к Django](#django)

### Добавление фильтров списка

Если в вашем списке есть множество элементов, может быть полезной возможность фильтрации отображаемых пунктов. Это выполняется путём перечисления их в атрибуте `list_filter`. Замените класс `BookInstanceAdmin` на следующий:
```py
class BookInstanceAdmin(admin.ModelAdmin):
    list_filter = ('status', 'due_back')
```

Представление списка теперь будет содержать панель фильтрации справа. Обратите внимание, как выбирать даты и статус для фильтрации:

![filter panel](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_bookinstance_list_filters.png)

### Формирование макета с подробным представлением

По умолчанию в представлениях деталей отображаются все поля по вертикали в порядке их объявления в модели. Вы можете изменить порядок декларации, какие поля отображаются (или исключены), используются ли разделы для организации информации, отображаются ли поля горизонтально или вертикально, и даже какие виджеты редактирования используются в админ-формах.

> **Примечание:** Модели LocalLibrary относительно просты, поэтому нам не нужно менять макет, но мы всё равно внесём некоторые изменения, просто чтобы показать вам, как это сделать.

### Управление отображаемыми и вложенными полями

Обновите ваш AuthorAdmin класс, чтобы добавить строку полей, как показано ниже:
```py
class AuthorAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'date_of_birth', 'date_of_death')
    fields = ['first_name', 'last_name', ('date_of_birth', 'date_of_death')]
```

Атрибут полей перечисляет только те поля, которые должны отображаться в форме, по порядку. Поля отображаются по вертикали по умолчанию, но будут отображаться горизонтально, если вы дополнительно группируете их в кортеже (как показано в полях «date» выше).

Перезагрузите приложение и перейдите к подробному представлению автора - он должен теперь отображаться, как показано ниже:

![change autor](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_author_detail.png)

> **Примечание:** Так же, вы можете использовать `exclude` атрибут для объявления списка атрибутов, которые будут исключены из формы (все остальные атрибуты в модели, будут отображаться).

[Назад к Django](#django)

### Разделение на секции/Выделение подробного представления

Вы можете добавлять "разделы" (sections) для группировки связанной информации в модели в форме детализации, используя атрибут [fieldsets](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.fieldsets) .

В модели `BookInstance` мы имеем информацию соответствия конкретной книги (т.е. `name`, `imprint`, and `id`) и датой когда она вновь станет доступной (`status`, `due_back`). Мы можем добавить их в разные секции, добавив текст жирным шрифтом в наш `BookInstanceAdmin` класс.
```py
@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    list_filter = ('status', 'due_back')

    fieldsets = (
        (None, {
            'fields': ('book','imprint', 'id')
        }),
        ('Availability', {
            'fields': ('status', 'due_back')
        }),
    )
```

Каждая секция имеет свой заголовок (или `None`, если заголовок не нужен) и ассоциированный кортеж полей в словаре - формат сложный для описания, но относительно простой для понимания, если вы посмотрите на фрагмент кода, представленный выше.

Перезапустите сайт и перейдите к списку экземпляров; форма должна отображаться следующим образом:

![instace list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_bookinstance_detail_sections.png)

### Встроенное редактирование связанных записей

Иногда бывает полезно иметь возможность добавлять связанные записи одновременно. Например, имеет смысл иметь как информацию о книге, так и информацию о конкретных копиях, которые вы получили на той же странице подробностей. К примеру, вполне логично получить и информацию о книге, и информацию о конкретных копиях, зайдя на страницу детализации.

Вы можете это сделать, объявив [inlines](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.inlines), и указав тип [TabularInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.TabularInline) (горизонтальное расположение) или [StackedInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.StackedInline) (вертикальное расположение, так же как и в модели по умолчанию). Вы можете добавить `BookInstance` информацию в подробное описание `Book` , добавив строки, представленные ниже и располагающиеся рядом с `BookAdmin`:
```py
class BooksInstanceInline(admin.TabularInline):
    model = BookInstance

@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'display_genre')
    inlines = [BooksInstanceInline]
```

Попробуйте перезапустить приложение, а затем взгляните на представление книги — внизу вы должны увидеть экземпляры книги, относящиеся к этой книге:

![book instance](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_book_detail_inlines.png)

В этом случае, всё, что мы сделали - объявили наш встроенный класс tablular, который просто добавляет все поля из встроенной модели. Вы можете указать все виды дополнительной информации для макета, включая отображаемые поля, их порядок, независимо от того, являются ли они только для чтения или нет, и т. д. (См. [TabularInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.TabularInline) для получения дополнительной информации).

> **Примечание:** В этой функции есть некоторые неприятные ограничения! На скриншоте выше у нас есть три существующих экземпляра книги, за которыми следуют три поля для новых экземпляров книги (которые очень похожи!). Было бы лучше НЕ иметь лишних экземпляров книг по умолчанию и просто добавить их с помощью ссылки **Add another Book instance** или иметь возможность просто перечислять `BookInstances` как нечитаемые здесь ссылки. Первый вариант можно сделать, установив `extra` атрибут в 0 в модели `BookInstanceInline`, попробуйте сами.

[Назад к Django](#django)

### Проверьте себя

Мы многое изучили в этом разделе и теперь настало время вам самостоятельно попробовать несколько вещей:

1. Для представления списка `BookInstance` , добавьте код для отображения книги, статуса, даты возврата, и id (вместо значения по умолчанию возвращаемого `__str__()`).
2. Добавьте встроенный список перечня `Book` в представление списка `Author` , используя тот же самый подход, который мы применили для `Book`/`BookInstance`.

### Заключение

Вот и всё! Теперь вы узнали, как настроить сайт администрирования как в самой простой, так и в улучшенной форме, о создании суперпользователя и о том, как перемещаться по сайту администратора, просматривать, удалять и обновлять записи. По пути вы создали множество книг, экземпляров, жанров и авторов, которые мы сможем перечислить и отобразить, как только мы создадим собственный вид и шаблоны.

Дополнительные материалы

- [Writing your first Django app, part 2: Introducing the Django Admin](https://docs.djangoproject.com/en/1.10/intro/tutorial02/#introducing-the-django-admin) (Django docs)
- [The Django Admin site](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/) (Django Docs)

[Назад к Django](#django)

## Django 5: cоздание домашней страницы

Теперь мы готовы создать код нашей первой страницы — домашняя страница сайта [LocalLibrary](#django-сайт-местной-библиотеки) будет показывать количество записей в каждой модели, кроме того, она будет выводить боковую навигационную панель с ссылками на другие страницы сайта. В результате мы приобретём практический навык написания простых URL-преобразований и отображений, получения записей из базы данных и применения шаблонов.

|Требования: | Прочитать [Введение в Django](#введение). Завершить изучение предыдущих частей руководства (включая [Руководство часть 4: Django административный раздел сайта](#django-4-административная-панель-django)).
|---|---
|Цель: |Понимать как создавать простые url-преобразования (которые не содержат никаких данных) и отображения, как получать данные из моделей и создавать шаблоны.

### Обзор

Теперь, когда мы определили наши модели и создали несколько записей в них, пришло время написать код, который будет показывать данную информацию пользователям. И первое, что нам необходимо сделать это определиться какую информацию мы бы хотели показывать на наших страницах, а затем определить соответствующие URL-адреса для получения соответствующих ресурсов. Затем нам надо создать url-преобразования, отображения (функции, или классы), а затем шаблоны страницы.

Диаграмма, представленная ниже, демонстрирует главный поток данных и элементов, которые нужно реализовать для управления HTTP запросами и ответами. Поскольку мы уже создали модель, то нам остаётся создать следующее:

- URL-преобразования для перехода по соответствующему URL-адресу (с учётом информации, передаваемой в данном адресе) к соответствующей функции отображения.
- Функции отображения для запроса соответствующих данных из моделей, создание страниц HTML для показа этих данных и их отправку в клиент пользователя (в браузер).
- Шаблоны, которые используются отображениями для рендеринга (отрисовки) данных.

![blok-scheme](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Home_page/basic-django.png)

Как вы увидите в следующем разделе, у нас будет 5 страниц, которые мы немного опишем в данной статье. Данная статья, большей частью, будет сконцентрирована на реализации всего-лишь одной, домашней страницы нашего сайта (к другим страницам мы перейдём в других частях руководства). Это должно дать вам хорошее базовое представление о работе с URL-преобразованиями (связывании), отображениями и моделями.

[Назад к Django](#django)

### Определяем URL-адреса страниц

По сути, так как для конечных пользователей, данная версия сайта LocalLibrary является read-only (только для чтения), то нам надо создать домашнюю страницу и страницы, которые будут показывать списки авторов и книг, а также детальную информацию о них, соответственно.

Перечислим URL-адреса, которые понадобятся для наших страниц:

- `catalog/` — Домашняя/индексная страница.
- `catalog/books/` — Список всех книг.
- `catalog/authors/` — Список всех авторов.
- `catalog/book/<id>` — Детальная информация для определённой книги со значением первичного ключа равного `<id>`. Например, `/catalog/book/3`, для `id = 3`.
- `catalog/author/<id>` — Детальная информация для определённого автора со значением первичного ключа равного `<id>`. Например, `/catalog/author/11`, для автора с `id = 11`.

Первые три URL-адреса используются для показа домашней страницы, а также списков книг и авторов. Они не кодируют никакой дополнительной информации и результат показа данных страниц будет полностью зависеть от того, что находится в базе данных и, по сути, будет все время одним и тем же (при неизменной базе данных, конечно).

Последние два URL-адреса применяются для показа детальной информации об определённой книге, или авторе — в себе они содержат соответствующее значение идентификатора (показан как `<id>`, выше). URL-преобразование получает данную информацию и передаёт её в отображение, которое применяет её для запроса к базе данных. Для кодирования и применения данной информации в вашем URL-адресе нам понадобится только одно url-преобразование, соответствующее отображение и шаблон страницы для показа любой книги (или автора).

> **Примечание:** Django позволяет вам конструировать ваши URL-адреса любым, удобным для вас, способом — вы можете закодировать информацию в теле URL-адреса, как показано выше, или использовать URL-адрес типа `GET` (например, `/book/?id=6`). Независимо от ваших предпочтений, URL-адреса должны быть понятными, логичными и читабельными ([посмотрите совет W3C здесь](https://www.w3.org/Provider/Style/URI)).
>
>Документация Django рекомендует кодировать информацию в теле URL-адреса, на практике это приводит к лучшей структуре сайта.

Как было отмечено ранее, оставшаяся часть данной статьи описывает как сделать главную страницу сайта.

[Назад к Django](#django)

### Создание главной страницы сайта

Первой страницей, которую мы создадим, будет главная страница сайта (`catalog/`). Она будет небольшой статической HTML-страницей, которая будет показывать вычисленные "количества" различных записей из базы данных. Для того, чтобы проделать данную работу мы вначале создадим URL-преобразование, затем отображение и шаблон.

> **Примечание:** Лучше уделить больше внимания на данный раздел, поскольку информация, представленная здесь, применяется для создания всех страниц сайта.

### URL-преобразование

Когда мы создавали [скелет сайта](#django-2-создание-скелета) мы обновили **locallibrary/urls.py** так что всякий раз, когда начинается URL-адрес наш `catalog/` получен и `URLConf` `catalog.urls` подключён для обработки оставшейся части строки.
```py
urlpatterns += [
    path('catalog/', include('catalog.urls')),
]
```

> **Примечание:** всякий раз, когда Django сталкивается c [django.urls.include()](https://docs.djangoproject.com/en/2.0/ref/urls/#django.urls.include) он отбрасывает часть совпавшего URL , и отправляет оставшуюся строку в включённый URLconf для дальнейшей обработки.

Внутри нашего каталога приложения откройте **urls.py** и поместите в него текст, отмеченный жирным, ниже.
```py
urlpatterns = [
    path('', views.index, name='index'),
]
```

Эта функция `path()` определяет URL-паттерн (в данном случае это пустая строка: '` `' - мы поговорим чуть более подробно о них далее в данном руководстве) и функцию отображения, которая будет вызвана, если введённый адрес будет соответствует данному паттерну (`views.index` — это функция с именем `index()` в **views.py**).

Данная функция `path()`, кроме того, определяет параметр `name`, который уникально определяет это частное URL-преобразование. Вы можете использовать данное имя для "обратного" ("reverse") преобразования — то есть, для динамического создания URL-адреса, указывающего на ресурс, на которое указывает данное преобразование. Например, теперь, когда у нас имеется данное символическое имя, мы можем ссылаться на нашу домашнюю страницу при помощи создания следующей ссылки внутри какого-либо шаблона:
```html
<a href="{% url 'index' %}">Home</a>.
```

> **Примечание:** Мы могли бы, конечно, жёстко указать прямую ссылку (то есть, `<a href="/catalog/">Home</a>`), но тогда, если мы изменим адрес нашей домашней страницы (например на `/catalog/index`), то данные ссылки перестанут корректно работать. Применение "обратного" url-преобразования более гибкий и эффективный подход!

[Назад к Django](#django)

### Отображения (на основе функций)

Отображение является функцией, которая обрабатывает HTTP-запрос, получает данные из базы данных (при необходимости), которые применяются для генерации страницы HTML. Затем функция отображения возвращает сгенерированную страницу пользователю в виде HTTP-ответа. В нашем случае, индексная функция демонстрирует этот процесс — она получает информацию о количестве записей `Book`, `BookInstance`, доступности `BookInstance`, а также записи `Author` из базы данных, затем передаёт эти записи в шаблон страницы, генерирует страницу и передаёт её пользователю (клиенту пользователя, например браузеру).

Откройте **catalog/views.py** и отметьте для себя, что данный файл уже импортирует функцию [render()](https://docs.djangoproject.com/en/1.10/topics/http/shortcuts/#django.shortcuts.render) - функцию, которая генерирует HTML-файлы при помощи шаблонов страниц и соответствующих данных.
```py
from django.shortcuts import render

# Создайте ваше отображение здесь
```

Скопируйте следующий код в нижнюю часть файла. Первая строка импортирует классы модели, которые мы будем использовать для доступа к данным во всех наших функциях (позже и классах) отображения.
```py
from .models import Book, Author, BookInstance, Genre

def index(request):
    """
    Функция отображения для домашней страницы сайта.
    """
    # Генерация "количеств" некоторых главных объектов
    num_books=Book.objects.all().count()
    num_instances=BookInstance.objects.all().count()
    # Доступные книги (статус = 'a')
    num_instances_available=BookInstance.objects.filter(status__exact='a').count()
    num_authors=Author.objects.count()  # Метод 'all()' применён по умолчанию.

    # Отрисовка HTML-шаблона index.html с данными внутри
    # переменной контекста context
    return render(
        request,
        'index.html',
        context={'num_books':num_books,'num_instances':num_instances,'num_instances_available':num_instances_available,'num_authors':num_authors},
    )
```

Первая часть функции отображения получает количество записей при помощи вызова функции `objects.all()` у атрибута `objects`, доступного для всех классов моделей. Похожим образом мы получаем список объектов `BookInstance`, которые имеют статус 'a' (Доступно). Вы можете найти дополнительную информацию о работе с моделями в предыдущей части руководства ([Руководство часть 3: Применение моделей > Поиск записей](#django-3-использование-моделей)).

В конце функции `index` вызывается функция `render()`, которая, в качестве ответа, создаёт и возвращает страницу HTML (эта функция "оборачивает" вызовы нескольких функций, тем самым существенно упрощая процесс разработки). В качестве параметров ей передаются объект `request` (типа `HttpRequest`), шаблон HTML-страницы с метками (`placeholders`), которые будут замещены данными, а также переменной `context` (словарь Python, который содержит данные, которые и будут замещать метки в шаблоне).

В следующем разделе мы более подробно поговорим о шаблонах и переменной контекста. Давайте создадим наш шаблон, чтобы показать уже что-нибудь пользователю!

[Назад к Django](#django)

### Шаблон

Шаблон это текстовый файл, который определяет структуру и расположение данных в файле, кроме того, в нем размещают специальные метки (placeholders), которые используются для показа реального содержимого, то есть данных. По умолчанию Django ищет файлы шаблонов в директории с именем **'templates'** внутри вашего приложения. Например, внутри индексной функции отображения, которую мы только что создали, вызов `render()` будет пытаться найти файл **/locallibrary/catalog/templates/*index.html*** и в случае неудачи сгенерирует ошибку о том, что файл не найден. Вы можете увидеть данную ошибку, если вы сохраните предыдущие изменения, затем перейдёте в браузер и наберёте в адресной строке `127.0.0.1:8000`. В результате, в окно браузера будет выведено сообщение об ошибке "TemplateDoesNotExist at /catalog/" и некоторая другая информация.

> **Примечание:** На самом деле, в зависимости от настроек проекта, Django просматривает несколько мест в поисках шаблона (поиск в директории приложения осуществляется по умолчанию!). Вы можете найти больше информации о шаблонах и форматах, которые они поддерживают, перейдя по ссылке [Шаблоны](https://docs.djangoproject.com/en/1.10/topics/templates/) (Django docs).

### Расширение шаблонов

Шаблон главной страницы нашего сайта должен соответствовать стандарту разметки HTML для разделов `head` и `body`, кроме того иметь разделы для навигации (на другие страницы, которые мы создадим позже) и показа некоторого вводного текста. Большая часть данной структуры будет одинаковой для всех страниц нашего сайта. Таким образом, чтобы избежать копирования одной и той же информации, язык создания шаблонов Django позволяет вам объявить базовый шаблон, а затем расширить его, замещая только те части, которые являются специфическими для каждой страницы.

Например, базовый шаблон **base_generic.html** может выглядеть как показано ниже. Как вы видите, этот файл содержит некоторую "общую" структуру HTML, разделы для заголовка, панель навигации и содержимое, отмеченное тэгами шаблона `block` и `endblock` (показано жирным). Данные блоки могут быть пустыми, или иметь содержимое, которое будет использоваться "по умолчанию" всеми страницами-наследниками.

> **Примечание:** *Тэги* шаблона подобны функциям, которые могут применяться для создания циклов по спискам, выполнять условные операции и так далее. Кроме тэгов, язык шаблона позволяет использовать переменные (которые передаются в шаблон из отображения), а также *шаблонные фильтры*, которые переформатируют переменные (например, переводят строку в нижний регистр).
```django
<!doctype html>
<html lang="en">
<head>
  {% block title %}<title>Local Library</title>{% endblock %}
</head>

<body>
  {% block sidebar %}<!-- insert default navigation text for every page -->{% endblock %}
  {% block content %}<!-- default content text (typically empty) -->{% endblock %}
</body>
</html>
```

Когда мы определяем шаблон для конкретного отображения, то в первую очередь мы объявляем базовый шаблон (при помощи тэга `extends` — смотрите код в следующем фрагменте). Если имеются блоки в базовом шаблоне, которые мы хотим заместить, тогда в нашем текущем шаблоне мы объявляем `block`/`endblock` и указываем соответствующее имя блока.

Например фрагмент кода, показанный ниже, демонстрирует применение тэга `extends` и переопределяет блок с именем `content`. Окончательный код HTML будет содержать все структуры базового файла шаблона (включая содержимое по умолчанию, которое мы указали в блоке `title`) и код блока `content`, который мы разместили в текущем файле шаблона.
```django
{% extends "base_generic.html" %}

{% block content %}
  <h1>Local Library Home</h1>
  <p>
    Welcome to <em>LocalLibrary</em>, a very basic Django website developed as a
    tutorial example on the Mozilla Developer Network.
  </p>
{% endblock %}
```

[Назад к Django](#django)

### Базовый шаблон сайта LocalLibrary

Базовый шаблон, который мы планируем использовать для сайта *LocalLibrary*, представлен ниже. Как вы видите, данный фрагмент содержит HTML код и объявляет следующие блоки `title`, `sidebar` и `content`. Мы добавили заголовок по умолчанию (который, возможно, мы захотим изменить), а также боковую панель навигации, содержащей ссылки на списки всех книг и авторов (панель навигации, мы, вероятно, не будем менять/замещать, но, тем не менее, добавив этот блок, мы оставим для себя такую возможность).

> **Примечание:** Во фрагменте мы используем два дополнительных шаблонных тега: `url` и `load static`. Они будут описаны в следующих разделах.

Создайте новый файл — **/locallibrary/catalog/templates/base_generic.html** — и добавьте в него следующее содержимое:
```django
<!doctype html>
<html lang="en">
  <head>
    {% block title %}<title>Local Library</title>{% endblock %}
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

    <!-- Добавление дополнительного статического CSS файла -->
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/styles.css' %}" />
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <div class="col-sm-2">
          {% block sidebar %}
            <ul class="sidebar-nav">
              <li><a href="{% url 'index' %}">Home</a></li>
              <li><a href="">All books</a></li>
              <li><a href="">All authors</a></li>
            </ul>
          {% endblock %}
        </div>
        <div class="col-sm-10 ">{% block content %}{% endblock %}</div>
      </div>
    </div>
  </body>
</html>
```

Шаблон использует (и включает в себя) JavaScript и CSS от [Bootstrap](http://getbootstrap.com/) для лучшего размещения элементов и формирования внешнего вида HTML страницы. Применение Bootstrap, или любого другого фреймворка для клиентской части сайта, является довольно продуктивным способом повышения привлекательности страницы, в том числе, это учитывает возможность запроса и показа сайта с устройств, с различными разрешениями экрана, а кроме того, это позволяет нам повысить уровень взаимодействия с пользователем — мы направим большую часть своих усилий на серверную часть нашего сайта!

Базовый шаблон ссылается на локальный файл css (**styles.css**), который предоставляет дополнительные стили. Создайте **/locallibrary/catalog/static/css/styles.css** и добавьте в него следующее содержимое:
```css
.sidebar-nav {
  margin-top: 20px;
  padding: 0;
  list-style: none;
}
```

[Назад к Django](#django)

### Индексный шаблон (шаблон главной страницы сайта)

Создайте файл HTML **/locallibrary/catalog/templates/index.html** и скопируйте в него код, указанный ниже. Как вы наверное заметили, в первой строке мы расширяем наш базовый шаблон, а затем замещаем содержимое блока `content`, базового шаблона, новым содержимым текущего шаблона.
```django
{% extends "base_generic.html" %}

{% block content %}
<h1>Local Library Home</h1>

  <p>Welcome to <em>LocalLibrary</em>, a very basic Django website developed as a tutorial example on the Mozilla Developer Network.</p>

<h2>Dynamic content</h2>

  <p>The library has the following record counts:</p>
  <ul>
    <li><strong>Books:</strong> {{ num_books }}</li>
    <li><strong>Copies:</strong> {{ num_instances }}</li>
    <li><strong>Copies available:</strong> {{ num_instances_available }}</li>
    <li><strong>Authors:</strong> {{ num_authors }}</li>
  </ul>

{% endblock %}
```

В данном фрагменте, в разделе *Динамическое содержимое*, мы объявили метки (*шаблонные переменные*) для информации, которую мы получаем из соответствующего отображения. Данные переменные объявляются при помощи "двойных фигурных скобок" (в предыдущем фрагменте выделено жирным).

> **Примечание:** Переменные шаблона заключаются в двойные фигурные скобки (`{{ num_books }}`) , а тэги шаблона (функции шаблона), помещаются в одинарные фигурные скобки со знаками процента (`{% extends "base_generic.html" %}`).

Важно отметить, что данные переменные имеют имена, соответствующие именам передаваемых ключей из словаря переменной `context`, которая, в свою очередь, передаётся из отображения, во время вызова функции `render()` (смотри ниже). При отрисовке шаблона, вместо этих ключей будут подставлены, соответствующие им, значения.
```py
return render(
    request,
    'index.html',
     context={'num_books':num_books,'num_instances':num_instances,'num_instances_available':num_instances_available,'num_authors':num_authors},
)
```

[Назад к Django](#django)

### Ссылка на статические файлы их шаблонов

Любой ваш проект с большой вероятностью будет использовать статические ресурсы, включая JavaScript, CSS и изображения. В связи с тем, что расположение этих файлов может быть неизвестно (или может измениться), Django позволяет вам в шаблоне указать относительное расположение данных файлов при помощи глобального значения `STATIC_URL` (по умолчанию, значение параметра `STATIC_URL` установлено в '`/static/`', но вы можете выбрать любое другое значение, указав, например, сетевой ресурс, или что-то ещё).

Внутри шаблона вы вызываете функцию (тэг) `load`, которая загружает статическую библиотеку "static" (как показано ниже). После того как статическая библиотека загружена, вы можете использовать тэг шаблона `static`, который указывает относительный путь URL к интересующему вас файлу.
```django
<!-- Добавляем дополнительный статический CSS-файл -->
{% load static %}
<link rel="stylesheet" href="{% static 'css/styles.css' %}" />
```

Тем же способом вы можете загрузить нужное изображение. Например:
```django
{% load static %}
<img
  src="{% static 'catalog/images/local_library_model_uml.png' %}"
  alt="My image"
  style="width:555px;height:540px;" />
```

> **Примечание:** Фрагменты выше указывают пути расположения файлов, но Django не использует их по умолчанию. В процессе разработки сервер использует значения, указанные в глобальном файле URL-преобразований (**/locallibrary/locallibrary/urls.py**), который мы создали в части [создание скелета сайта](#django-2-создание-скелета). В дальнейшем, в продакшене, вам нужно будет уточнить параметры расположения статических файлов. Мы вернёмся к этому позже.

Для получения более подробной информации о работе со статическими файлами обратитесь к документации по ссылке [Управление статическими файлами](https://docs.djangoproject.com/en/1.10/howto/static-files/) (Django docs).

### Построение URL-адресов

Базовый шаблон, указанный выше, вводит тэг `url`.
```py
<li><a href="{% url 'index' %}">Home</a></li>
```

Данный тэг с именем `url()`, ищет в файле **urls.py** связанное значение переменной, указанной в качестве её параметра `'index'`, а затем возвращает URL, который вы можете использовать для ссылки на соответствующие ресурсы.

### Как теперь все это выглядит?

На данный момент мы должны были сделать всё что необходимо, для того, чтобы показать главную страницу нашего сайта. Запустите сервер (`python3 manage.py runserver`) и введите в ваш браузер адрес `http://127.0.0.1:8000/`. Если все настроено как надо, то ваш сайт должен выглядеть как показано на следующей картинке.

![catalog](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Home_page/index_page_ok.png)

> **Примечание:** На данном этапе вы не сможете воспользоваться ссылками на страницы **All books** и **All authors**, потому что url-адреса, отображения и шаблоны для данных страниц не созданы (мы просто объявили метки для соответствующих ссылок в базовом шаблоне `base_generic.html`).

[Назад к Django](#django)

### Проверьте себя

А теперь парочка заданий, чтобы проверить, насколько вы усвоили работу с запросами к моделям базы данных, взаимодействия с отображениями и шаблонами.

1. В главном файле шаблона (**base_generic.html**) есть блок `title`. Переопределите этот блок в индексном шаблоне (**index.html**) и задайте новый заголовок для этой страницы.
2. Модифицируйте функцию отображения таким образом, чтобы получать из базы данных количество жанров и количество книг, которые содержат в своих заголовках какое-либо слово (без учёта регистра), а затем передайте эти значения в шаблон.

### Итог

Мы создали домашнюю страницу для нашего сайта — HTML страница, которая показывает количество некоторых записей из базы данных и содержит ссылки на другие "все-ещё-будут-созданы" страницы. Кроме того, мы изучили большое количество базовой информации об url-преобразованиях, отображениях, запросах к базе данных, используя наши модели, передачу информации из отображений в шаблоны, кроме того, создание и расширение шаблонов.

В следующей части, при помощи наших новых знаний, мы создадим ещё четыре страницы.

- **Смотрите также:**
- [Написание вашего первого приложения Django, часть 3: Отображения и Шаблоны](https://docs.djangoproject.com/en/1.10/intro/tutorial03/) (Django docs)
- [URL-диспетчер](https://docs.djangoproject.com/en/1.10/topics/http/urls/) (Django docs)
- [Функции отображения](https://docs.djangoproject.com/en/1.10/topics/http/views/) (DJango docs)
- [Шаблоны](https://docs.djangoproject.com/en/1.10/topics/templates/) (Django docs)
- [Управление статическими файлами](https://docs.djangoproject.com/en/1.10/howto/static-files/) (Django docs)
- [Удобные (встроенные) функции Django](https://docs.djangoproject.com/en/1.10/topics/http/shortcuts/#django.shortcuts.render) (Django docs)

[Назад к Django](#django)

## Django 6: отображение списков и детальной информации

Данная часть расширяет наш сайт [LocalLibrary](#django-сайт-местной-библиотеки), добавляя в него списки и страницы, путём предоставления подробной информации о книгах и авторах. В текущей части мы подробно изучим обобщённые базовые классы отображения и покажем как они могут существенно сократить количество кода, который вы должны были бы написать в обычной ситуации. Кроме того, мы более подробно рассмотрим управление и настройки URL-адресов, показывая как выполнить простое сопоставление какой-либо строки паттерну регулярного выражения.

|Требования: |Завершить все предыдущие части руководства, включая [Руководство Django Часть 5: Создание домашней страницы](#django-5-cоздание-домашней-страницы).
|----|---
|Цель: |Понимать где и как применять обобщённые базовые классы отображения, и как применять паттерны URL-адресов для передачи информации в отображения.

### Обзор

В данном руководстве мы завершим первую версию сайта [LocalLibrary](#django-сайт-местной-библиотеки), с помощью добавления страницы перечисления и подробной информации о книгах и авторах (или, если быть более точными, мы покажем как вам реализовать соответствующие страницы для книг, а для авторов вы сможете сделать их самостоятельно!)

Данный процесс похож на создание главной страницы сайта, который мы показывали в предыдущей части руководства. Нам все также надо создать URL-преобразования, отображения и шаблоны страниц. Основным отличием будет то, что для страниц подробной информации перед нами встанет дополнительная задача получения информации из паттерна URL-адреса и передачи её отображению. Для этих страниц мы собираемся продемонстрировать совершенно другой тип отображения, основанный на применении обобщённых классов отображения списка и детальной информации о записи. Это может существенно сократить количество кода, необходимого для отображения и сделает его (код) более простым для написания и поддержки.

Завершающая часть данного руководства будет посвящена демонстрации постраничного показа ваших данных (pagination) при применении обобщённого класса отображения списка.

### Страница со списком книг

Страница со списком книг показывает все книги в наличии и будет доступна по адресу: `catalog/books/`. Эта страница для каждой записи выводит заголовок и автора, при этом каждый заголовок является гиперссылкой на соответствующую страницу подробной информации о книге. Данная страница будет иметь ту же структуру и навигацию как и все остальные страницы сайта, таким образом мы сможем расширить базовый шаблон сайта (**base_generic.html**), который мы создали в предыдущей части руководства.

### Преобразования URL-адресов

Откройте файл **/catalog/urls.py** и скопируйте в него путь до `'books/'`, как в примере ниже. Практически так же, как и для главной страницы сайта, функция `path()` определяет регулярное выражение, по которому проверяется адрес (**'books/'**), функцию отображения, которая вызовется при совпадении адресов (`views.BookListView.as_view()`), и название для этого конкретного преобразования.
```py
urlpatterns = [
    path('', views.index, name='index'),
    path('books/', views.BookListView.as_view(), name='books'),
]
```

Как было отмечено в предыдущей части руководства, URL-адрес уже должен содержать `/catalog`, и таким образом полный адрес, на самом деле, имеет вид `/catalog/books/`.

Функция отображения имеет другой формат, чем прежде — это связано с тем, что данное отображение реализуется через класс. Мы будем наследоваться от существующей общей функции из **view**, которая уже делает большую часть того, что мы хотим, вместо того, чтобы писать свою собственную функцию во **view** с нуля.

При использовании обобщённых классов отображения в Django мы получаем доступ к соответствующей функции отображения при помощи вызова метода `as_view()`. Таким образом выполняется вся работа по созданию экземпляра класса и гарантируется вызов правильных методов для входящих HTTP-запросов.

[Назад к Django](#django)

### Отображение (на основе базового класса)

Мы могли бы достаточно просто реализовать отображение списка книг при помощи обычной функции (также, как мы сделали это для главной страницы сайта), которая должны была бы выполнить запрос получения всех книг из базы данных, затем вызвать функцию `render()`, в которую передать данный список, в соответствующий шаблон страницы. Тем не менее, вместо это мы будем использовать обобщённый класс отображения списка — класс, который наследуется от существующего отображения (ListView). Поскольку обобщённый класс уже реализует большую часть того, что нам нужно, и следуя лучшим практикам Django, мы сможем создать более эффективный список при помощи меньшего количества кода, меньшего количества повторений и гораздо лучшей поддержкой.

Откройте **catalog/views.py** и скопируйте следующий код, в нижнюю часть данного файла:
```py
from django.views import generic

class BookListView(generic.ListView):
    model = Book
```

Это всё! Обобщённое отображение выполнит запрос к базе данных, получит все записи заданной модели (`Book`), затем отрендерит (отрисует) соответствующий шаблон, расположенный в **/locallibrary/catalog/templates/catalog/book_list.html** (который мы создадим позже). Внутри данного шаблона вы можете получить доступ к списку книг при помощи переменной шаблона `object_list` ИЛИ `book_list` (если обобщить, то "`the_model_name_list`").

> **Примечание:** Этот, выглядящий странно, путь к файлу шаблона не является опечаткой — обобщённое отображение ищет файл шаблона `/application_name/the_model_name_list.html` (`catalog/book_list.html`, в данном случае) внутри директории приложения `/application_name/templates/` (у нас - `/catalog/templates/`).

Вы можете использовать атрибуты для того, чтобы изменить поведение по умолчанию. Например, вы могли бы указать другой файл шаблона, например, если в вашем распоряжении имеется несколько отображений, которые используют одну и ту же модель, или вам позарез захотелось бы использовать другое имя переменной шаблона, если `book_list` не является интуитивно понятным. Возможно, наиболее полезным вариантом является изменение/отфильтрованные результата запроса к базе данных — таким образом, вместо перечисления всех книг вы могли бы показывать 5 наиболее популярных.
```py
class BookListView(generic.ListView):
    model = Book
    context_object_name = 'my_book_list'   # ваше собственное имя переменной контекста в шаблоне
    queryset = Book.objects.filter(title__icontains='war')[:5] # Получение 5 книг, содержащих слово 'war' в заголовке
    template_name = 'books/my_arbitrary_template_name_list.html'  # Определение имени вашего шаблона и его расположения
```

### Переопределение методов в классах отображения

Пока что вам не приходилось этого делать, но у вас имеется возможность переопределять некоторые методы класса отображения.

Например, мы можем переопределить метод получения списка всех записей `get_queryset()`. Данный подход является более гибким, чем использование атрибута `queryset`, как мы сделали в предыдущем фрагменте кода (хотя, в данном случае и нет никакой разницы):
```py
class BookListView(generic.ListView):
    model = Book

    def get_queryset(self):
        return Book.objects.filter(title__icontains='war')[:5] # Получить 5 книг, содержащих 'war' в заголовке
```

Мы также могли бы переопределить метод `get_context_data()` для того, чтобы в контексте (в переменной контекста) передавать шаблону дополнительные переменные (например, список книг передаётся по умолчанию). Фрагмент, представленный ниже, показывает как добавить переменную с именем "some_data" в контекст (затем она будет доступна как переменная шаблона).
```py
class BookListView(generic.ListView):
    model = Book

    def get_context_data(self, **kwargs):
        # В первую очередь получаем базовую реализацию контекста
        context = super(BookListView, self).get_context_data(**kwargs)
        # Добавляем новую переменную к контексту и инициализируем её некоторым значением
        context['some_data'] = 'This is just some data'
        return context
```

В процессе выполнения всего этого важно придерживаться определённой последовательности действий:

- В первую очередь - получить существующий контекст из нашего суперкласса.
- Затем добавить в контекст новую информацию.
- Затем вернуть новый (обновлённый) контекст.

> **Примечание:** Посмотрите [Встроенные обобщённые классы отображения](https://docs.djangoproject.com/en/1.10/topics/class-based-views/generic-display/) (Django docs) для ознакомления с большим количеством примеров того, что вы могли бы сделать.

[Назад к Django](#django)

### Создание шаблона Отображения Списка

Создайте HTML-файл **/locallibrary/catalog/templates/catalog/book_list.html** и скопируйте в него текст, указанный ниже. Как было отмечено ранее, это файл шаблона по умолчанию, который будет "искать" обобщённый класс отображения списка (для модели с именем `Book` в приложении с именем `catalog`).

Шаблоны для обобщённых отображений такие же как все остальные шаблоны (хотя, естественно, передаваемые в них контекст, или информация могут отличаться). Так же как и с нашим шаблоном для главной страницы, в первой строке мы расширяем наш базовый шаблон, а затем определяем и замещаем блок с именем `content`.
```django
{% extends "base_generic.html" %}

{% block content %}
    <h1>Book List</h1>

    {% if book_list %}
    <ul>

      {% for book in book_list %}
      <li>
        <a href="{{ book.get_absolute_url }}">{{ book.title }}</a> ({{book.author}})
      </li>
      {% endfor %}

    </ul>
    {% else %}
      <p>There are no books in the library.</p>
    {% endif %}
{% endblock %}
```

По умолчанию отображение передаёт контекст (список книг) как `object_list` и `book_list` (синонимы; оба варианта будут работать).

### Условные ветвления

Мы применяем теги шаблона [`if`](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#if), `else` и `endif` для того, чтобы проверить определена ли переменная book_list и содержит ли она данные. Если список НЕ пуст, тогда мы выполняем итерации по списку книг. Если список пуст (`else`-случай) тогда мы показываем текст, поясняющий, что в наличии нет книг.
```dj
{% if book_list %}
  <!-- здесь наш код "бежит" по списку книг -->
{% else %}
  <p>В библиотеке книг нет.</p>
{% endif %}
```

В данном фрагменте проверяется только одно условие, но вы можете протестировать другие варианты при помощи тэга шаблона `elif` (например, `{% elif var2 %}` ). Для дополнительной информации по данной теме смотрите: [if](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#if), ifequal/[ifnotequal](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#ifequal-and-ifnotequal) и [ifchanged](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#ifchanged) в главе [Встроенные тэги и фильтры шаблона](https://docs.djangoproject.com/en/1.10/ref/templates/builtins) (Django Docs).

[Назад к Django](#django)

### Цикл For

Шаблон использует тэги [for](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#for) и `endfor` для того, чтобы "пробежаться" по списку книг, как показано ниже. На каждой итерации (каждом цикле) в переменную шаблона `book` передаётся информация текущего элемента списка.
```django
{% for book in book_list %}
  <li><!-- здесь код, который использует информацию из каждого элемента book списка--></li>
{% endfor %}
```

Мы не применяем здесь, но внутри каждого цикла Django создаёт переменные, которые вы можете использовать при итерации. Например, вы можете проверять переменную `forloop.last` (указывает на последнюю итерацию в цикле) для выполнения каких-либо завершающих действий для данного цикла.

### Доступ к переменным

Код внутри цикла создаёт экземпляр для каждой книги из списка, при помощи которой показывается заголовок (как ссылка на "скоро-будет-сделано" подробное отображение) и автора книги.
```html
<a href="{{ book.get_absolute_url }}">{{ book.title }}</a> ({{book.author}})
```

Мы получаем доступ к полям соответствующей записи о книге при помощи "дот-нотации", то есть через точку (например, `book.title` и `book.author`), где текст, который идёт после `book`, является именем поля (так, как определено в модели).

Кроме того, внутри нашего шаблона, мы можем вызывать *функции* модели — в данном случае, мы вызываем `Book.get_absolute_url()` для получения URL-адреса, который мы используем для показа детальной информации о книге. Данный вызов работает только для функции у которой нет аргументов (в шаблоне не существует возможности передать аргументы в функцию!)

> **Примечание:** Мы должны быть достаточно осмотрительными для того, чтобы избегать "сторонних эффектов" когда мы вызываем функции из шаблона. В данном случае мы просто получаем URL-адрес, но функции могут делать всё что угодно — мы не хотели бы "убить" наша базу данных (например) просто отрендеривая наш шаблон!

### Обновление базового шаблона

Откройте файл базового шаблона (`/locallibrary/catalog/templates/base_generic.html`) и вставьте `{% url 'books' %}` в URL-ссылку для пункта **All books**, как показано ниже. Тем самым, мы создали "переход" на страницу с книгами (теперь мы можем смело это сделать, поскольку у нас имеется соответствующее "книжное" url-преобразование).
```py
<li><a href="{% url 'index' %}">Home</a></li>
<li><a href="{% url 'books' %}">All books</a></li>
<li><a href="">All authors</a></li>
```

- Как же теперь все это выглядит?

Пока что у вас нет возможности создать список книг, потому что мы не учли ещё необходимые зависимости — преобразование URL-адреса для страниц с подробной информации о книге, которое необходимо для ссылок на отдельные книги. Мы покажем страницы со списком и подробной информацией о книге после следующего раздела.

[Назад к Django](#django)

### Страница с подробной информацией о книге

Доступ к странице с подробной информацией о книге осуществляется при помощи URL-адреса `catalog/book/<id>` (где `<id>` является первичным ключом для данной книги). В дополнение к полям модели `Book` (автор, краткое содержание, ISBN, язык и жанр), также мы перечислим детали доступных экземпляров книги (`BookInstances`) включая их статус, ожидаемую дату возврата, штамп (imprint) и id. Это должно позволить нашим читателям не просто узнать о книге, но также убедиться, имеется ли она в наличии и/или когда будет доступна.

### URL-преобразования

Откройте **/catalog/urls.py** и добавьте '**book-detail**' URL-преобразование, отмеченное жирным в следующем фрагменте. Эта функция `url()` определяет паттерн, связанный с обобщённым классом отображения детальной информации, а также имя для данной связи.
```py
from django.urls import path
from . import views
from django.conf.urls import url

urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^books/$', views.BookListView.as_view(), name='books'),
    url(r'^book/(?P<pk>\d+)$', views.BookDetailView.as_view(), name='book-detail'),
]
```

В отличие от предыдущих преобразований, в данном случае мы применяем наше регулярное выражение (РВ) для сопоставления "настоящего паттерна", а не просто строки. Данное РВ сопоставляет любой URL-адрес, который начинается с `book/`, за которым до конца строки (до маркера конца строки - $) следуют одна, или более *цифр*. В процессе выполнения данного преобразования, оно "захватывает" цифры и передаёт их в функцию отображения как параметр с именем `pk`.

> **Примечание:** Как было отмечено ранее, наш преобразуемый URL-адрес в реальности выглядит вот так `catalog/book/<digits>` (потому что мы находимся в приложении **catalog**, то подразумевается каталог `/catalog/`).

> **Предупреждение: Важно:** Обобщённый класс отображения подробной информации ожидает получить параметр с именем `pk`. Если вы пишете свою собственную функцию отображения, то тогда вы можете использовать параметр с любым именем, который пожелаете, или вообще передавать информацию в безымянном аргументе.

[Назад к Django](#django)

### Отдельный пример с регулярными выражениями

Паттерны [регулярного выражения](https://docs.python.org/3/library/re.html) является невероятно мощным инструментом преобразования. Пока что, мы не очень много говорили о них, поскольку мы сопоставляли URL-адреса с простыми строками (а не паттернами), и потому что они не интуитивны и пугающий для начинающих.

> **Примечание:** Без паники! Мы будем рассматривать и использовать достаточно простые паттерны и при этом хорошо задокументированные!

В первую очередь вы должны знать что обычно регулярные выражения объявляются при помощи строкового литерала (то есть, они заключены в кавычки: **r'<ваше регулярное выражение>'**).

Главными элементами синтаксиса объявления паттерна, который вы должны знать, являются:

| Символ | Значение
|---|--
| ^ | Соответствует началу строки
| $ | Соответствует концу строки
| \d | Соответствует цифре (0, 1, 2, ... 9)
| \w | Соответствует любому символу из алфавита в верхнем- или нижнем- регистре, цифре, или символу подчёркивания (`_`)
| + | Соответствует **одному, или более** предыдущему символу. Например, для соответствия **одной, или более** цифре вы должны использовать `\d+`. Для **одного и более** символа "a", вы можете использовать `a+`
| * | Соответствует отсутствию вообще, или присутствию **одного, или более** предыдущему символу. Например, для соответствия "ничему", или слову (то есть, любому символу) вы можете использовать `\w*`
| () | Захват части паттерна внутри скобок. Любое захваченное значение будет передано отображению как безымянный параметр (если захватывается множество паттернов, то соответствующие параметры будут поставляться в порядке их объявления).
| (? P\<name>) | Захват части паттерна (обозначенного через ...) как именованной переменной (в данном случае \<name>). Захваченные значения передаются в отображение с определённым именем. Таким образом, ваше отображение должно объявить аргумент с тем же самым именем!
| [] | Соответствует одному символу из множества. Например, `[abc]` будет соответствовать либо `'a'`, или `'b'`, или `'c'`. `[-\w]` будет соответствовать либо символу `'-'` , или любому другому словарному символу.

Большинство других символов могут быть заданы буквально!

Давайте рассмотрим несколько реальных примеров паттернов:

| Паттерн | Описание
|-----|---
| **r'^book/(?P<pk>\d+)$'** | Это РВ применяется в нашем url-преобразовании. Оно соответствует строке, которая начинается с `book/` (**^book/**), затем имеет одну, или более цифр (`\d+`), а затем завершается (цифрой и только цифрой).Оно также захватывает все цифры **(?P<pk>\d+)** и передаёт их в отображение, в параметре с именем `'pk'`. **Захваченные значения всегда передаются как строка!** Например, данному паттерну должна соответствовать следующая строка `book/1234` , которая отправляет переменную `pk='1234'` в отображение.
| **r'^book/(\d+)$'** | Этот паттерн соответствует тем же самым URL-адресам как и в предыдущем случае. Захваченная информация будет отправлена в отображение как безымянный параметр.
| **r'^book/(?P<stub>[-\w]+)$'** | Данный паттерн соответствует строке, которая начинается с `book/` (**^book/**), затем идут один, или более символов либо `'-'`, или словарные символы (**[-\w]+**), а затем завершается. Он также захватывает данное множество символов и передаёт их в отображение в параметре с именем `'stub'`. Это довольно типичный паттерн для **"стаба"**. Стабы являются дружественными URL-адресами - первичными ключами для данных. Вы могли бы применить стаб, если вы захотели бы, чтобы URL-адрес вашей книги был более информативным. Например, `/catalog/book/the-secret-garden`, выглядит немного лучше чем `/catalog/book/33`.

Вы можете захватить (указать) несколько паттернов в одном преобразовании и, тем самым, закодировать много различной информации в URL-адресе.

> **Примечание:** В качестве дополнительного задания, рассмотрите возможность того, как вы могли бы закодировать url на список всех книг, вышедших в определённый год, месяц, день и какое РВ (паттерн) должно соответствовать этому.

### Передача дополнительных настроек в ваши преобразования URL-адресов

Одной возможностью, которую мы не применяли здесь, но которая могла бы быть вам полезной, является то, что вы можете объявлять и передавать [дополнительные настройки](https://docs.djangoproject.com/en/1.10/topics/http/urls/#views-extra-options) в отображения. Данные настройки объявляются как словарь, который вы передаёте как третий безымянный аргумент функции `url()`. Этот способ может быть полезен, если вы хотите воспользоваться тем же самым отображением для нескольких ресурсов и передавать данные для изменения его поведения в каждом отдельном случае (ниже, мы передаём разные имена шаблонов).
```py
url(r'^/url/$', views.my_reused_view, {'my_template_name': 'some_path'}, name='aurl'),
url(r'^/anotherurl/$', views.my_reused_view, {'my_template_name': 'another_path'}, name='anotherurl'),
```

> **Примечание:** И дополнительные настройки, и именованные захваченные паттерны передаются в отображение как именованные параметры. Если вы используете одинаковое имя и для захваченного паттерна и для дополнительной настройки, то последняя будет отброшена, а в отображение будет передано значение захваченного паттерна.

[Назад к Django](#django)

### Отображение (на основе класса)

Откройте **catalog/views.py**, и скопируйте следующий код в нижнюю часть файла:
```py
class BookDetailView(generic.DetailView):
    model = Book
```

Это всё! Все что вам надо теперь сделать это создать шаблон с именем /**locallibrary/catalog/templates/catalog/book_detail.html**, а отображение передаст ему информацию из базы данных для определённой записи `Book`, выделенной при помощи URL-преобразования. Внутри шаблона вы можете получить доступ к списку книг при помощи переменной с именем object или book (обобщённо "`the_model_name`").

Если у вас имеется необходимость, то вы можете изменить текущий шаблон и/или имя объекта контекста, используемого для ссылки на книгу в шаблоне. Кроме того, вы можете переопределить методы, например, для добавления дополнительной информации к контексту.

- **Что произойдёт, если записи не существует?**

Если запрашиваемой записи не существует, тогда обобщённый класс отображения подробной информации автоматически "выкинет" исключение `Http404` — в продакшене это приведёт к автоматическому отображению страницы с текстом "resource not found" ("ресурс не найден"), которую, конечно же, вы можете настроить по своему усмотрению.

Просто для иллюстрации идеи как это могло бы работать, мы приведём фрагмент кода, демонстрирующего возможную реализацию отображения в виде функции, если по каким-либо причинам вы не используете отображение на основе обобщённого класса.
```py
def book_detail_view(request,pk):
    try:
        book_id=Book.objects.get(pk=pk)
    except Book.DoesNotExist:
        raise Http404("Book does not exist")

    #book_id=get_object_or_404(Book, pk=pk)

    return render(
        request,
        'catalog/book_detail.html',
        context={'book':book_id,}
    )
```

В первую очередь отображение пытается получить определённую запись о книге из модели. Если ей это не удаётся, то "выбрасывается" исключение `Http404`, которое сигнализирует, что данная книга не найдена "not found". Последним шагом является, как обычно, вызов функции `render()` с именем соответствующего шаблона и данных о книге, передаваемых в параметре с именем context (в виде словаря).

> **Примечание:** Функция `get_object_or_404()` (показана закомментированной) является удобным "ярлыком" для генерации исключения `Http404` если запись не найдена.

[Назад к Django](#django)

### Создание шаблона детальной информации

Создайте HTML файл **/locallibrary/catalog/templates/catalog/book_detail.html** и скопируйте в него содержимое, представленное ниже. Как было указано ранее, это шаблон "по умолчанию" (имя шаблона), который "ожидается"обобщённым классом отображения детальной информации (для модели с именем `Book` в приложении с именем `catalog`).
```django
{% extends "base_generic.html" %}

{% block content %}
  <h1>Title: {{ book.title }}</h1>

  <p><strong>Author:</strong> <a href="">{{ book.author }}</a></p> <!-- author detail link not yet defined -->
  <p><strong>Summary:</strong> {{ book.summary }}</p>
  <p><strong>ISBN:</strong> {{ book.isbn }}</p>
  <p><strong>Language:</strong> {{ book.language }}</p>
  <p><strong>Genre:</strong> {% for genre in book.genre.all %} {{ genre }}{% if not forloop.last %}, {% endif %}{% endfor %}</p>

  <div style="margin-left:20px;margin-top:20px">
    <h4>Copies</h4>

    {% for copy in book.bookinstance_set.all %}
    <hr>
    <p class="{% if copy.status == 'a' %}text-success{% elif copy.status == 'd' %}text-danger{% else %}text-warning{% endif %}">{{ copy.get_status_display }}</p>
    {% if copy.status != 'a' %}<p><strong>Due to be returned:</strong> {{copy.due_back}}</p>{% endif %}
    <p><strong>Imprint:</strong> {{copy.imprint}}</p>
    <p class="text-muted"><strong>Id:</strong> {{copy.id}}</p>
    {% endfor %}
  </div>
{% endblock %}
```

> **Примечание:** Ссылка на автора в шаблоне содержит пустой URL-адрес, потому что мы ещё не создали страницу детальной информации об авторе. Когда это произойдёт, вы должны будете обновить данный URL-адрес как указано ниже:
> ```django
> <a href="{% url 'author-detail' book.author.pk %}">{{ book.author }}</a>
> ```

Хотя и несколько больше, но почти все в данном шаблоне нам уже встречалось ранее:

- Мы расширяем наш базовый шаблон и переопределяем блок `content`.
- Мы используем условие `if` для показа того, или иного содержимого.
- Мы используем циклы `for` того, чтобы пробежаться по элементам (объектам) в соответствующих списках.
- Мы получаем доступ к полям контекста при помощи "дот-нотации" (поскольку мы использовали обобщённый класс отображения детальной информации, то контекст имеет имя `book`; также можем использовать имя `object`)

Одной интересной вещью, которую мы не видели ранее, является функция `book.bookinstance_set.all()`. Данный метод является "автомагически"-сконструированным Django для того, чтобы вернуть множество записей `BookInstance`, связанных с данной книгой `Book`.
```django
{% for copy in book.bookinstance_set.all %}
<!-- итерации по каждой копии/экземпляру книги -->
{% endfor %}
```

Этот метод создан, потому что вы, на стороне "многим" данной связи, объявили поле `ForeignKey` (один-ко многим). Поскольку вы ничего не объявили на другой стороне ("один") данной модели (то есть, модель `Book` "ничего не знает" про модель `BookInstance`), то она не имеет никакой возможности (по умолчанию) для получения множества соответствующих записей. Для того, чтобы обойти эту проблему, Django конструирует соответствующую функцию "обратного просмотра" ("reverse lookup"), которой вы можете воспользоваться. Имя данной функции создаётся в нижнем регистре и состоит из имени модели, в которой был объявлен `ForeignKey` (то есть, `bookinstance`), за которым следует `_set` (то есть функция, созданная для `Book` будет иметь вид `bookinstance_set()`).

> **Примечание:** Здесь мы используем `all()` для получения всех записей (по умолчанию). Вы, наверное, могли бы использовать метод `filter()` для получения подмножества записей в коде, но, к сожалению, вы НЕ можете применить данный вызов в шаблоне, потому что вы не можете передать в нем (в шаблоне) аргументы в функцию.
>
> Обратите внимание, что если вы не определяете порядок выдачи данных (в вашем отображении, или в модели), то сервер разработки "выкинет" сообщения об ошибках, похожие на следующие:
>
> ```[29/May/2017 18:37:53] "GET /catalog/books/?page=1 HTTP/1.1" 200 1637
> /foo/local_library/venv/lib/python3.5/site-packages/django/views/generic/list.py:99: UnorderedObjectListWarning: Pagination may yield inconsistent results with an unordered object_list: <QuerySet [<Author: Ortiz, David>, <Author: H. McRaven, William>, <Author: Leigh, Melinda>]>
>   allow_empty_first_page=allow_empty_first_page, **kwargs)
> ```
> Это случилось потому что, [paginator object](https://docs.djangoproject.com/en/1.10/topics/pagination/#paginator-objects) (далее объект постраничного вывода) ожидает видеть некую упорядоченность ORDER BY при запросе к базе данных. Без этого, он не сможет гарантировать правильный вывод полученных данных!
>
> Данное руководство пока не дошло до описания **Pagination** (пока, но скоро будет), и поскольку вы не можете использовать функцию `sort_by()` и передавать параметр (по той же причине, что и `filter()`) вы должны выбрать один из трёх вариантов дальнейших действий:
>
> 1. Добавить атрибут `ordering` внутри `Meta-класса` объявленного в вашей модели.
> 2. Добавить атрибут `queryset` в вашей реализации класса отображения, определяющего `order_by()`.
> 3. Добавить метод `get_queryset` в вашу реализацию класса отображения и также определить метод `order_by()`.
>
> Если вы выбрали пункт номер один с Meta-классом для модели Author (вероятно, не такой гибкий как вариант с настройкой класса отображения, но тем не менее, достаточно простой), вы должны прийти к чему-то похожему на следующее:
>
> ```py
> class Author(models.Model):
>     first_name = models.CharField(max_length=100)
>     last_name = models.CharField(max_length=100)
>     date_of_birth = models.DateField(null=True, blank=True)
>     date_of_death = models.DateField('Died', null=True, blank=True)
> 
>     def get_absolute_url(self):
>         return reverse('author-detail', args=[str(self.id)])
> 
>     def __str__(self):
>         return '%s, %s' % (self.last_name, self.first_name)
> 
>     class Meta:
>         ordering = ['last_name']
> ```
>
> Конечно же, поле не обязательно должно иметь имя `last_name`: оно может быть любым.
>
> И последнее, но не окончательное, вы должны сортировать по атрибуту/колонке, которая была проиндексирована (уникально, или нет) в вашей базе данных для того, чтобы избежать проблем с быстродействием. Конечно, это не является необходимым в данном примере (и мы, вероятно, забегаем далеко вперёд), если у нас такое небольшое количество книг (и пользователей!), но это необходимо помнить для будущих проектов.

[Назад к Django](#django)

### Как это теперь выглядит?

На данный момент мы должны были создать все необходимое для показа страниц со списком книг и детальной информацией. Запустите сервер (`python3 manage.py runserver`) и откройте ваш браузер `http://127.0.0.1:8000/`.

> **Предупреждение:** Не кликайте на каком-либо авторе, - ссылки пока не заданы — это будет вашим дополнительным заданием!

Кликните ссылку **All books** для перехода на страницу со списком книг.

![Book list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/book_list_page_no_pagination.png)

Затем кликните на ссылку одной из ваших книг. Если все настроено как надо, то вы должны увидеть то, что указано на картинке.

![about book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/book_detail_page_no_pagination.png)

[Назад к Django](#django)

### Постраничный вывод (Pagination)

Если у вас всего лишь несколько записей в базе данных, то наша страница вывода списка книг будет выглядеть отлично. Тем не менее, когда у вас появятся десятки, или сотни записей ваша страница станет значительно дольше загружаться (и станет слишком длинной для комфортного просмотра). Решением данной проблемы является добавление постраничного вывода (Pagination) к вашему отображению списка, который будет выводить ограниченное количество элементов на каждой странице.

Django имеет отличный встроенный механизм для постраничного вывода. Даже более того, он встроен в обобщённый класс отображения списков, следовательно вам не нужно проделывать большой объем работы, чтобы воспользоваться возможностями постраничного вывода!

### Отображения

Откройте **catalog/views.py** и добавьте поле `paginate_by` как показано в следующем фрагменте.
```py
class BookListView(generic.ListView):
    model = Book
    paginate_by = 10
```

Как только у вас появится более 10 записей в базе данных отображение начнёт формировать постраничный вывод данных, которые он передаёт шаблону. К различным страницам данного вывода можно получить доступ при помощи параметров GET-запроса — к странице 2 вы можете получить доступ, используя URL-адрес: `/catalog/books/?page=2`.

### Шаблоны

Теперь, когда данные выводятся постранично, нам надо добавить функциональность переключения между страницами в шаблона страницы. Поскольку мы хотели бы использовать данный механизм для всех списков на сайте, то мы пропишем его в базовом шаблоне сайта.

Откройте **/locallibrary/catalog/templates/base_generic.html** и, ниже блока `content`, вставьте блок (во фрагменте не выделен жирным), отвечающий за постраничный вывод. Данный код, в первую очередь, проверяет "включён" ли механизм постраничного вывода для данной страницы и если это так, то он добавляет ссылки `next` и `previous`, соответственно (а также, номер текущей страницы).
```django
{% block content %}{% endblock %}

{% block pagination %}
  {% if is_paginated %}
    <div class="pagination">
      <span class="page-links">
        {% if page_obj.has_previous %}
          <a href="{{ request.path }}?page={{ page_obj.previous_page_number }}">previous</a>
        {% endif %}
        <span class="page-current">
          Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}.
        </span>
        {% if page_obj.has_next %}
          <a href="{{ request.path }}?page={{ page_obj.next_page_number }}">next</a>
        {% endif %}
      </span>
    </div>
  {% endif %}
{% endblock %}
```

Параметр `page_obj` является объектом типа [Paginator](https://docs.djangoproject.com/en/1.10/topics/pagination/#paginator-objects), который будет создаваться каждый раз, когда будет применяться постраничный вывод данных для текущей страницы. Он позволяет получить всю информацию о текущей странице, о предыдущих страницах, сколько всего страниц и так далее.

Мы используем `{{ request.path }}` для получения URL-адреса текущей страницы, для того, чтобы создать ссылки на соответствующие страницы, обратите внимание, что данный вызов не зависит от объекта `page_obj` и, таким образом, может использоваться отдельно.

На этом все!

[Назад к Django](#django)

### Как это выглядит?

Картинка ниже показывает как выглядит постраничный вывод — если вы не добавили более 10 записей в вашу базу данных, тогда вы можете проверить как это работает, просто уменьшив значение в `paginate_by`, в файле **catalog/views.py**. Для получения результата, соответствующего картинке ниже, мы изменили `paginate_by = 2`.

Ссылки на страницы показаны в нижней части страницы. Показаны ссылки следующая/предыдущая в зависимости от того на какой странице вы в данный момент находитесь.

![List Page paginated](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/book_list_paginated.png)

### Проверьте себя

Дополнительным задание в данной статье и для завершения данного этапа проекта будет создание отображений детальной информации об авторе и их списка. Эти отображения должны находиться по следующим адресам:

- `catalog/authors/` — Список авторов.
- `catalog/author/<id>` — Детальная информация об авторе со значением первичного ключа равным `<id>`

Соответствующий код для URL-преобразований и отображений должен быть идентичным коду для списка книг и детальной информации о книге `Book`, который мы создали ранее. Шаблоны будут отличаться, но будут иметь похожее поведение.

> **Примечание:**
>
> - Когда вы создадите URL-преобразование для страницы списка авторов вам понадобится обновить ссылку All authors в базовом шаблоне. Следуйте тем же путём, который мы проделали когда обновляли ссылку All books.
> - Когда вы создадите URL-преобразование для страницы с детальной информацией об авторе, вы должны будете обновить шаблон детальной информации о книге (/locallibrary/catalog/templates/catalog/book_detail.html), таким образом, чтобы ссылка автора указывала на страницу с детальной информации о нем (а не быть пустой). Данная ссылка будет иметь вид как указано жирным во фрагменте ниже.
>
> ```django
> <p>
>   <strong>Author:</strong>
>   <a href="{% url 'author-detail' book.author.pk %}">{{ book.author }}</a>
> </p>
> ```

Когда вы закончите, ваши страницы должны будут выглядеть как на картинке.

![pic1](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/author_list_page_no_pagination.png)

![pic2](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/author_detail_page_no_pagination.png)

[Назад к Django](#django)

### Итоги

Поздравляем! Наша базовая функциональность библиотеки готова!

В данной статье мы изучили как применять обобщённые классы отображения списка и детальной информации, и использовать их для создания страниц отображения наших книг и авторов. Кроме того, мы многое узнали о паттернах преобразования, построенных на основе регулярных выражений, а также то, как вы можете передавать данные из URL-адреса в ваше отображение. Мы изучили несколько приёмов применения шаблонов. В самом конце мы показали как осуществлять постраничный вывод списков, так, что наши списки управляются даже тогда, когда они содержат много записей.

В нашей следующей статье мы расширим нашу библиотеку, путём поддержки пользовательских аккаунтов, и так образом продемонстрируем аутентификацию, разграничение уровней доступа, сессии и формы.

- **Дополнительная информация**
- [Встроенные обобщённые классы отображения](https://docs.djangoproject.com/en/1.10/topics/class-based-views/generic-display/) (Django docs)
- [Обобщённый вид отображения](https://docs.djangoproject.com/en/1.10/ref/class-based-views/generic-display/) (Django docs)
- [Введение в отображения на основе классов](https://docs.djangoproject.com/en/1.10/topics/class-based-views/intro/) (Django docs)
- [Встроенные теги шаблона и фильтры](https://docs.djangoproject.com/en/1.10/ref/templates/builtins) (Django docs).
- [Постраничный вывод (Pagination)](https://docs.djangoproject.com/en/1.10/topics/pagination/) (Django docs)

[Назад к Django](#django)

## Django 7: сессии

Эта часть расширяет наш сайт LocalLibrary, добавляя счётчик посещений домашней страницы, реализованного при помощи сессий. Это относительно простой пример, но он демонстрирует то, как при помощи сессий реализовать анализ поведения анонимных пользователей на сайте.

| Требования: | Завершить изучение всех предыдущих разделов, включая Django [Руководство Часть 6: Обобщённые отображения списков и детальной информации](#django-6-отображение-списков-и-детальной-информации)
|----|----
| Цель: | Понимать как применять сессии.

### Обзор

В предыдущих частях мы создали сайт [LocalLibrary](#django-сайт-местной-библиотеки), который позволяет пользователям получать из каталога списки книг и авторов. На данный момент каждый посетитель сайта получает доступ к одним и тем же страницам и типам информации динамически сформированными из базы данных.

В "настоящей" библиотеке вам хотелось бы предоставить пользователю индивидуальные услуги, которые зависят от его предпочтений и предыдущего опыта использования сайта, его настроек и тому подобное. Например, при очередном посещении сайта вы можете скрыть сообщения об ошибках для тех пользователей, которые их уже получали, или сохранить и учитывать пользовательские настройки (например, количество выводимых данных на странице как результат какого-либо поиска).

Сессии позволяют вам реализовать такой род функциональности, который позволит вам хранить и получать произвольные данные, полученные на основе индивидуального поведения пользователя на сайте.

### Что такое сессии?

Все взаимодействия между браузерами и серверами осуществляются при помощи протокола HTTP, который не сохраняет своё состояние (stateless). Данный факт означает, что сообщения между клиентом и сервером являются полностью независимыми один от другого — то есть не существует какого-либо представления "последовательности", или поведения в зависимости от предыдущих сообщений. В результате, если вы хотите создать сайт, который будет отслеживать взаимодействие с клиентом (браузером), вам нужно реализовать это самостоятельно.

Сессии являются механизмом, который использует Django (да и весь остальной "Интернет") для отслеживания "состояния" между сайтом и каким-либо браузером. Сессии позволяют вам хранить произвольные данные браузера и получать их в тот момент, когда между данным браузером и сайтом устанавливается соединение. Данные получаются и сохраняются в сессии при помощи соответствующего "ключа".

Django использует куки (cookie), которые содержат специальный идентификатор сессии, который выделяет среди остальных, каждый браузер и соответствующую сессию. Реальные данные сессии, по умолчанию, хранятся в базе данных сайта (это более безопасно, чем сохранять данные в куки, где они могут быть уязвимы для злоумышленников). Однако, у вас есть возможность настроить Django так, чтобы сохранять данные сессий в других местах (кеше, файлах, "безопасных" куки). Но всё же хранение по умолчанию является хорошей и безопасной возможностью.

[Назад к Django](#django)

### Подключение сессий

Сессии стали доступны автоматически в тот момент, когда мы [создали скелет сайта](#django-2-создание-скелета) (во второй части руководства).

Необходимые конфигурации выполняются в разделах INSTALLED_APPS и MIDDLEWARE файла проекта (**locallibrary/locallibrary/settings.py**), как показано ниже:
```py
INSTALLED_APPS = [
    ...
    'django.contrib.sessions',
    ....

MIDDLEWARE = [
    ...
    'django.contrib.sessions.middleware.SessionMiddleware',
    ....
```

### Применение сессий

Вы можете получить доступ к переменной `session`, в соответствующем отображении, через параметр `request` (`HttpRequest` передаётся как первый аргумент в каждое отображение). Переменная сессии является связью с определённым пользователем (или, если быть более точным, связью с определённым браузером, который определяется при помощи идентификатора (`id`) сессии, получаемого из куки браузера).

Переменная (или поле) `session` является объектом-словарём, который служит для чтения и записи неограниченное число раз. С ним вы можете выполнять любые стандартные операции, включая очистку всех данных, проверку наличия ключа, циклы по данным и так далее. Большую часть времени вы будете тратить на обычные "словарные" операции - получения и установки значений.

Ниже представлены фрагменты кода, которые показывают вам как получать, задавать и удалять некоторые данные при помощи ключа "`my_car`", связанного с текущей сессией (браузером).

> **Примечание:** Одной из самых грандиозных вещей в Django является то, что вам не надо думать о механизме, который связывает сессию с текущим запросом в отображении. Во фрагменте ниже, всё что вам надо знать, это то, что `my_car` связана с тем браузером, который отправил текущий запрос.

```py
# Получение значения сессии при помощи ключа(то есть, 'my_car').
# Если такого ключа нет, то возникнет ошибка KeyError
my_car = request.session['my_car']

# Получение значения сессии. Если значения не существует,
# то вернётся значение по умолчанию ('mini')
my_car = request.session.get('my_car', 'mini')

# Передача значения в сессию
request.session['my_car'] = 'mini'

# Удаление значения из сессии
del request.session['my_car']
```

Данное API имеет другие методы, которые большей частью используются для управления куки, связанных с сессией. Например, существуют методы проверки того, что куки поддерживаются клиентским браузером, другие методы служат для установки и проверки предельных дат жизни куки, а также для очистки просроченных сессий из хранилища. Подробное описание API вы можете найти в разделе [Как использовать сессии](https://docs.djangoproject.com/en/1.10/topics/http/sessions/) (Django docs).

[Назад к Django](#django)

### Хранение данных сессии

По умолчанию Django сохраняет данные сессии в базу данных и отправляет соответствующие куки клиенту только тогда, когда сессия была *изменена*, или *удалена*. Если вы обновляете какие-либо данные при помощи ключа сессии, как показано в предыдущем фрагменте, тогда вам не надо беспокоиться о процессе сохранения! Например:
```py
# Данное присваивание распознается как обновление сессии
# и данные будут сохранены
request.session['my_car'] = 'mini'
```

Если вы обновите информацию внутри данных сессии, тогда Django не распознает эти изменения и не выполнит сохранение данных (например, если вы изменили "`wheels`" внутри переменной "`my_car`", как показано ниже). В таких случаях вам надо явно указывать, что сессия была изменена.
```py
# Объект сессии модифицируется неявно.
# Изменения НЕ БУДУТ сохранены!
request.session['my_car']['wheels'] = 'alloy'

# Явное указание, что данные изменены.
# Сессия будет сохранена, куки обновлены (если необходимо).
request.session.modified = True
```

> **Примечание:** Вы можете изменить поведение сессий таким образом, чтобы они записывали любое своё изменение в базу данных и отправляли куки, при каждом запросе, путём установки `SESSION_SAVE_EVERY_REQUEST = True`, в файле настроек проекта (**locallibrary/locallibrary/settings.py**).

[Назад к Django](#django)

### Простой пример — получение числа визитов

В качестве примера из реального мира мы обновим нашу библиотеку так, чтобы сообщать пользователю количество совершенных им визитов главной страницы сайта [LocalLibrary](#django-сайт-местной-библиотеки).

Откройте **/locallibrary/catalog/views.py** и добавьте изменения, выделенных жирным, ниже.
```py
def index(request):
    ...

    num_authors=Author.objects.count()  # The 'all()' is implied by default.

    # Number of visits to this view, as counted in the session variable.
    num_visits=request.session.get('num_visits', 0)
    request.session['num_visits'] = num_visits+1

    # Render the HTML template index.html with the data in the context variable.
    return render(
        request,
        'index.html',
        context={'num_books':num_books,'num_instances':num_instances,'num_instances_available':num_instances_available,'num_authors':num_authors,
            'num_visits':num_visits}, # num_visits appended
    )
```

В первую очередь мы получаем значение '`num_visits`' из сессии, возвращая 0, если оно не было установлено ранее. Каждый раз при получении запроса, мы увеличиваем данное значение на единицу и сохраняем его обратно в сессии (до следующего посещения данной страницы пользователем). Затем переменная `num_visits` передаётся в шаблон через переменную контекста `context`.

> **Примечание:** Можно проверить наличие поддержки куки в браузере (для примера, смотрите [Как использовать сессии](https://docs.djangoproject.com/en/1.10/topics/http/sessions/)), или разработать наш UI таким образом, чтобы это не имело значения.

Для показа значения переменной, из следующего фрагмента добавьте нижнюю строчку кода в ваш шаблон главной страницы сайта (**/locallibrary/catalog/templates/index.html**), в его нижний раздел "Dynamic content":
```django
<h2>Dynamic content</h2>

<p>The library has the following record counts:</p>
<ul>
  <li><strong>Books:</strong> {{ num_books }}</li>
  <li><strong>Copies:</strong> {{ num_instances }}</li>
  <li><strong>Copies available:</strong> {{ num_instances_available }}</li>
  <li><strong>Authors:</strong> {{ num_authors }}</li>
</ul>

<p>
  You have visited this page {{ num_visits }}{% if num_visits == 1 %} time{%
  else %} times{% endif %}.
</p>
```

Сохраните ваши изменения и перезапустите сервер. Данное значение должно изменяться всякий раз, когда вы обновляете страницу.

- **Итоги**

Вы узнали как применять сессии для улучшения взаимодействие с анонимными пользователями.

В наших следующих статьях мы рассмотрим фреймворк аутентификации и авторизации (разрешение доступа, permission), и покажем вам как поддерживать пользовательские аккаунты.

- **Смотрите также**
- [Как использовать сессии](https://docs.djangoproject.com/en/1.10/topics/http/sessions/) (Django docs)

[Назад к Django](#django)

## Django 8: аутентификация и авторизация пользователя

В данном руководстве мы продемонстрируем вам систему входа пользователя на ваш сайт используя его собственный аккаунт. Кроме того, мы покажем как реализовать контроль того, что может видеть и делать пользователь, в зависимости от того, залогинен он, или нет, а также имеет ли он соответствующий уровень прав доступа (*permissions*). Для того чтобы продемонстрировать все это, мы расширим [LocalLibrary](#django-сайт-местной-библиотеки), добавив страницы для входа/выхода, а также страницы просмотра/редактирования книг, специфические для пользователя и персонала.

| Требования: | Завершить изучение предыдущих тем руководства, включая [Руководство Django Часть 7: Работа с сессиями](#django-7-сессии).
|----|----
| Цель: | Понимать как настроить и использовать механизм аутентификации пользователя и разграничений прав доступа.

### Обзор

Django предоставляет систему аутентификации и авторизации ("permission") пользователя, реализованную на основе фреймворка работы с сессиями, который мы рассматривали в [предыдущей части](#django-7-сессии). Система аутентификации и авторизации позволяет вам проверять учётные данные пользователей и определять какие действия какой пользователь может выполнять. Данный фреймворк включает в себя встроенные модели для `Пользователей` и `Групп` (основной способ применения прав доступа для более чем одного пользователя), непосредственно саму систему прав доступа (permissions)/флаги, которые определяют может ли пользователь выполнить задачу, с какой формой и отображением для авторизованных пользователей, а так же получить доступ к контенту с ограниченным доступом.

> **Примечание:** В соответствии с идеологией Django система аутентификации является очень общей и, таким образом, не предоставляет некоторые возможности, которые присутствуют в других системах веб-аутентификации. Решениями некоторых общих задач занимаются пакеты сторонних разработчиков, например, защита от подбора пароля (через стороннюю библиотеку **OAuth**).

В данном разделе руководства мы покажем вам реализацию аутентификации пользователя на сайте [LocalLibrary](#django-сайт-местной-библиотеки), создание страниц входа/выхода, добавления разграничения доступа (permissions) к вашим моделям, а также продемонстрируем контроль за доступом к некоторым страницам. Мы будем использовать аутентификацию/авторизацию для показа пользователям и сотрудникам библиотеки, списков книг, которые были взяты на прокат.

Система аутентификации является очень гибкой и позволяет вам формировать свои собственные URL-адреса, формы, отображения, а также шаблоны страниц, если вы пожелаете, с нуля, через простой вызов функций соответствующего API для авторизации пользователя. Тем не менее, в данной статье мы будем использовать "встроенные" в Django методы отображений и форм аутентификации, а также методы построения страниц входа и выхода. Нам все ещё необходимо создавать шаблоны страниц, но это будет достаточно несложно.

Мы покажем вам как реализовать разграничение доступа (permissions), а также выполнять соответствующую проверку статусов авторизации и прав доступа, в отображениях, и в шаблонах страниц.

[Назад к Django](#django)

### Подключение аутентификации

Аутентификация была подключена автоматически когда мы создали [скелет сайта](#django-2-создание-скелета) (в части 2), таким образом на данный момент вам ничего не надо делать.

> **Примечание:** Необходимые настройки были выполнены для нас, когда мы создали приложение при помощи команды `django-admin startproject`. Таблицы базы данных для пользователей и модели авторизации были созданы, когда в первый раз выполнили команду python `manage.py migrate`.

Соответствующие настройки сделаны в параметрах `INSTALLED_APPS` и `MIDDLEWARE` файла проекта (**locallibrary/locallibrary/settings.py**), как показано ниже:
```py
INSTALLED_APPS = [
    ...
    'django.contrib.auth',  # Фреймворк аутентификации и моделей по умолчанию.
    'django.contrib.contenttypes',  # Django контент-типовая система (даёт разрешения, связанные с моделями).
    ....

MIDDLEWARE = [
    ...
    'django.contrib.sessions.middleware.SessionMiddleware',  # Управление сессиями между запросами
    ...
    'django.contrib.auth.middleware.AuthenticationMiddleware',  # Связывает пользователей, использующих сессии, запросами.
    ....
```

### Создание пользователей и групп

Вы уже создали своего первого пользователя когда мы рассматривали [Административную панель сайта Django](#django-4-административная-панель-django) в части 4 (это был суперпользователь, созданный при помощи команды `python manage.py createsuperuser`). Наш суперпользователь уже авторизован и имеет все необходимые уровни доступа к данным и функциям, таким образом нам необходимо создать тестового пользователя для отработки соответствующей работы сайта. В качестве наиболее быстрого способа, мы будем использовать административную панель сайта для создания соответствующих групп и аккаунтов locallibrary.

> **Примечание:** Вы можете создавать пользователей программно, как показано ниже. Например, вам мог бы подойти данный способ в том случае, если вы разрабатываете интерфейс, который позволяет пользователям создавать их собственные аккаунты (вы не должны предоставлять доступ пользователям к административной панели вашего сайта).
>
> ```py
> from django.contrib.auth.models import User
> 
> # Создайте пользователя и сохраните его в базе данных
> user = User.objects.create_user('myusername', 'myemail@crazymail.com', 'mypassword')
> 
> # Обновите поля и сохраните их снова
> user.first_name = 'John'
> user.last_name = 'Citizen'
> user.save()
> ```

Ниже мы создадим группу, а затем пользователя. Несмотря на то, что у нас пока нет никаких разрешений для добавления к нашей библиотеке каких-либо членов, если мы захотим это сделать в будущем, то будет намного проще добавлять их к уже созданной группе, с заданной аутентификацией.

Запустите сервер разработки и перейдите к административной панели вашего сайта (`http://127.0.0.1:8000/admin/`). Залогиньтесь на сайте при помощи параметров (имя пользователя и пароля) аккаунта суперпользователя. Самая "верхняя" страница панели Администратора показывает все наши модели. Для того, чтобы увидеть записи в разделе **Authentication and Authorisation** вы можете нажать на ссылку **Users**, или **Groups**.

![adding users](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/admin_authentication_add.png)

В первую очередь, в качестве нового члена нашего сайта, давайте создадим новую группу.

1. Нажмите на кнопку **Add (Добавить)** (рядом с Group) и создайте новую группу; для данной группы введите **Name (Имя)** "Library Members".

![add group](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/admin_authentication_add_group.png)

2. Для данной группы не нужны какие-либо разрешения, поэтому мы просто нажимаем кнопку **SAVE (Сохранить)** (вы перейдёте к списку групп).

Теперь давайте создадим пользователя:

1. Перейдите обратно на домашнюю страницу административной панели
2. Для перехода к диалогу добавления пользователя нажмите на кнопку **Add**, соответствующую строке Users (Пользователи).

![add uoser](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/admin_authentication_add_user_prt1.png)

3. Введите соответствующие **Username (имя пользователя)** и **Password/Password confirmation (пароль/подтверждение пароля)** для вашего тестового пользователя

4. Нажмите **SAVE** для завершения процесса создания пользователя.

Административная часть сайта создаст нового пользователя и немедленно перенаправит вас на страницу **Change user (Изменение параметров пользователя)** где вы можете, соответственно, изменить ваш **username**, а кроме того добавить информацию для дополнительных полей модели User. Эти поля включают в себя имя пользователя, фамилию, адрес электронной почты, статус пользователя, а также соответствующие параметры доступа (может быть установлен только флаг **Active**). Ниже вы можете определить группу для пользователя и необходимые параметры доступа, а кроме того, вы можете увидеть важные даты, относящиеся к пользователю (дату подключения к сайту и дату последнего входа).

![change user](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/admin_authentication_add_user_prt2.png)

5. В разделе *Groups*, из списка *Доступные группы* выберите группу **Library Member**, а затем переместите её в блок "Выбранные группы" (нажмите **стрелку-"направо"**, находящуюся между блоками).

![groups](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/admin_authentication_user_add_group.png)

6. Больше нам не нужно здесь нечего делать, просто нажмите **"Save"(Сохранить)**, и вы вернётесь к списку созданных пользователей.

Вот и все! Теперь у вас есть учётная запись «обычного члена библиотеки», которую вы сможете использовать для тестирования (как только добавим страницы, чтобы пользователи могли войти в систему).

> **Примечание:** Попробуйте создать другого пользователя, например "Библиотекаря". Так же создайте группу "Библиотекарей" и добавьте туда своего только что созданного библиотекаря

[Назад к Django](#django)

### Настройка представлений проверки

Django предоставляет почти все, что нужно для создания страниц аутентификации входа, выхода из системы и управления паролями из коробки. Это включает в себя url-адреса, представления (views) и формы, но не включает шаблоны — мы должны создать свой собственный шаблон!

В этом разделе мы покажем, как интегрировать систему по умолчанию в [сайт LocalLibrary](#django-сайт-местной-библиотеки) и создать шаблоны. Мы поместим их в основные URL проекта.

> **Примечание:** Вы не должны использовать этот код, но вполне вероятно, что вы хотите, потому что это делает вещи намного проще. Вам почти наверняка потребуется изменить код обработки формы, если вы измените свою модель пользователя (сложная тема!) но даже в этом случае вы всё равно сможете использовать функции просмотра запасов.

> **Примечание:** В этом случае мы могли бы разумно поместить страницы аутентификации, включая URL-адреса и шаблоны, в наше приложение каталога. Однако, если бы у нас было несколько приложений, было бы лучше отделить это общее поведение входа в систему и иметь его доступным на всем сайте, так что это то, что мы показали здесь!

### Проектирование URLs

Добавьте следующее в нижней части файла проекта **urls.py** (**locallibrary/locallibrary/urls.py**):
```py
#Add Django site authentication urls (for login, logout, password management)
urlpatterns += [
    path('accounts/', include('django.contrib.auth.urls')),
]
```

Перейдите по `http://127.0.0.1:8000/accounts/` URL (обратите внимание на косую черту!), Django покажет ошибку, что он не смог найти этот URL, и перечислить все URL, которые он пытался открыть. Из этого вы можете увидеть URL-адреса, которые будут работать, например:

> **Примечание:** Использование вышеуказанного метода добавляет следующие URL-адреса с именами в квадратных скобках, которые могут использоваться для изменения сопоставлений URL-адресов. Вам не нужно реализовывать что-либо ещё - приведённое выше сопоставление URL-адресов автоматически отображает указанные ниже URL-адреса.
> ```py
> accounts/ login/ [name='login']
> accounts/ logout/ [name='logout']
> accounts/ password_change/ [name='password_change']
> accounts/ password_change/done/ [name='password_change_done']
> accounts/ password_reset/ [name='password_reset']
> accounts/ password_reset/done/ [name='password_reset_done']
> accounts/ reset/<uidb64>/<token>/ [name='password_reset_confirm']
> accounts/ reset/done/ [name='password_reset_complete']
> ```

Теперь попробуйте перейти к URL-адресу входа (`http://127.0.0.1:8000/accounts/login/`). Это приведёт к сбою снова, но с ошибкой, сообщающей вам, что нам не хватает требуемого шаблона (**registration/login.html**) в пути поиска шаблона. Вы увидите следующие строки, перечисленные в жёлтом разделе вверху:
```py
Exception Type:    TemplateDoesNotExist
Exception Value:    registration/login.html
```

Следующий шаг - создать каталог регистрации в пути поиска, а затем добавить файл **login.html**.

[Назад к Django](#django)

### Каталог шаблонов

URL-адреса (и неявные представления), которые мы только что добавили, ожидают найти связанные с ними шаблоны в каталоге **/регистрации/** где-то в пути поиска шаблонов.

Для этого сайта мы разместим наши HTML-страницы в каталоге `templates/registration/`. Этот каталог должен находиться в корневом каталоге проекта, то есть в том же каталоге, что и в каталоге и папках locallibrary). Создайте эти папки сейчас.

> **Примечание:** Ваша структура папок теперь должна выглядеть так: `locallibrary (django project folder) |_catalog |_locallibrary |_templates (new) |_registration`

Чтобы сделать эти директории видимыми для загрузчика шаблонов (т. е. помещать этот каталог в путь поиска шаблона) откройте настройки проекта (**/locallibrary/locallibrary/settings.py**), и обновите в секции `TEMPLATES` строку `'DIRS'` как показано.
```py
TEMPLATES = [
    {
        ...
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        ...
```

[Назад к Django](#django)

### Шаблон аутентификации

> **Предупреждение: Важно:** Шаблоны аутентификации, представленные в этой статье, являются очень простой / слегка изменённой версией шаблонов логина демонстрации Django. Возможно, вам придётся настроить их для собственного использования!

Создайте новый HTML файл, названный **/locallibrary/templates/registration/login.html**, дайте ему следующее содержание:
```django
{% extends "base_generic.html" %}

{% block content %}

{% if form.errors %}
  <p>Your username and password didn't match. Please try again.</p>
{% endif %}

{% if next %}
  {% if user.is_authenticated %}
    <p>Your account doesn't have access to this page. To proceed,
    please login with an account that has access.</p>
  {% else %}
    <p>Please login to see this page.</p>
  {% endif %}
{% endif %}

<form method="post" action="{% url 'login' %}">
{% csrf_token %}
<table>

<tr>
  <td>{{ form.username.label_tag }}</td>
  <td>{{ form.username }}</td>
</tr>

<tr>
  <td>{{ form.password.label_tag }}</td>
  <td>{{ form.password }}</td>
</tr>
</table>

<input type="submit" value="login" />
<input type="hidden" name="next" value="{{ next }}" />
</form>

{# Assumes you setup the password_reset view in your URLconf #}
<p><a href="{% url 'password_reset' %}">Lost password?</a></p>

{% endblock %}
```

Этот шаблон имеет сходство с тем, что мы видели раньше - он расширяет наш базовый шаблон и переопределяет блок контента. Остальная часть кода - это довольно стандартный код обработки формы, о котором мы поговорим в следующем учебном пособии. Все, что вам нужно знать, это показ формы, в которой вы можете ввести своё имя пользователя и пароль, а если вы введёте недопустимые значения, вам будет предложено ввести правильные значения, когда страница обновится.

Перейдите на страницу входа (`http://127.0.0.1:8000/accounts/login/`) когда вы сохраните свой шаблон, и вы должны увидеть что-то наподобие этого:

![login](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/library_login.png)

Если ваша попытка войти в систему будет успешной, вы будете перенаправлены на другую страницу (по умолчанию это будет `http://127.0.0.1:8000/accounts/profile/`). Проблема здесь в том, что по умолчанию Django ожидает, что после входа в систему вы захотите перейти на страницу профиля, что может быть или не быть. Поскольку вы ещё не определили эту страницу, вы получите ещё одну ошибку!

Откройте настройки проекта (**/locallibrary/locallibrary/settings.py**) и добавьте текст ниже. Теперь, когда вы входите в систему, вы по умолчанию должны перенаправляться на домашнюю страницу сайта.
```py
# Redirect to home URL after login (Default redirects to /accounts/profile/)
LOGIN_REDIRECT_URL = '/'
```

[Назад к Django](#django)

### Шаблон выхода

Если вы перейдёте по URL-адресу выхода (`http://127.0.0.1:8000/accounts/logout/`), то увидите странное поведение - ваш пользователь наверняка выйдет из системы, но вы попадёте на страницу выхода администратора. Это не то, что вам нужно, хотя бы потому, что ссылка для входа на этой странице приведёт вас к экрану входа в систему администратора. (и это доступно только для пользователей, у которых есть разрешение `is_staff`).

Создайте и откройте **/locallibrary/templates/registration/logged_out.html**. Скопируйте текст ниже:
```django
{% extends "base_generic.html" %}

{% block content %}
  <p>Logged out!</p>

  <a href="{% url 'login'%}">Click here to login again.</a>
{% endblock %}
```

Этот шаблон очень прост. Он просто отображает сообщение, информирующее вас о том, что вы вышли из системы, и предоставляет ссылку, которую вы можете нажать, чтобы вернуться на экран входа в систему. Если вы снова перейдёте на страницу выхода из системы, вы увидите эту страницу:

![logout](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/library_logout.png)

### Шаблон сброса пароля

Система сброса пароля по умолчанию использует электронную почту, чтобы отправить пользователю ссылку на сброс. Вам необходимо создать формы, чтобы получить адрес электронной почты пользователя, отправить электронное письмо, разрешить им вводить новый пароль и отметить, когда весь процесс будет завершён.

В качестве отправной точки можно использовать следующие шаблоны.

### Форма сброса пароля

Это форма, используемая для получения адреса электронной почты пользователя (для отправки пароля для сброса пароля). Создайте **/locallibrary/templates/registration/password_reset_form.html** со следующим содержанием:
```django
{% extends "base_generic.html" %}

{% block content %}
  <form action="" method="post">{% csrf_token %}
      {% if form.email.errors %} {{ form.email.errors }} {% endif %}
          <p>{{ form.email }}</p>
      <input type="submit" class="btn btn-default btn-lg" value="Reset password" />
  </form>
{% endblock %}
```

[Назад к Django](#django)

### Сброс пароля

Эта форма отображается после того, как ваш адрес электронной почты будет собран. Создайте **/locallibrary/templates/registration/password_reset_done.html** со следующим содержанием:
```django
{% extends "base_generic.html" %}

{% block content %}
  <p>
    We've emailed you instructions for setting your password. If they haven't
    arrived in a few minutes, check your spam folder.
  </p>
{% endblock %}
```

### Сброс пароля по email

Этот шаблон предоставляет текст электронной почты HTML, содержащий ссылку на сброс, которую мы отправим пользователям. Создайте **/locallibrary/templates/registration/password_reset_email.html** со следующим содержанием:
```django
Someone asked for password reset for email {{ email }}. Follow the link below:
{{ protocol}}://{{ domain }}{% url 'password_reset_confirm' uidb64=uid token=token %}
```

### Подтверждение на сброс пароля

На этой странице вы вводите новый пароль после нажатия ссылки в электронном письме с возвратом пароля. Создайте **/locallibrary/templates/registration/password_reset_confirm.html** со следующим содержанием:
```django
{% extends "base_generic.html" %}

{% block content %}
  {% if validlink %}
    <p>Please enter (and confirm) your new password.</p>
    <form action="" method="post">
      {% csrf_token %}
      <table>
        <tr>
          <td>
            {{ form.new_password1.errors }}
            <label for="id_new_password1">New password:</label>
          </td>
          <td>{{ form.new_password1 }}</td>
        </tr>
        <tr>
          <td>
            {{ form.new_password2.errors }}
            <label for="id_new_password2">Confirm password:</label>
          </td>
          <td>{{ form.new_password2 }}</td>
        </tr>
        <tr>
          <td></td>
          <td><input type="submit" value="Change my password" /></td>
        </tr>
      </table>
    </form>
  {% else %}
    <h1>Password reset failed</h1>
    <p>
      The password reset link was invalid, possibly because it has already been
      used. Please request a new password reset.
    </p>
  {% endif %}
{% endblock %}
```

[Назад к Django](#django)

### Сброс пароля завершён

Это последний шаблон сброса пароля, который отображается, чтобы уведомить вас о завершении сброса пароля. Создайте **/locallibrary/templates/registration/password_reset_complete.html** со следующим содержанием::
```django
{% extends "base_generic.html" %}

{% block content %}
  <h1>The password has been changed!</h1>
  <p><a href="{% url 'login' %}">log in again?</a></p>
{% endblock %}
```

### Тестирование новых страниц аутентификации

Теперь, когда вы добавили конфигурацию URL и создали все эти шаблоны, теперь страницы аутентификации должны работать! Вы можете протестировать новые страницы аутентификации, попытавшись войти в систему, а затем выйдите из учётной записи суперпользователя, используя эти URL-адреса:

- `http://127.0.0.1:8000/accounts/login/`
- `http://127.0.0.1:8000/accounts/logout/`

Вы сможете проверить функцию сброса пароля по ссылке на странице входа. **Имейте в виду, что Django отправляет только сбросные электронные письма на адреса пользователей, которые уже хранятся в его базе данных!**

> > **Примечание:** Система сброса пароля требует, чтобы ваш сайт поддерживал электронную почту, что выходит за рамки этой статьи, поэтому эта часть **ещё не будет работать**. Чтобы разрешить тестирование, поместите следующую строку в конец файла settings.py. Это регистрирует любые письма, отправленные на консоль (чтобы вы могли скопировать ссылку на сброс пароля с консоли).
> ```py
> EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
> ```
> 
> Для получения дополнительной информации см. [Отправка email](https://docs.djangoproject.com/en/2.0/topics/email/) (Django docs).

[Назад к Django](#django)

### Тестирование проверки подлинности пользователей

В этом разделе мы рассмотрим, что мы можем сделать, чтобы выборочно контролировать контент, который видят пользователи, на основе того, вошли ли они в систему или нет.

- **Тестирование в шаблонах**

Вы можете получить информацию о текущем зарегистрированном пользователе в шаблонах с переменной шаблона `{{user}}` (это добавляется в контекст шаблона по умолчанию при настройке проекта, как и в нашем скелете).

Обычно вы сначала проверяете переменную шаблона `{{user.is_authenticated}}`, чтобы определить, имеет ли пользователь право видеть конкретный контент. Чтобы продемонстрировать это, мы обновим нашу боковую панель, чтобы отобразить ссылку «Вход», если пользователь вышел из системы, и ссылку «Выход», если он вошёл в систему.

Откройте базовый шаблон (**/locallibrary/catalog/templates/base_generic.html**) и скопируйте следующий текст в *sidebar* блок непосредственно перед тегом шаблона *endblock*.
```py
  <ul class="sidebar-nav">

    ...

   {% if user.is_authenticated %}
     <li>User: {{ user.get_username }}</li>
     <li><a href="{% url 'logout'%}?next={{request.path}}">Logout</a></li>
   {% else %}
     <li><a href="{% url 'login'%}?next={{request.path}}">Login</a></li>
   {% endif %}
  </ul>
```

Как вы можете видеть, мы используем теги шаблона **if-else-endif** для условного отображения текста на основе того, является ли `{{user.is_authenticated}}` истинным. Если пользователь аутентифицирован, мы знаем, что у нас есть действительный пользователь, поэтому мы вызываем `{{user.get_username}}`, чтобы отобразить их имя.

Мы создаём URL-адрес для входа и выхода из системы, используя тег шаблона URL-адреса и имена соответствующих конфигураций URLs. Также обратите внимание на то, как мы добавили `?next={{request.path}}` в конец URLs. Это означает, что следующий URL-адрес содержит адрес (URL) текущей страницы, в конце связанного URL-адреса. После того, как пользователь успешно выполнил вход в систему, представления будут использовать значение "`next`" чтобы перенаправить пользователя обратно на страницу, где они сначала нажали ссылку входа / выхода из системы.

> **Примечание:** Попробуйте! Если вы находитесь на главной странице и вы нажимаете «Вход / Выход» на боковой панели, то после завершения операции вы должны вернуться на ту же страницу.

- **Тестирование в представлениях**

Если вы используете функциональные представления, самым простым способом ограничить доступ к вашим функциям является применение `login_required` декоратор к вашей функции просмотра, как показано ниже. Если пользователь вошёл в систему, ваш код просмотра будет выполняться как обычно. Если пользователь не вошёл в систему, это перенаправит URL-адрес входа, определённый в настройках проекта. (`settings.LOGIN_URL`), передав текущий абсолютный путь в качестве `next` параметра URL. Если пользователю удастся войти в систему, они будут возвращены на эту страницу, но на этот раз аутентифицированы.
```py
from django.contrib.auth.decorators import login_required

@login_required
def my_view(request):
    ...
```

> **Примечание:** Вы можете сделать то же самое вручную, путём тестирования `request.user.is_authenticated`, но декоратор намного удобнее!

Аналогичным образом, самый простой способ ограничить доступ к зарегистрированным пользователям в ваших представлениях на основе классов - это производные от `LoginRequiredMixin`. Вы должны объявить этот mixin сначала в списке суперкласса, перед классом основного представления.
```py
from django.contrib.auth.mixins import LoginRequiredMixin

class MyView(LoginRequiredMixin, View):
    ...
```

Это имеет такое же поведение при переадресации, что и `login_required` декоратор. Вы также можете указать альтернативное местоположение для перенаправления пользователя, если он не аутентифицирован (`login_url`), и имя параметра URL вместо "`next`" , чтобы вставить текущий абсолютный путь (`redirect_field_name`).
```py
class MyView(LoginRequiredMixin, View):
    login_url = '/login/'
    redirect_field_name = 'redirect_to'
```

Для получения дополнительной информации ознакомьтесь с [Django docs here](https://docs.djangoproject.com/en/1.10/topics/auth/default/#limiting-access-to-logged-in-users).

[Назад к Django](#django)

### Пример - перечисление книг текущего пользователя

Теперь, когда мы знаем, как ограничить страницу определённому пользователю, создайте представление о книгах, которые заимствовал текущий пользователь.

К сожалению, у нас пока нет возможности пользователям использовать книги! Поэтому, прежде чем мы сможем создать список книг, мы сначала расширим `BookInstance` модель для поддержки концепции заимствования и использования приложения Django Admin для заимствования ряда книг нашему тестовому пользователю.

### Модели

Прежде всего, мы должны предоставить пользователям возможность кредита на `BookInstance` (у нас уже есть `status` и `due_back` дата, но у нас пока нет связи между этой моделью и пользователем). Мы создадим его с помощью поля `ForeignKey` (один ко многим). Нам также нужен простой механизм для проверки того, просрочена ли заёмная книга.

Откройте **catalog/models.py**, и импортируйте модель `User` из `django.contrib.auth.models` (добавьте это чуть ниже предыдущей строки импорта в верхней части файла, так `User` доступен для последующего кода, что позволяет использовать его):
```py
from django.contrib.auth.models import User
```

Затем добавьте поле `borrower` в модель `BookInstance`:
```py
borrower = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
```

Пока мы здесь, давайте добавим свойство, которое мы можем вызвать из наших шаблонов, чтобы указать, просрочен ли конкретный экземпляр книги. Хотя мы могли бы рассчитать это в самом шаблоне, использование свойства, как показано ниже, будет намного более эффективным. Добавьте это где-нибудь в верхней части файла:
```PY
from datetime import date
```

Теперь добавьте следующее определение свойства внутри класса BookInstance:
```py
@property
def is_overdue(self):
    if self.due_back and date.today() > self.due_back:
        return True
    return False
```

> **Примечание:** Сначала мы проверим, является ли `due_back` пустым, прежде чем проводить сравнение. Пустое поле `due_back` заставило Django выкидывать ошибку, а не показывать страницу: пустые значения не сопоставимы. Это не то, что мы хотели бы, чтобы наши пользователи испытывали!

Теперь, когда мы обновили наши модели, нам нужно будет внести новые изменения в проект, а затем применить эти миграции:
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

[Назад к Django](#django)

### Admin

Теперь откройте каталог **catalog/admin.py**, и добавьте поле `borrower` в класс `BookInstanceAdmin` , как в `list_display` , так и в полях `fieldsets` , как показано ниже. Это сделает поле видимым в разделе Admin, так что мы можем при необходимости назначить `User` в `BookInstance`.
```py
@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    list_display = ('book', 'status', 'borrower', 'due_back', 'id')
    list_filter = ('status', 'due_back')

    fieldsets = (
        (None, {
            'fields': ('book','imprint', 'id')
        }),
        ('Availability', {
            'fields': ('status', 'due_back','borrower')
        }),
    )
```

### Займите несколько книг

Теперь, когда возможно кредитовать книги конкретному пользователю, зайдите и заработайте на нескольких записей в `BookInstance`. Установите `borrowed` поле вашему тестовому пользователю, сделайте `status` «В займе» и установите сроки оплаты как в будущем, так и в прошлом.

> **Примечание:** Мы не будем описывать процесс, так как вы уже знаете, как использовать Admin сайт!

### Займ в представлении

Теперь мы добавим представление для получения списка всех книг, которые были предоставлены текущему пользователю. Мы будем использовать один и тот же общий класс, с которым мы знакомы, но на этот раз мы также будем импортировать и выводить из `LoginRequiredMixin`, так что только вошедший пользователь сможет вызвать это представление. Мы также решили объявить `template_name`, вместо того, чтобы использовать значение по умолчанию, потому что у нас может быть несколько разных списков записей BookInstance, с разными представлениями и шаблонами.

Добавьте следующее в **catalog/views.py**:
```py
from django.contrib.auth.mixins import LoginRequiredMixin

class LoanedBooksByUserListView(LoginRequiredMixin,generic.ListView):
    """
    Generic class-based view listing books on loan to current user.
    """
    model = BookInstance
    template_name ='catalog/bookinstance_list_borrowed_user.html'
    paginate_by = 10

    def get_queryset(self):
        return BookInstance.objects.filter(borrower=self.request.user).filter(status__exact='o').order_by('due_back')
```

Чтобы ограничить наш запрос только объектами BookInstance для текущего пользователя, мы повторно реализуем `get_queryset()`, как показано выше. Обратите внимание, что "o" это сохранённый код для "on loan" и мы сортируем по дате `due_back`, чтобы сначала отображались самые старые элементы.

[Назад к Django](#django)

### URL-адрес для заёмных книг

Теперь откройте **/catalog/urls.py** и добавьте `url()` , указывая на приведённое выше представление (вы можете просто скопировать текст ниже в конец файла).
```py
urlpatterns += [
    url(r'^mybooks/$', views.LoanedBooksByUserListView.as_view(), name='my-borrowed'),
]
```

### Шаблон для заёмных книг

Теперь все, что нам нужно сделать для этой страницы, - это добавить шаблон. Сначала создайте файл шаблона `/catalog/templates/catalog/bookinstance_list_borrowed_user.html` и осчастливте его следующим содержанием:
```py
{% extends "base_generic.html" %}

{% block content %}
    <h1>Borrowed books</h1>

    {% if bookinstance_list %}
    <ul>

      {% for bookinst in bookinstance_list %}
      <li class="{% if bookinst.is_overdue %}text-danger{% endif %}">
        <a href="{% url 'book-detail' bookinst.book.pk %}">{{bookinst.book.title}}</a> ({{ bookinst.due_back }})
      </li>
      {% endfor %}
    </ul>

    {% else %}
      <p>There are no books borrowed.</p>
    {% endif %}
{% endblock %}
```

Этот шаблон очень похож на тот, который мы создали ранее для объектов `Book` и `Author`. Единственное, что «новое» здесь, это то, что мы проверяем метод, который мы добавили в модель (`bookinst.is_overdue`) с целью использовать его для изменения цвета просроченных предметов.

Когда сервер разработки запущен, вы должны теперь иметь возможность просматривать список для зарегистрированного пользователя в своём браузере по адресу `http://127.0.0.1:8000/catalog/mybooks/`. Попробуйте это, когда ваш пользователь войдёт в систему и выйдет из системы (во втором случае вы должны быть перенаправлены на страницу входа в систему).

[Назад к Django](#django)

### Добавить список на боковую панель

Последний шаг - добавить ссылку на эту новую страницу в sidebar. Мы поместим это в тот же раздел, где мы покажем другую информацию для зарегистрированного пользователя.

Откройте базовый шаблон (**/locallibrary/catalog/templates/base_generic.html**) и добавьте выделенную строку из sidebar, как показано на рисунке.
```py
 <ul class="sidebar-nav">
   {% if user.is_authenticated %}
   <li>User: {{ user.get_username }}</li>
   <li><a href="{% url 'my-borrowed' %}">My Borrowed</a></li>
   <li><a href="{% url 'logout'%}?next={{request.path}}">Logout</a></li>
   {% else %}
   <li><a href="{% url 'login'%}?next={{request.path}}">Login</a></li>
   {% endif %}
 </ul>
```

### На что это похоже?

Когда любой пользователь войдёт в систему, он будет видеть ссылку «Мной позаимствовано (My Borrowed)» в боковой колонке, и список книг, показанных ниже (первая книга не имеет установленной даты, что является ошибкой, которую мы надеемся исправить в более позднем уроке!).

![borrowed books](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/library_borrowed_by_user.png)

### Права доступа

Права доступа связаны с моделями и определяют операции, которые могут выполняться на экземпляре модели самим пользователем, у которого есть разрешение. По умолчанию Django автоматически даёт *добавить*, *изменить*, и *удалить* разрешения у всех моделей, которые позволяют пользователям с правом доступа выполнять связанные действия через администратора сайта. Вы можете определить свои собственные разрешения для моделей и предоставить их конкретным пользователям. Вы также можете изменить разрешения, связанные с разными экземплярами одной и той же модели. Тестирование разрешений в представлениях и шаблонах очень похоже на тестирование по статусу аутентификации (фактически, тестирование прав доступа также проверяет аутентификацию).

Модели
Определение разрешений выполняется в разделе моделей "`class Meta`" , используется `permissions` поле. Вы можете указать столько разрешений, сколько необходимо в кортеже, причём каждое разрешение определяется во вложенном кортеже, содержащем имя разрешения и отображаемое значение разрешения. Например, мы можем определить разрешение, позволяющее пользователю отметить, что книга была возвращена, как показано здесь:
```py
class BookInstance(models.Model):
    ...
    class Meta:
        ...
        permissions = (("can_mark_returned", "Set book as returned"),)
```

Затем мы могли бы назначить разрешение группе «Библиотекарь» (Librarian) на сайте администратора.

Откройте **catalog/models.py**, и добавьте разрешение, как показано выше. Вам нужно будет повторно выполнить миграцию (вызвав `python3 manage.py makemigrations` и `python3 manage.py migrate`) для надлежащего обновления базы данных.

[Назад к Django](#django)

### Шаблоны

Разрешения текущего пользователя хранятся в переменной шаблона, называемой `{{ perms }}`. Вы можете проверить, имеет ли текущий пользователь определённое разрешение, используя конкретное имя переменной в соответствующем приложении «Django» - например, `{{ perms.catalog.can_mark_returned }}` будет `True` если у пользователя есть это разрешение, а `False` - в противном случае. Обычно мы проверяем разрешение с использованием шаблона `{% if %}`, как показано в:
```py
{% if perms.catalog.can_mark_returned %}
    <!-- We can mark a BookInstance as returned. -->
    <!-- Perhaps add code to link to a "book return" view here. -->
{% endif %}
```

### Представления

Разрешения можно проверить в представлении функции, используя `permission_required` декоратор или в представлении на основе классов, используя `PermissionRequiredMixin`. шаблон и поведение такие же, как для аутентификации входа в систему, хотя, конечно, вы можете разумно добавить несколько разрешений.

Функция в представлении с декоратором:
```py
from django.contrib.auth.decorators import permission_required

@permission_required('catalog.can_mark_returned')
@permission_required('catalog.can_edit')
def my_view(request):
    ...
```

Требуется разрешение mixin для представлений на основе классов.
```py
from django.contrib.auth.mixins import PermissionRequiredMixin

class MyView(PermissionRequiredMixin, View):
    permission_required = 'catalog.can_mark_returned'
    # Or multiple permissions
    permission_required = ('catalog.can_mark_returned', 'catalog.can_edit')
    # Note that 'catalog.can_edit' is just an example
    # the catalog application doesn't have such permission!
```

Пример

Мы не будем обновлять LocalLibrary здесь; возможно, в следующем уроке!

[Назад к Django](#django)

### Испытайте себя

Ранее в этой статье мы показали вам, как создать страницу для текущего пользователя, в которой перечислены книги, которые они заимствовали. Теперь задача состоит в том, чтобы создать аналогичную страницу, которая видна только для библиотекарей, которая отображает все книги, которые были заимствованы, и которая показывает имя каждого заёмщика.

Вы должны следовать той же схеме, что и для другого представления. Главное отличие состоит в том, что вам нужно ограничить представление только библиотекарями. Вы можете сделать это на основе того, является ли пользователь сотрудником (декоратор функции: `staff_member_required`, переменная шаблона: `user.is_staff`) но мы рекомендуем вам вместо этого использовать `can_mark_returned` разрешения и `PermissionRequiredMixin`, как описано в предыдущем разделе.

> **Предупреждение: Важно:** Не забудьте использовать вашего суперпользователя для тестирования на основе разрешений (проверки разрешений всегда возвращают true для суперпользователей, даже если разрешение ещё не определено!). Вместо этого создайте пользователя-библиотекаря и добавьте необходимые возможности.

Когда вы закончите, ваша страница должна выглядеть примерно, как на скриншоте ниже.

![all borrowed](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Authentication/library_borrowed_all.png)

### Подводим итоги

Отличная работа - теперь вы создали веб-сайт, на котором участники библиотеки могут входить в систему и просматривать собственный контент, и библиотекари (с правом доступа) могут просматривать все заёмные книги с их читателями. На данный момент мы все ещё просто просматриваем контент, но те же принципы и методы используются, когда вы хотите начать изменять и добавлять данные.

В следующей статье мы рассмотрим, как вы можете использовать формы Django для сбора пользовательского ввода, а затем начнём изменять некоторые из наших сохранённых данных.

- **Смотрите также**
- [User authentication in Django](https://docs.djangoproject.com/en/1.10/topics/auth/) (Django docs)
- [Using the (default) Django authentication system](https://docs.djangoproject.com/en/1.10/topics/auth/default//) (Django docs)
- [Introduction to class-based views > Decorating class-based views](https://docs.djangoproject.com/en/1.10/topics/class-based-views/intro/#decorating-class-based-views) (Django docs)

[Назад к Django](#django)

## Django 9: работа с формами

На этом уроке мы покажем вам процесс работы с HTML-формами в Django. В частности, продемонстрируем самый простой способ построения формы для создания, обновления и удаления экземпляров модели. При этом мы расширим [сайт местной библиотеки](#django-сайт-местной-библиотеки), чтобы библиотекари могли обновлять книги, создавать, обновлять и удалять авторов, используя наши собственные формы (а не возможности приложения администратора).

| Необходимые условия: | Завершите все предыдущие учебные темы, в том числе [Django руководство часть 8: Аутентификация пользователя и права доступа](#django-8-аутентификация-и-авторизация-пользователя).
|------|----
| Цель: | Научиться понимать, как создавать формы, чтобы получать информацию от пользователей и обновлять базу данных. Узнать, как обобщённые классы отображения форм могут значительно упростить процесс создания форм при работе с одной моделью.

### Обзор

[HTML форма](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Forms) - это группа из одного или нескольких полей/виджетов на веб-странице, которая используется для сбора информации от пользователей для последующей отправки на сервер. Формы являются гибким механизмом сбора пользовательских данных, поскольку имеют целый набор виджетов для ввода различных типов данных, как то: текстовые поля, флажки, переключатели, установщики дат и т. д. Формы являются относительно безопасным способом взаимодействия пользовательского клиента и сервера, поскольку они позволяют отправлять данные в POST-запросах, применяя защиту от [Межсайтовой подделки запроса](https://ru.wikipedia.org/wiki/Межсайтовая_подделка_запроса) (*Cross Site Request Forgery - CSRF*)

Пока что мы не создавали каких-либо форм в этом учебнике, но мы встречались с ними в административной панели Django — например, снимок экрана ниже показывает форму для редактирования одной из наших моделей книг ([Book](#django-3-использование-моделей)), состоящую из нескольких списков выбора и текстовых редакторов.

![book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/admin_book_add.png)

Работа с формами может быть достаточно сложной! Разработчикам надо описать форму на HTML, проверить её валидность, а также, на стороне сервера, проверять введённые пользователем данные (а возможно и на стороне клиента), далее, в случае возникновения ошибок необходимо опять показать пользователю форму и, при этом, указать на то, что пошло не так, в случае же успеха проделать с данными необходимые операции и каким-то образом проинформировать об этом пользователя. Django, при работе с формами, берёт большую часть, описанной выше работы, на себя. Он предоставляет фреймворк, который позволяет вам определять форму и её поля программно, а затем использовать эти объекты и для генерации непосредственно кода HTML-формы, и для контроля за процессом валидации и других пользовательский взаимодействий с формой.

В данной части руководства мы покажем вам несколько способов создания и работы с формами и, в частности, как применение обобщённых классов работы с формой могут значительно уменьшить необходимый объем работы. Кроме того, мы расширим возможности нашего сайта [LocalLibrary](#django-сайт-местной-библиотеки), путём добавления функциональности для библиотекарей, которая будет позволять им обновлять информацию - добавим страницы для создания, редактирования, удаления книг и авторов (воспроизведём и расширим стандартные возможности административной части сайта).

[Назад к Django](#django)

### Формы HTML

Начнём мы с краткого обзора [Форм HTML](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Forms). Рассмотрим простую форму HTML, имеющую поле для ввода имени некоторой "команды" ("team"), и, связанную с данным полем, текстовой меткой:

![html form](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/form_example_name_field.png)

Форма описывается на языке HTML как набор элементов, расположенных внутри парных тэгов `<form>...</form>`. Любая форма содержит как минимум одно поле-тэг `input` типа `type="submit"`.
```html
<form action="/team_name_url/" method="post">
  <label for="team_name">Enter name: </label>
  <input
    id="team_name"
    type="text"
    name="name_field"
    value="Default name for team." />
  <input type="submit" value="OK" />
</form>
```

Здесь у нас только одно поле для ввода имени команды, но форма может *иметь* любое количество элементов ввода и, связанных с ними, текстовых меток. Атрибут элемента `type` определяет какого типа виджет будет показан в данной строке. Атрибуты `name` и `id` используются для однозначной идентификации данного поля в JavaScript/CSS/HTML, в то время как `value` содержит значение для поля (когда оно показывается в первый раз). Текстовая метка добавляется при помощи тэга `label` (смотрите "Enter name", в предыдущем фрагменте) и имеет атрибут `for` со значением идентификатора `id`, того поля, с которым данная текстовая метка связана.

Элемент `input` с `type="submit"` будет показана как кнопка (по умолчанию), нажав на которую, пользователь отправляет введённые им данные на сервер (в данном случае только значение поля с идентификатором `team_name`). Атрибуты формы определяют каким методом будут отправлены данные на сервер (атрибут `method`) и куда (атрибут `action`):

- `action:` Это ресурс/URL-адрес куда будут отправлены данные для обработки. Если значение не установлено (то есть, значением поля является пустая строка), тогда данные будут отправлены в отображение (функцию, или класс), которое сформировало текущую страницу.
- `method:` HTTP-метод, используемый для отправки данных: **post**, или **get**.
  - Метод `POST` должен всегда использоваться если отправка данных приведёт к внесению изменений в базе данных на сервере. Применение данного метода должно повысить уровень защиты от CSRF.
  - Метод `GET` должен применяться только для форм, действия с которыми не приводят к изменению базы данных (например для поисковых запросов). Кроме того, данный метод рекомендуется применять для создания внешних ссылок на ресурсы сайта.

Ролью сервера в первую очередь является отрисовка начального состояния формы — либо содержащей пустые поля, либо с установленными начальными значениями. После того как пользователь нажмёт на кнопку, сервер получит все данные формы, а затем должен провести их валидацию. В том случае, если форма содержит неверные данные, сервер должен снова отрисовать форму, показав при этом поля с правильными данными, а также сообщения, описывающие "что именно пошло не так". В тот момент, когда сервер получит запрос с "правильными" данными он должен выполнить все необходимые действия (например, сохранение данных, возврат результата поиска, загрузка файла и тому подобное), а затем, в случае необходимости, проинформировать пользователя.

Как вы видите, создание HTML-формы, валидация и возврат данных, переотрисовка введённых значений, при необходимости, а также выполнение желаемых действий с "правильными данными", в целом, может потребовать довольно больших усилий для того, чтобы все "заработало". Django делает этот процесс намного проще, беря на себя некоторые "тяжёлые" и повторяющиеся участки кода!

[Назад к Django](#django)

### Процесс управления формой в Django

Управление формами в Django использует те же самые техники, которые мы изучали в предыдущих частях руководства (при показе информации из наших моделей): отображение получает запрос, выполняет необходимые действия, включающие в себя чтение данных из моделей, генерацию и возврат страницы HTML (из шаблона, в который передаётся *контекст*, содержащий данные, которые и будут показаны). Что делает данный процесс более сложным, так это то, что серверной части надо дополнительно обработать данные, предоставленные пользователем и, в случае возникновения ошибок, снова перерисовать страницу.

Диаграмма, представленная ниже, демонстрирует процесс работы с формой в Django, начиная с запроса страницы, содержащей форму (выделено зелёным цветом).

![form diagram](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/form_handling_-_standard.png)

В соответствии с данной диаграммой, главными моментами, которые берут на себя формы Django являются:

1. Показ формы по умолчанию при первом запросе со стороны пользователя.

- Форма может содержать пустые поля (например, если вы создаёте новую запись в базе данных), или они (поля) могут иметь начальные значения (например, если вы изменяете запись, или хотите заполнить её каким-либо начальным значением).
- Форма в данный момент является несвязанной, потому что она не ассоциируется с какими-либо введёнными пользователем данными (хотя и может иметь начальные значения).

2. Получение данных из формы (из HTML-формы) со стороны клиента и связывание их с формой (классом формы) на стороне сервера.

- Связывание данных с формой означает, что данные, введённые пользователем, а также возможные ошибки, при переотрисовке в дальнейшем, будут относиться именно к данной форме, а не к какой-либо ещё.

3. Очистка и валидация данных.

- Очистка данных - это их проверка на наличие возможных значений, или вставок в поля ввода (то есть очистка - это удаление неправильных символов, которые потенциально могут использоваться для отправки вредоносного содержимого на сервер), с последующей конвертацией очищенных данных в подходящие типы данных Python.
- Валидация проверяет, значения полей (например, правильность введённых дат, их диапазон и так далее)

4. Если какие-либо данные являются неверными, то выполнение перерисовки формы, но на этот раз, с уже введёнными пользователем данными и сообщениями об ошибках, описывающих возникшие проблемы.

5. Если все данные верны, то исполнение необходимых действий (например, сохранение данных, отправка писем, возврат результата поиска, загрузка файла и так далее)

6. Когда все действия были успешно завершены, то перенаправление пользователя на другую страницу.

Django предоставляет несколько инструментов и приёмов, которые помогают вам во время выполнения задач, описанных выше. Наиболее фундаментальным из них является класс Form, который упрощает генерацию HTML-формы и очистку/валидацию её данных. В следующем разделе мы опишем процесс работы с формами при помощи практического примера по созданию страницы, которая позволит библиотекарям обновлять информацию о книгах.

> **Примечание:** Понимание того, как используется класс `Form` поможет вам когда мы будем рассматривать классы фреймворка Django, для работы с формами более "высокого уровня".

[Назад к Django](#django)

### HTML-форма обновления книги. Класс Form и функция отображения

Данная глава будет посвящена процессу создания страницы, которая позволит библиотекарям обновлять информацию о книгах (в частности, вводить дату возврата книги). Для того, чтобы сделать это мы создадим форму, которая позволит пользователям вводить значение дат. Мы проинициализируем поле датой, равной 3 неделям, начиная с текущего дня, и, для того, чтобы библиотекарь не имел возможность ввести "неправильную" дату, мы добавим валидацию введённых значений, которая будет проверять, чтобы введённая дата не относилась к прошлому, или к слишком далёкому будущему. Когда будет получена "правильная" дата мы запишем её значение в поле `BookInstance.due_back`.

Данный пример будет использовать отображение на основе функции, а также продемонстрирует работу с классом `Form`. Следующие разделы покажут изменения, которые вам надо сделать, чтобы продемонстрировать работу форм в проекте [LocalLibrary](#django-сайт-местной-библиотеки).

### Класс Form

Класс `Form` является сердцем системы Django при работе с формами. Он определяет поля формы, их расположение, показ виджетов, текстовых меток, начальных значений, валидацию значений и сообщения об ошибках для "неправильных" полей (если таковые имеются). Данный класс, кроме того, предоставляет методы для отрисовки самого себя в шаблоне при помощи предопределённых форматов (таблицы, списки и так далее), или для получения значения любого элемента (позволяя выполнять более точную отрисовку).

### Объявление класса формы Form

Синтаксис объявления для класса формы `Form` очень похож на объявление класса модели `Model`, он даже использует те же типы полей (и некоторые похожие параметры). Это существенный момент, поскольку в обоих случаях нам надо убедиться, что каждое поле управляет правильным типом данных, соответствует нужному диапазону (или другому критерию) и имеет необходимое описание для показа/документации.

Для того, чтобы создать класс с возможностями базового класса `Form` мы должны импортировать библиотеку `forms`, наследовать наш класс от класса `Form`, а затем объявить поля формы. Таким образом, самый простой класс формы в нашем случае будет иметь вид, показанный ниже:
```py
from django import forms

class RenewBookForm(forms.Form):
    renewal_date = forms.DateField(help_text="Enter a date between now and 4 weeks (default 3).")
```

[Назад к Django](#django)

### Поля формы

В нашем случае мы имеем одно поле типа [DateField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#datefield), которое служит для ввода обновлённой даты возврата книги, которое будет отрендерено в HTML с пустым значением и текстовой меткой "Renewal date:", а также текстовым описанием: "Enter a date between now and 4 weeks (default 3 weeks)." Так как никаких дополнительных опций мы не определяем, то поле будет "получать" даты в следующем формате [input_formats](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#django.forms.DateField.input_formats): YYYY-MM-DD (2016-11-06), MM/DD/YYYY (02/26/2016), MM/DD/YY (10/25/16), а для отрисовки по умолчанию, будет использовать [виджет](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#widget): [DateInput](https://docs.djangoproject.com/en/1.10/ref/forms/widgets/#django.forms.DateInput).

Существует множество других типов полей для класса формы, которые по своей функциональности подобны соответствующим им эквивалентам типов полей для классов моделей: [BooleanField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#booleanfield), [CharField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#charfield), [ChoiceField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#choicefield), [TypedChoiceField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#typedchoicefield), [DateField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#datefield), [DateTimeField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#datetimefield), [DecimalField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#decimalfield), [DurationField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#durationfield), [EmailField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#emailfield), [FileField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#filefield), [FilePathField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#filepathfield), [FloatField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#floatfield), [ImageField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#imagefield), [IntegerField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#integerfield), [GenericIPAddressField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#genericipaddressfield), [MultipleChoiceField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#multiplechoicefield), [TypedMultipleChoiceField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#typedmultiplechoicefield), [NullBooleanField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#nullbooleanfield), [RegexField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#regexfield), [SlugField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#slugfield), [TimeField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#timefield), [URLField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#urlfield), [UUIDField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#uuidfield), [ComboField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#combofield), [MultiValueField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#multivaluefield), [SplitDateTimeField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#splitdatetimefield), [ModelMultipleChoiceField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#modelmultiplechoicefield), [ModelChoiceField](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#modelchoicefield).

Общие аргументы для большинства полей перечислены ниже:

- [required](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#required): Если `True`, то данное поле не может быть пустым, или иметь значение `None`. Данное значение установлено по умолчанию.
- [label](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#label): Текстовая метка, используемая для рендеринга поля в HTML-код. Если [label](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#label) не определена, то Django попытается создать её значение при помощи имени поля, переводя первый символ в верхний регистр, а также заменяя символы подчёркивания пробелами (например, для переменной с именем *renewaldate*, будет создан следующий текст метки: `_Renewal date`).
- [label_suffix](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#label-suffix): По умолчанию показывает двоеточие после текста метки (например, `Renewal date**:**`). Данный параметр позволяет вам указать любой суффикс по вашему желанию.
- [initial](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#initial): Начальное значение для поля при показе формы.
- [widget](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#widget): Применяемый виджет для поля.
- [help_text](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#help-text) (как показано в примере выше): Дополнительный текст, который может быть показан на форме, для описания того, как использовать поле.
- [error_messages](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#error-messages): Список сообщений об ошибках для данного поля. Вы можете переопределить его своими сообщениями, при необходимости.
- [validators](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#validators): Список функций, которые будут вызваны для валидации, введённого в поле значения.
- [localize](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#localize): Позволяет осуществить локализацию данных поля формы (например, формат ввода числовых значений, или дат).
- [disabled](https://docs.djangoproject.com/en/1.10/ref/forms/fields/#disabled): Если установлено в True, то поле показывается, но его значение изменить нельзя. По умолчанию равно False.

[Назад к Django](#django)

### Валидация

Django предоставляет несколько мест где вы можете осуществить валидацию ваших данных. Простейшим способом проверки значения одиночного поля является переопределение метода `clean_<fieldname>()` (здесь, `<fieldname>` это имя поля, которое вы хотите проверить). Например, мы хотим проверить, что введённое значение `renewal_date` находится между текущей датой и 4 неделями в будущем. Для этого мы создаём метод `clean_renewal_date()`, как показано ниже:
```py
from django import forms

from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
import datetime #for checking renewal date range.

class RenewBookForm(forms.Form):
    renewal_date = forms.DateField(help_text="Enter a date between now and 4 weeks (default 3).")

    def clean_renewal_date(self):
        data = self.cleaned_data['renewal_date']

        #Проверка того, что дата не выходит за "нижнюю" границу (не в прошлом).
        if data < datetime.date.today():
            raise ValidationError(_('Invalid date - renewal in past'))

        #Проверка того, то дата не выходит за "верхнюю" границу (+4 недели).
        if data > datetime.date.today() + datetime.timedelta(weeks=4):
            raise ValidationError(_('Invalid date - renewal more than 4 weeks ahead'))

        # Помните, что всегда надо возвращать "очищенные" данные.
        return data
```

Необходимо отметить два важных момента. Первый это то, что мы получаем наши данные при помощи словаря `self.cleaned_data['renewal_date']`, а затем в конце возвращаем полученное значение, для проведения необходимых проверок. Данный шаг позволяет нам, при помощи валидаторов, получить "очищенные", проверенные, а затем, приведённые к стандартным типам, данные (в нашем случае к типу Python `datetime.datetime`).

Второй момент касается того случая, когда наше значение "выпадает за рамки" и мы "выкидываем" исключение `ValidationError`, в котором указываем текст, который мы хотим показать на форме, для случая когда были введены неправильные данные. Пример, показанный выше, оборачивает данный текст при помощи [функции перевода Django](https://docs.djangoproject.com/en/1.10/topics/i18n/translation/) `ugettext_lazy()` (импортируемую через `_()`), которая может вам пригодиться, если вы планируете перевести ваш сайт в будущем.

> **Примечание:** Существует множество других методов и примеров валидации различных форм, которые можно найти в [Формы и валидация поля](https://docs.djangoproject.com/en/1.10/ref/forms/validation/) (Django docs). Например, в случае, если у вас имеется много полей, которые зависят один от другого, вы можете переопределить функцию [Form.clean()](https://docs.djangoproject.com/en/1.10/ref/forms/api/#django.forms.Form.clean) и, при необходимости, "выкинуть" `ValidationError`.

В целом, это все, что нам понадобится для создания формы в данном примере!

[Назад к Django](#django)

### Копирование класса формы

Создайте и откройте файл **locallibrary/catalog/forms.py**, а затем скопируйте в него весь код, указанный в предыдущем фрагменте.

### Конфигурация URL-адресов

Перед созданием отображения давайте добавим соответствующую конфигурацию URL-адреса для страницы обновления книг. Скопируйте следующий фрагмент в нижнюю часть файла **locallibrary/catalog/urls.py**.
```py
urlpatterns += [
    url(r'^book/(?P<pk>[-\w]+)/renew/$', views.renew_book_librarian, name='renew-book-librarian'),
]
```

Данная конфигурация перенаправит запросы с адресов формата `/catalog/book/<bookinstance id>/renew/` в функции с именем `renew_book_librarian()` в **views.py**, туда же передаст идентификатор `id` записи `BookInstance` в качестве параметра с именем `pk`. Шаблон соответствует только если **pk** это правильно отформатированный **uiid**.

> **Примечание:** Вместо имени "pk" мы можем использовать любое другое, по нашему желанию, потому что мы имеем полный контроль над функцией отображения (которого у нас нет в случае использования встроенного обобщённого класса отображения, который ожидает параметр с определённым именем). Тем не менее имя `pk` является понятным сокращением от "primary key", поэтому мы его тут и используем!

### Отображение

Как было отмечено в разделе [Процесс управление формой в Django](#процесс-управления-формой-в-django), отображение должно отрендерить форму по умолчанию, когда она вызывается в первый раз и, затем, перерендерить её, в том случае, если возникли какие-либо ошибки при работе с её полями. В случае же успеха, после обработки "правильных" данных отображение перенаправляет пользователя на новую (другую) страницу. Для того чтобы выполнить все эти действия, отображение должно знать вызвано ли оно в первый раз для отрисовки формы по умолчанию, а если это не так, то провести валидацию полученных данных.

Для форм, которые используют `POST`-запрос при отправке информации на сервер, наиболее общей схемой проверки данного факта является следующая строка кода `if request.method == 'POST':`. `GET`-запросу, а также первому запросу формы, в таком случае соответствует блок `else`. Если вы хотите отправлять свои данные в виде `GET`-запроса, то в таком случае приёмом проверки того факта, что данный запрос первый (или последующий), является получение значения какого-либо поля формы (например, если значение скрытого поля формы пустое, то данный вызов является первым).

Процесс обновления книги приводит к изменению информации в базе данных, таким образом, в соответствии с нашими соглашениями, в таком случае мы должны применять запрос типа `POST`. Фрагмент кода, представленный ниже, показывает (наиболее общую) схему работы для таких запросов.
```py
from django.shortcuts import get_object_or_404
from django.http import HttpResponseRedirect
from django.urls import reverse
import datetime

from .forms import RenewBookForm

def renew_book_librarian(request, pk):
    book_inst = get_object_or_404(BookInstance, pk=pk)

    # Если данный запрос типа POST, тогда
    if request.method == 'POST':

        # Создаём экземпляр формы и заполняем данными из запроса (связывание, binding):
        form = RenewBookForm(request.POST)

        # Проверка валидности данных формы:
        if form.is_valid():
            # Обработка данных из form.cleaned_data
            #(здесь мы просто присваиваем их полю due_back)
            book_inst.due_back = form.cleaned_data['renewal_date']
            book_inst.save()

            # Переход по адресу 'all-borrowed':
            return HttpResponseRedirect(reverse('all-borrowed') )

    # Если это GET (или какой-либо ещё), создать форму по умолчанию.
    else:
        proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3)
        form = RenewBookForm(initial={'renewal_date': proposed_renewal_date,})

    return render(request, 'catalog/book_renew_librarian.html', {'form': form, 'bookinst':book_inst})
```

В первую очередь мы импортируем наш класс формы (RenewBookForm), а также другие необходимые объекты и методы:

- [get_object_or_404()](https://docs.djangoproject.com/en/1.10/topics/http/shortcuts/#get-object-or-404): Возвращает определённый объект из модели в зависимости от значения его первичного ключа, или выбрасывает исключение `Http404`, если данной записи не существует.
- [HttpResponseRedirect](https://docs.djangoproject.com/en/1.10/ref/request-response/#django.http.HttpResponseRedirect): Данный класс перенаправляет на другой адрес (HTTP код статуса 302).
- [reverse()](https://docs.djangoproject.com/en/1.10/ref/urlresolvers/#django.urls.reverse): Данная функция генерирует URL-адрес при помощи соответствующего имени URL конфигурации/преобразования и дополнительных аргументов. Это эквивалент Python тэгу url, которые мы использовали в наших шаблонах.
- [datetime:](https://docs.python.org/3/library/datetime.html) Библиотека Python для работы с датами и временим.

В отображении аргумент `pk` мы используем в функции `get_object_or_404()` для получения текущего объекта типа `BookInstance` (если его не существует, то функция, а следом и наше отображение прервут своё выполнение, а на странице пользователя отобразится сообщение об ошибке: "объект не найден"). Если запрос вызова отображения не является `POST`-запросом, то мы переходим к условному блоку `else`, в котором мы создаём форму по умолчанию и передаём ей начальное значения `initial` для поля `renewal_date` (выделено жирным ниже, - 3 недели, начиная с текущей даты).
```py
    book_inst = get_object_or_404(BookInstance, pk=pk)

    # Если это GET (или другой метод), тогда создаём форму по умолчанию
    else:
        proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3)
        form = RenewBookForm(initial={'renewal_date': proposed_renewal_date,})

    return render(request, 'catalog/book_renew_librarian.html', {'form': form, 'bookinst':book_inst})
```

После создания формы мы вызываем функцию `render()`, чтобы создать HTML страницу; передаём ей в качестве параметров шаблон и контекст, который содержит объект формы. Кроме того, контекст содержит объект типа `BookInstance`, который мы будем использовать в шаблоне, для получения информации об обновляемой книге.

Если все таки у нас `POST`-запрос, тогда мы создаём объект с именем `form` и заполняем его данными, полученными из запроса. Данный процесс называется связыванием (или, биндингом, от англ. "binding") и позволяет нам провести валидацию данных. Далее осуществляется валидация формы, при этом проверяются все поля формы — для этого используются как код обобщённого класса, так и пользовательских функций, в частности нашей функции проверки введённых дат `clean_renewal_date()`.
```py
    book_inst = get_object_or_404(BookInstance, pk=pk)

    # Если данный запрос типа POST, тогда
    if request.method == 'POST':

        # Создаём экземпляр формы и заполняем данными из запроса (связывание, binding):
        form = RenewBookForm(request.POST)

        # Проверка валидности формы:
        if form.is_valid():
            # process the data in form.cleaned_data as required (here we just write it to the model due_back field)
            book_inst.due_back = form.cleaned_data['renewal_date']
            book_inst.save()

            # redirect to a new URL:
            return HttpResponseRedirect(reverse('all-borrowed') )

    return render(request, 'catalog/book_renew_librarian.html', {'form': form, 'bookinst':book_inst})
```

Если формы не прошла валидацию, то мы снова вызываем функцию `render()`, но на этот раз форма будет содержать сообщения об ошибках.

Если форма прошла валидацию, тогда мы можем начать использовать данные, получая их из атрибута формы `form.cleaned_data` (то есть, `data = form.cleaned_data['renewal_date']`). Здесь мы просто сохраняем данные в поле `due_back`, соответствующего объекта `BookInstance`.

> **Предупреждение: Важно:** Хотя вы также можете получить доступ к данным формы непосредственно через запрос (например `request.POST['renewal_date']`, или `request.GET['renewal_date']` (в случае GET-запроса), это НЕ рекомендуется. Очищенные данные проверены на вредоносность и преобразованы в типы, совместимые с Python.

Последним шагом в части обработки формы представления является перенаправление на другую страницу, обычно страницу «Успех». В нашем случае мы используем объект класса `HttpResponseRedirect` и функцию `reverse()` для перехода к отображению с именем `'all-borrowed'` (это было домашним заданием в [Руководство часть 8: Аутентификация и разграничение доступа](#django-8-аутентификация-и-авторизация-пользователя)). Если вы не создали данную страницу, то просто укажите переход на домашнюю страницу сайта по адресу '/').

Все это необходимо для управления формой как таковой, но нам нужно как-то ограничить доступ к отображению (открыть доступ только библиотекарям). Мы могли бы создать новое разрешение (permission) в классе `BookInstance` ("`can_renew`"), но мы пойдём простым путём и воспользуемся функцией-декоратором `@permission_required` вместе с нашим существующим разрешением `can_mark_returned`.

Окончательный вид отображения показан ниже. Пожалуйста, скопируйте данный текст в нижнюю часть файла **locallibrary/catalog/views.py**.
```py
from django.contrib.auth.decorators import permission_required

from django.shortcuts import get_object_or_404
from django.http import HttpResponseRedirect
from django.urls import reverse
import datetime

from .forms import RenewBookForm

@permission_required('catalog.can_mark_returned')
def renew_book_librarian(request, pk):
    """
    View function for renewing a specific BookInstance by librarian
    """
    book_inst = get_object_or_404(BookInstance, pk=pk)

    # If this is a POST request then process the Form data
    if request.method == 'POST':

        # Create a form instance and populate it with data from the request (binding):
        form = RenewBookForm(request.POST)

        # Check if the form is valid:
        if form.is_valid():
            # process the data in form.cleaned_data as required (here we just write it to the model due_back field)
            book_inst.due_back = form.cleaned_data['renewal_date']
            book_inst.save()

            # redirect to a new URL:
            return HttpResponseRedirect(reverse('all-borrowed') )

    # If this is a GET (or any other method) create the default form.
    else:
        proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3)
        form = RenewBookForm(initial={'renewal_date': proposed_renewal_date,})

    return render(request, 'catalog/book_renew_librarian.html', {'form': form, 'bookinst':book_inst})
```

[Назад к Django](#django)

### Шаблон

Создайте шаблон, на который ссылается наше отображение (**/catalog/templates/catalog/book_renew_librarian.html**) и скопируйте в него код, указанный ниже:
```html
{% extends "base_generic.html" %}
{% block content %}

    <h1>Renew: {{bookinst.book.title}}</h1>
    <p>Borrower: {{bookinst.borrower}}</p>
    <p{% if bookinst.is_overdue %} class="text-danger"{% endif %}>Due date: {{bookinst.due_back}}</p>

    <form action="" method="post">
        {% csrf_token %}
        <table>
        {{ form }}
        </table>
        <input type="submit" value="Submit" />
    </form>

{% endblock %}
```

Большая его часть вам знакома из предыдущих частей руководства. Мы расширяем базовый шаблон, а затем замещаем блок содержимого `content`. У нас имеется возможность ссылаться на переменную `{{bookinst}}` (и её поля) поскольку мы передали её в объект контекста при вызове функции `render()`. Здесь мы используем данный объект для вывода заголовка книги, дат её получения и возврата.

Код формы относительно прост. В первую очередь мы объявляем тэг `form`, затем определяем куда будут отправлены данные (`action`) и каким способом (`method`, в данном случае "HTTP POST") — если обратитесь к обзору раздела [Формы HTML](#django-9-работа-с-формами) в верхней части данной страницы, то найдёте там замещение, что пустое значение атрибута `action`, означает, что данные из формы будут переданы обратно по текущему URL-адресу данной страницы (чего мы и хотим!). Внутри тэга формы мы объявляем кнопку `submit` при помощи которой мы можем отправить наши данные. Блок `{% csrf_token %}`, добавленный первой строкой внутри блока формы, является частью фреймворка Django и служит для борьбы с CSRF.

Примечание: Добавляйте `{% csrf_token %}` в каждый шаблон Django, в котором вы создаёте форму для отправки данных методом `POST`. Это поможет уменьшить вероятность взлома вашего сайта злоумышленниками.

Все что осталось, это указать переменную `{{form}}`, которую мы передали в шаблон в словаре контекста. Возможно это вас не удивит, но таким образом мы предоставим возможность форме отрендерить свои поля с их метками, виджетами и дополнительными текстами, и в результате мы получим следующее:
```html
<tr>
  <th><label for="id_renewal_date">Renewal date:</label></th>
  <td>
    <input
      id="id_renewal_date"
      name="renewal_date"
      type="text"
      value="2016-11-08"
      required />
    <br />
    <span class="helptext"
      >Enter date between now and 4 weeks (default 3 weeks).</span
    >
  </td>
</tr>
```

> **Примечание:** Возможно это не очевидно, поскольку наша форма содержит только одно поле, но по умолчанию каждое поле формы помещается в её собственную строку таблицы (поэтому переменная `{{form}}` находится внутри тэга `table`. Тот же результат можно получить, если воспользоваться следующим вызовом `{{ form.as_table }}`.

Если вы ввели неправильную дату, то на странице вы должны получить список сообщений об ошибках (показано жирным ниже).
```html
<tr>
  <th><label for="id_renewal_date">Renewal date:</label></th>
  <td>
    <ul class="errorlist">
      <li>Invalid date - renewal in past</li>
    </ul>
    <input
      id="id_renewal_date"
      name="renewal_date"
      type="text"
      value="2015-11-08"
      required />
    <br />
    <span class="helptext"
      >Enter date between now and 4 weeks (default 3 weeks).</span
    >
  </td>
</tr>
```

[Назад к Django](#django)

### Другие варианты применения переменной шаблона form

В простом случае применения `{{form}}` как показано выше, каждое поле рендерится в виде отдельной строки таблицы. Кроме того, вы можете отрендерить каждое поле как список элементов (`{{form.as_ul}}`), или как параграф (`{{form.as_p}}`).

Что ещё больше вдохновляет, так это то, что вы можете полностью контролировать процесс рендеринга любой части формы, используя для этого дот-нотацию (точку). Например, мы можем получить доступ к следующим полям поля формы `renewal_date`:

- `{{form.renewal_date}}`: само поле.
- `{{form.renewal_date.errors}}`: Список ошибок.
- `{{form.renewal_date.id_for_label}}`: Идентификатор текстовой метки.
- `{{form.renewal_date.help_text}}`: Дополнительный текст.
- и так далее!

Примеры того как вручную отрендерить формы в шаблонах, а также пробежать циклом по шаблонным полям, смотрите [Работы с формами > Ручная работа с формами](https://docs.djangoproject.com/en/1.10/topics/forms/#rendering-fields-manually) (Django docs).

### Тестирование страницы

Если вы выполнили задание в [Django руководство часть 8: Аутентификация и разрешение доступа](#django-8-аутентификация-и-авторизация-пользователя), то у вас должна быть страница со списком всех книг в наличии библиотеки и данный список (страница) должен быть доступен только её сотрудникам. На данной странице в каждом пункте (для каждой книги) мы можем добавить ссылку на нашу новую страницу обновления книги.
```django
{% if perms.catalog.can_mark_returned %}-
  <a href="{% url 'renew-book-librarian' bookinst.id %}">Renew</a>
{% endif %}
```

> **Примечание:** Помните что, для того чтобы перейти на страницу обновления книги, ваш тестовый логин должен иметь разрешение доступа типа "`catalog.can_mark_returned`"(возможно надо воспользоваться вашим аккаунтом для суперпользователя).

Вы можете попробовать вручную создать URL-адрес для тестирования, например — `http://127.0.0.1:8000/catalog/book/<bookinstance_id>/renew/` (правильный идентификатор записи id для bookinstance можно получить, если перейти на страницу детальной информации книги и скопировать поле `id`).

[Назад к Django](#django)

### Как теперь все это выглядит?

Если все получилось как надо, то форма по умолчанию должна выглядеть следующим образом:

![renew](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/forms_example_renew_default.png)

А такой наша форма будет в случае ввода неправильной даты:

![invalid renew](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/forms_example_renew_invalid.png)

Список всех книг с ссылками на страницу обновления данных:

![borrowed](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/forms_example_renew_allbooks.png)

### Класс ModelForm

Создание класса формы `Form` при помощи примера, описанного выше, является довольно гибким способом, позволяющим вам создавать формы любой структуры которую вы пожелаете, в связке с любой моделью, или моделями.

Тем не менее, если вам просто нужна форма для отображения полей одиночной модели, тогда эта самая модель уже содержит большую часть информации, которая вам нужна для построения формы: сами поля, текстовые метки, дополнительный текст и так далее. И чтобы не воспроизводить информацию из модели для вашей формы, проще воспользоваться классом [ModelForm](https://docs.djangoproject.com/en/1.10/topics/forms/modelforms/), который помогает создавать формы непосредственно из модели. Класс `ModelForm` может применяться в ваших отображениях точно таким же образом как и "классический" класс формы `Form`.

Базовая реализация `ModelForm` содержит тоже поле как и ваш предыдущий класс формы `RenewBookForm`, что и показано ниже. Все что вам необходимо сделать, - внутри вашего нового класса добавить класс `Meta` и связать его с моделью `model` (`BookInstance`), а затем перечислить поля модели в поле `fields` которые должны быть включены в форму (вы можете включить все поля при помощи `fields = '__all__'`, или можно воспользоваться полем `exclude` (вместо `fields`), чтобы определить поля модели, которые не нужно включать).
```py
from django.forms import ModelForm
from .models import BookInstance

class RenewBookModelForm(ModelForm):
    class Meta:
        model = BookInstance
        fields = ['due_back',]
```

> **Примечание:** Это не выглядит сильно проще, чем просто использовать класс `Form` (и это действительно так, поскольку мы используем только одно поле). Тем не менее, если вы хотите иметь много полей, то такой способ построения формы может значительно уменьшить количество кода и ускорить разработку!

Оставшаяся часть информации касается объявления полей модели (то есть, текстовых меток, виджетов, текстов, сообщений об ошибках). Если они недостаточно "правильные", то тогда мы можем переопределить их в нашем классе `Meta` при помощи словаря, содержащего поле, которое надо изменить и его новое значение. Например, в нашей форме мы могли бы поменять текст метки для поля *"Renewal date"* (вместо того, чтобы оставить текст по умолчанию: *Due date*), а кроме того мы хотим написать другой вспомогательный текст. Класс `Meta`, представленный ниже, показывает вам, как переопределить данные поля. Кроме того, при необходимости, вы можете установить значения для виджетов `widgets` и сообщений об ошибках `error_messages`.
```py
class Meta:
    model = BookInstance
    fields = ['due_back',]
    labels = { 'due_back': _('Renewal date'), }
    help_texts = { 'due_back': _('Enter a date between now and 4 weeks (default 3).'), }
```

Чтобы добавить валидацию, вы можете использовать тот же способ как и для класса `Form` — вы определяете функцию с именем `clean_field_name()` из которой выбрасываете исключение `ValidationError`, если это необходимо. Единственным отличием от нашей оригинальной формы будет являться то, что поле модели имеет имя `due_back`, а не "`renewal_date`".
```py
from django.forms import ModelForm
from .models import BookInstance

class RenewBookModelForm(ModelForm):
    def clean_due_back(self):
       data = self.cleaned_data['due_back']

       #Проверка того, что дата не в прошлом
       if data < datetime.date.today():
           raise ValidationError(_('Invalid date - renewal in past'))

       #Check date is in range librarian allowed to change (+4 weeks)
       if data > datetime.date.today() + datetime.timedelta(weeks=4):
           raise ValidationError(_('Invalid date - renewal more than 4 weeks ahead'))

       # Не забывайте всегда возвращать очищенные данные
       return data

    class Meta:
        model = BookInstance
        fields = ['due_back',]
        labels = { 'due_back': _('Renewal date'), }
        help_texts = { 'due_back': _('Enter a date between now and 4 weeks (default 3).'), }
```

Теперь класс `RenewBookModelForm` является функциональным эквивалентом нашему предыдущему классу `RenewBookForm`. Вы можете импортировать и использовать его в тех же местах, где и `RenewBookForm`.

[Назад к Django](#django)

### Обобщённые классы отображения для редактирования

Алгоритм управления формой, который мы использовали в нашей функции отображения, является примером достаточно общего подхода к работе с формой. Django старается абстрагировать и упростить большую часть данной работы, путём широкого применения [обобщённых классов отображений](https://docs.djangoproject.com/en/1.10/ref/class-based-views/generic-editing/), которые служат для создания, редактирования и удаления отображений на основе моделей. Они не только управляют поведением отображения, но, кроме того, они из вашей модели автоматически создают класс формы (`ModelForm`).

> **Примечание:** В дополнение к отображениям для редактирования, описываемых здесь, существует также класс [FormView](https://docs.djangoproject.com/en/1.10/ref/class-based-views/generic-editing/#formview), который по своему предназначению находится где-то между "простой" функцией отображения и другими обобщёнными отображениями, то есть в каком-то смысле, в диапазоне: "гибкость" против "усилия при программировании". Применяя `FormView`, вы все ещё нуждаетесь в создании класса `Form`, но вам не нужно реализовывать всю "стандартную" функциональность работы с формой. Вместо этого, вы должны просто реализовать функцию, которая будет вызвана в тот момент, когда станет понятно, что получаемые из формы данные, "правильные" (валидны).

В данном разделе мы собираемся использовать обобщённые классы для редактирования, для того, чтобы создать страницы, который добавляют функциональность создания, редактирования и удаления записей типа `Author` из нашей библиотеки — предоставляя базовую функциональность некоторых частей административной части сайта (это может быть полезно для случаев, когда вам нужно создать административную часть сайта, которая, в отличие от стандартной, была бы более гибкой).

### Отображения
Откройте файл отображений (**locallibrary/catalog/views.py**) и добавьте следующий код в его нижнюю часть:
```py
from django.views.generic.edit import CreateView, UpdateView, DeleteView
from django.urls import reverse_lazy
from .models import Author

class AuthorCreate(CreateView):
    model = Author
    fields = '__all__'
    initial={'date_of_death':'12/10/2016',}

class AuthorUpdate(UpdateView):
    model = Author
    fields = ['first_name','last_name','date_of_birth','date_of_death']

class AuthorDelete(DeleteView):
    model = Author
    success_url = reverse_lazy('authors')
```

Как вы видите, для создания отображений вам надо наследоваться от следующих классов `CreateView`, `UpdateView` и `DeleteView` (соответственно), а затем связать их с соответствующей моделью.

Для случаев "создать" и "обновить" вам также понадобится определить поля для показа на форме (применяя тот же синтаксис, что и для `ModelForm`). В этом случае мы демонстрируем синтаксис и для показа "всех" полей, и перечисление их по отдельности. Также вы можете указать начальные значения для каждого поля, применяя словарь пар *имяполя/значение_* (в целях демонстрации, в нашем примере мы явно указываем дату смерти — если хотите, то вы можете удалить это поле). По умолчанию отображения перенаправляют пользователя на страницу "успеха", показывая только что созданные/отредактированные данные (записи в модели). В нашем случае это, созданная в предыдущей части руководства, подробная информация об авторе. Вы можете указать альтернативное перенаправление при помощи параметра `success_url` (как в примере с классом `AuthorDelete`).

Классу `AuthorDelete` не нужно показывать каких либо полей, таким образом их не нужно и декларировать. Тем не менее, вам нужно указать `success_url`, потому что, в данном случае, для Django не очевидно что делать после успешного выполнения операции удаления записи. Мы используем функцию [reverse_lazy()](https://docs.djangoproject.com/en/1.10/ref/urlresolvers/#reverse-lazy) для перехода на страницу списка авторов после удаления одного из них — `reverse_lazy()` это более "ленивая" версия `reverse()`.

[Назад к Django](#django)

### Шаблоны

Отображения "создать" и "обновить" используют шаблоны с именем `model_name_form.html`, по умолчанию: (вы можете поменять суффикс на что-нибудь другое, при помощи поля `template_name_suffix` в вашем отображении, например, `template_name_suffix = '_other_suffix'`)

Создайте файл шаблона **locallibrary/catalog/templates/catalog/author_form.html** и скопируйте в него следующий текст.
```django
{% extends "base_generic.html" %}

{% block content %}
  <form action="" method="post">
      {% csrf_token %}
      <table>
      {{ form.as_table }}
      </table>
      <input type="submit" value="Submit" />
  </form>
{% endblock %}
```

Это напоминает наши предыдущие формы и рендер полей при помощи таблицы. Заметьте, что мы снова используем `{% csrf_token %}`.

Отображения "удалить" ожидает "найти" шаблон с именем формата **model_name_confirm_delete.html** (и снова, вы можете изменить суффикс при помощи поля отображения `template_name_suffix`). Создайте файл шаблона **locallibrary/catalog/templates/catalog/author_confirm_delete.html** и скопируйте в него текст, указанный ниже.
```django
{% extends "base_generic.html" %}

{% block content %}
  <h1>Delete Author</h1>

  <p>Are you sure you want to delete the author: {{ author }}?</p>

  <form action="" method="POST">
    {% csrf_token %}
    <input type="submit" value="Yes, delete." />
  </form>
{% endblock %}
```

Настройки URL-адресов
Откройте файл конфигураций URL-адресов (**locallibrary/catalog/urls.py**) и добавьте в его нижнюю часть следующие настройки:
```py
urlpatterns += [
    url(r'^author/create/$', views.AuthorCreate.as_view(), name='author_create'),
    url(r'^author/(?P<pk>\d+)/update/$', views.AuthorUpdate.as_view(), name='author_update'),
    url(r'^author/(?P<pk>\d+)/delete/$', views.AuthorDelete.as_view(), name='author_delete'),
]
```
Здесь нет ничего нового! Как вы видите отображения являются классами и следовательно должны вызываться через метод `.as_view()`. Паттерны URL-адресов для каждого случая должны быть вам понятны. Мы обязаны использовать `pk` как имя для "захваченного" значения первичного ключа, так как параметр именно с таким именем ожидается классами отображения.

Страницы создания, обновления и удаления автора теперь готовы к тестированию (мы не будем создавать на них ссылки в отдельном меню, но вы, если хотите, можете их сделать).

> **Примечание:** Наблюдательные пользователи могли заметить, что мы ничего не делаем, чтобы предотвратить несанкционированный доступ к страницам! Мы оставили это в качестве упражнения для вас (подсказка: вы можете использовать `PermissionRequiredMixin` и, либо создать новое разрешение, или воспользоваться нашим прежним `can_mark_returned`).

[Назад к Django](#django)

### Тестирование страницы

Залогиньтесь на сайте с аккаунтом, который позволит вам получить доступ к страницам редактирования данных (и записей) автора.

Затем перейдите на страницу создания новой записи автора: `http://127.0.0.1:8000/catalog/author/create/`, которая должна быть похожей на следующий скриншот.

![author create](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/forms_example_create_author.png)

Введите в поля значения и нажмите на кнопку **Submit**, чтобы сохранить новую запись об авторе. После этого, вы должны были перейти на страницу редактирования только что созданного автора, имеющий адрес, похожий на следующий `http://127.0.0.1:8000/catalog/author/10`.

У вас есть возможность редактирования записей при помощи добавления `/update/` в конец адреса подробной информации (то есть, `http://127.0.0.1:8000/catalog/author/10/update/`) — мы не показываем скриншот, потому что он выглядит в точности также как страница "создать"!

И последнее, мы можем удалить страницу, добавляя строку `/delete/` в конец адреса подробной информации автора (то есть, `http://127.0.0.1:8000/catalog/author/10/delete/)`. Django должен показать страницу, которая похожа на представленную ниже. Нажмите Yes, delete., чтобы удалить запись и перейти на страницу со списком авторов.

![author delete](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/forms_example_delete_author.png)

[Назад к Django](#django)

### Проверьте себя

Создайте несколько форм создания, редактирования и удаления записей в модели `Book`. При желании, вы можете использовать тоже структуры как и в случае с моделью `Authors`. Если ваш шаблон **book_form.html** является просто копией шаблона **author_form.html**, тогда новая страница "create book" будет выглядеть как на следующем скриншоте:

![book create](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Forms/forms_example_create_book.png)

### Итоги

Создание и управление формами может быть достаточно сложным! Django делает этот процесс намного проще, предоставляя прикладные механизмы объявления, рендеринга и проверки форм. Более того, Django предоставляет обобщённые классы редактирования форм, которые могут выполнять практически любую работу по созданию, редактированию и удалению записей, связанных с одиночной моделью.

Существует много чего ещё, что можно делать с формами (ознакомьтесь со списком ниже), но теперь вы должны понимать как добавлять базовые формы и создавать код управления формой на вашем сайте.

- **Смотрите также**
- [Работа с формами](https://docs.djangoproject.com/en/1.10/topics/forms/) (Django docs)
- [Создание вашего первого приложения, часть 4 > Создание простой формы](https://docs.djangoproject.com/en/1.10/intro/tutorial04/#write-a-simple-form) (Django docs)
- [Forms API](https://docs.djangoproject.com/en/1.10/ref/forms/api/) (Django docs)
- [Поля класса Form](https://docs.djangoproject.com/en/1.10/ref/forms/fields/) (Django docs)
- [Класс Form и валидация поля](https://docs.djangoproject.com/en/1.10/ref/forms/validation/) (Django docs)
- [Управление классом Form из классов отображений](https://docs.djangoproject.com/en/1.10/topics/class-based-views/generic-editing/) (Django docs)
- [Создание форм из моделей](https://docs.djangoproject.com/en/1.10/topics/forms/modelforms/) (Django docs)
- [Обобщённые отображения для редактирования](https://docs.djangoproject.com/en/1.10/ref/class-based-views/generic-editing/) (Django docs)

[Назад к Django](#django)

## Django 10: тестрование приложений Django

Сайты, в процессе развития и разработки, становится все сложнее тестировать вручную. Кроме такого тестирования, сложными становятся внутренние взаимодействия между компонентами - внесение небольшого изменения в одной части приложения влияет на другие. При этом, чтобы все продолжало работать нужно вносить все больше и больше изменений и, желательно так, чтобы не добавлялись новые ошибки. Одним из способов который позволяет смягчить последствия добавления изменений, является внедрение в разработку автоматического тестирования - оно должно просто и надёжно запускаться каждый раз, когда вы вносите изменения в свой код. Данное руководство рассматривает вопросы автоматизации юнит-тестирования вашего сайта при помощи фреймворка Django для тестов.

| Требования:	| Изучить все предыдущие темы руководства, включая [Руководство Django Часть 9: Работа с формами](#django-9-работа-с-формами).
|----|---
| Цель:	| Понимать как создавать юнит тесты для сайта на основе Django.

### Обзор

[LocalLibrary](#django-сайт-местной-библиотеки) в настоящий момент содержит страницы для показа списков всех книг, авторов, подробной информации о книгах `Book` и авторах `Author`, а также страницу для обновления информации об экземпляре книги `BookInstance` и, кроме того, страницы для создания, обновления и удаления записей модели `Author` (и модели `Book`, в том случае, если вы выполнили домашнее задание в руководстве [работа с формами](#django-9-работа-с-формами)). Даже в случае небольшого сайта, ручной переход на каждую страницу и беглая проверка того, что все работает как следует, может занять несколько минут. В процессе внесения изменений и роста сайта требуемое время для проведения проверок будет только возрастать. Если бы мы продолжили в том же духе, то в какой-то момент на проведение тестов мы тратили бы больше времени, чем на написание кода и внесение изменений.

Автоматические тесты могут серьёзно помочь нам справиться с этой проблемой! Очевидными преимуществами в таком случае являются значительно меньшие временные затраты на проведение тестов, их подробное выполнение, а кроме того, тесты имеют постоянную функциональность, или последовательность действий (человек никогда не сможет тестировать так надёжно!). В связи с быстротой их выполнения автоматические тесты можно выполнять более часто, а если они провалятся, то укажут на соответствующее место (где что-то пошло не так как ожидалось).

Кроме того, автоматические тесты могут действовать как первый "настоящий пользователь" вашего кода, заставляя вас строго следить за объявлениями и документированием поведения вашего сайта. Тесты часто являются основой для создания примеров вашего кода и документации. По этим причинам иногда некоторые процессы разработки программного обеспечения начинаются с определения тестов и их реализации, а уже после этого следует написание кода который должен иметь соответствующее поведение (так называемая разработка на [основе тестов](https://en.wikipedia.org/wiki/Test-driven_development) и на [основе поведения](https://en.wikipedia.org/wiki/Behavior-driven_development)).

Данное руководство показывает процесс создания автоматических тестов в Django при помощи добавления их к разработке сайта [LocalLibrary](#django-сайт-местной-библиотеки).

[Назад к Django](#django)

### Типы тестирования

Существует несколько типов, уровней, классификаций тестов и тестовых приёмов. Наиболее важными автоматическими тестами являются:

- **Юнит-тесты**

Проверяют функциональное поведение для отдельных компонентов, часто классов и функций.

- **Регрессионное тестирование**

Тесты которые воспроизводят исторические ошибки (баги). Каждый тест вначале запускается для проверки того, что баг был исправлен, а затем перезапускается для того, чтобы убедиться, что он не был внесён снова с появлением новых изменений в коде.

- **Интеграционные тесты**

Проверка совместной работы групп компонентов. Данные тесты отвечают за совместную работу между компонентами, не обращая внимания на внутренние процессы в компонентах. Они проводятся как для простых групп компонентов, так и для целых веб-сайтов.

> **Примечание:** К другим типам тестов относятся методы чёрного ящика, белого ящика, ручные, автоматические, канареечные (canary), дымные (smoke), соответствия (conformance), принятия (acceptance), функциональные (functional), системные (system), эффективности (performance), загрузочные (load) и стресс-тесты (stress tests).

[Назад к Django](#django)

### Что Django предоставляет для тестирования?

Тестирование сайта это сложная задача, потому что она состоит их нескольких логических слоёв – от HTTP-запроса и запроса к моделям, до валидации формы и их обработки, а кроме того, рендеринга шаблонов страниц.

Django предоставляет фреймворк для создания тестов, построенного на основе иерархии классов, которые, в свою очередь, зависят от стандартной библиотеки Python [unittest](https://docs.python.org/3/library/unittest.html#module-unittest). Несмотря на название, данный фреймворк подходит и для юнит-, и для интеграционного тестирования. Фреймворк Django добавляет методы API и инструменты, которые помогают тестировать как веб так и, специфическое для Django, поведение. Это позволяет вам имитировать URL-запросы, добавление тестовых данных, а также проводить проверку выходных данных ваших приложений. Кроме того, Django предоставляет API ([LiveServerTestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#liveservertestcase)) и инструменты [для применения различных фреймворков тестирования](https://docs.djangoproject.com/en/1.10/topics/testing/advanced/#other-testing-frameworks), например вы можете подключить популярный фреймворк [Selenium (англ.)](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Testing/Your_own_automation_environment) для имитации поведения пользователя в реальном браузере.

Для написания теста вы должны наследоваться от любого из классов тестирования Django (или *юниттеста*) ([SimpleTestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#simpletestcase), [TransactionTestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#transactiontestcase), [TestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#testcase), [LiveServerTestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#liveservertestcase)), а затем реализовать отдельные методы проверки кода (тесты это функции-"утверждения", которые проверяют, что результатом выражения являются значения `True` или `False`, или что два значения равны и так далее). Когда вы запускаете тест, фреймворк выполняет соответствующие тестовые методы в вашем классе-наследнике. Методы тестирования запускаются независимо друг от друга, начиная с метода настроек и/или завершаясь методом разрушения (tear-down), определённом в классе, как показано ниже.
```py
class YourTestClass(TestCase):

    def setUp(self):
        # Установки запускаются перед каждым тестом
        pass

    def tearDown(self):
        # Очистка после каждого метода
        pass

    def test_something_that_will_pass(self):
        self.assertFalse(False)

    def test_something_that_will_fail(self):
        self.assertTrue(False)
```

Самый подходящий базовый класс для большинства тестов это [django.test.TestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#testcase). Этот класс создаёт чистую базу данных перед запуском своих методов, а также запускает каждую функцию тестирования в его собственной транзакции. У данного класса также имеется тестовый [Клиент](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#django.test.Client), который вы можете использовать для имитации взаимодействия пользователя с кодом на уровне отображения. В следующих разделах мы сконцентрируемся на юнит-тестах, которые будут созданы на основе класса [TestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#testcase).

> **Примечание:** Класс [django.test.TestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#testcase) очень удобен, но он может приводить к замедленной работе в некоторых случаях (не для каждого теста необходимо настраивать базу данных, или имитировать взаимодействие с отображением). Когда вы познакомитесь с работой данного класса, то сможете заменить некоторые из ваших тестов на более простые классы тестирования.

[Назад к Django](#django)

### Что вы должны тестировать?

Вы должны тестировать все аспекты, касающиеся вашего кода, но не библиотеки, или функциональность, предоставляемые Python, или Django.

Например, рассмотрим модель `Author`, определённую ниже. Вам не нужно проверять тот факт, что `first_name` и `last_name` были сохранены в базу данных как `CharField`, потому что за это отвечает непосредственно Django (хотя конечно, на практике в течение разработки вы косвенно будете проверять данную функциональность). Тоже касается и, например, проверки того, что поле `date_of_birth` является датой, поскольку это тоже часть реализации Django.

Вы должны проверить текст для меток (*First name, Last_name, Date of birth, Died*), и размер поля, выделенного для текста (*100 символов*), потому что они являются частью вашей разработки и чем-то, что может сломаться/измениться в будущем.
```py
class Author(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    date_of_birth = models.DateField(null=True, blank=True)
    date_of_death = models.DateField('Died', null=True, blank=True)

    def get_absolute_url(self):
        return reverse('author-detail', args=[str(self.id)])

    def __str__(self):
        return '%s, %s' % (self.last_name, self.first_name)
```

Подобным же образом вы должны убедиться, что методы `get_absolute_url()` и `__str__()` ведут себя как требуется, потому что они являются частью вашей бизнес логики. В случае функции `get_absolute_url()` вы можете быть уверены, что функция из Django `reverse()` была реализована правильно и, следовательно, вы тестируете только то, чтобы соответствующий вызов в отображении был правильно определён.

> **Примечание:** Проницательные читатели могут заметить, что мы можем некоторым образом ограничить дату рождения и смерти какими-то граничными значениями и выполнять проверку, чтобы дата смерти шла после рождения. В Django данное ограничение может быть добавлено к вашим классам форм (хотя вы и можете определить валидаторы для этих полей, они будут проявлять себя только на уровне форм, а не уровне модели).

Ну что же, усвоив данную информацию, давайте перейдём к процессу определения и запуска тестов.

### Обзор структуры тестов

Перед тем как мы перейдём к тому "что тестировать", давайте кратко взглянем на моменты где и как определяются тесты.

Django использует юнит-тестовый модуль - [встроенный "обнаруживатель" тестов](https://docs.python.org/3/library/unittest.html#unittest-test-discovery), который находит тесты в текущей рабочей директории, в любом файле с шаблонным именем **test*.py**. Предоставляя соответствующие имена файлов, вы можете работать с любой структурой которая вас устраивает. Мы рекомендуем создать пакет для вашего тестирующего кода и, следовательно, отделить файлы моделей, отображений, форм и любые другие, от кода который будет использоваться для тестов. Например:
```bash
catalog/
  /tests/
    __init__.py
    test_models.py
    test_forms.py
    test_views.py
```

В проекте [LocalLibrary](#django-сайт-местной-библиотеки) создайте файловую структуру, указанную выше. Файл **__init__.py** должен быть пустым (так мы говорим Питону, что данная директория является пакетом). Вы можете создать три тестовых файла при помощи копирования и переименования файла-образца **/catalog/tests.py**.

> Примечание: Скелет тестового файла **/catalog/tests.py** был создан автоматически когда мы выполняли [построение скелета сайта Django](#django-2-создание-скелета). Является абсолютно "легальным" действием - поместить все ваши тесты в данный файл, тем не менее, если вы проводите тесты "правильно", то вы очень быстро придёте к очень большому и неуправляемому файлу тестирования.
> 
> Можете удалить данный файл, поскольку больше он нам не понадобится.

Откройте **/catalog/tests/test_models.py**. Файл должен импортировать `django.test.TestCase`, как показано ниже:
```py
from django.test import TestCase

# Поместите ваш код тестов здесь
```

Вы часто будете добавлять соответствующий тестовый класс для каждой модели/отображения/формы с отдельными методами проверки каждой отдельной функциональности. В каких-то случаях вы захотите иметь отдельный класс для тестирования какого-то особого варианта работы, или функциональности, с отдельными функциями тестирования, которые будут проверять элемент/элементы данного варианта (например, мы можем создать отдельный класс тестирования для проверки того, что поле валидно, - функции данного класса будут проверять каждый неверный вариант использования). Опять же, структура файлов и пакетов полностью зависит от вас и будет лучше если вы будете её придерживаться.

Добавьте тестовый класс, показанный ниже, в нижнюю часть файла. Данный класс демонстрирует как создать класс тестирования при помощи наследования от `TestCase`.
```py
class YourTestClass(TestCase):

    @classmethod
    def setUpTestData(cls):
        print("setUpTestData: Run once to set up non-modified data for all class methods.")
        pass

    def setUp(self):
        print("setUp: Run once for every test method to setup clean data.")
        pass

    def test_false_is_false(self):
        print("Method: test_false_is_false.")
        self.assertFalse(False)

    def test_false_is_true(self):
        print("Method: test_false_is_true.")
        self.assertTrue(False)

    def test_one_plus_one_equals_two(self):
        print("Method: test_one_plus_one_equals_two.")
        self.assertEqual(1 + 1, 2)
```

Этот класс определяет два метода которые вы можете использовать для дотестовой настройки (например, создание какой-либо модели, или других объектов, которые вам понадобятся):

- `setUpTestData()` вызывается каждый раз перед запуском теста на уровне настройки всего класса. Вы должны использовать данный метод для создания объектов, которые не будут модифицироваться/изменяться в каком-либо из тестовых методов.
- `setUp()` вызывается перед каждой тестовой функцией для настройки объектов, которые могут изменяться во время тестов (каждая функция тестирования будет получать "свежую" версию данных объектов).

> **Примечание:** Классы тестирования также содержат метод `tearDown()`, который мы пока не используем. Этот метод не особенно полезен для тестирования баз данных, поскольку базовый класс `TestCase` автоматически разрывает соединения с ними.

Далее идут несколько методов, которые используют функции `Assert`, проверяющие условия "истинно" (true), "ложно" (false) или равенство (`AssertTrue`, `AssertFalse`, `AssertEqual`). Если условия не выполняются как ожидалось, то это приводит к провалу теста и выводу соответствующего сообщения об ошибке на консоль.

Функции проверки утверждений `AssertTrue`, `AssertFalse`, `AssertEqual` реализованы в **unittest**. В данном фреймворке существуют и другие подобные функции, а кроме того, [специфические для Django функции](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#assertions) проверки, например, перехода из/к отображению (`assertRedirects`), проверки использования какого-то конкретного шаблона (`assertTemplateUsed`) и так далее.

> **Примечание:** В обычной ситуации у вас нет необходимости вызывать функции **print()** из методов теста, как во фрагменте выше. Мы поступили так только для того, чтобы вы в консоле увидели порядок вызова тестовых функций класса.

[Назад к Django](#django)

### Как запускать тесты

Простейшим способом запуска всех тестов является применение следующей команды:
```bash
python3 manage.py test
```

Таким образом мы найдём в текущей директории все файлы с именем **test*.py** и запустим все тесты (у нас имеются несколько файлов для тестирования, но на данный момент, только **/catalog/tests/test_models.py** содержит какие-либо тесты). По умолчанию, тесты сообщат что-нибудь, только в случае провала.

Запустите тесты из корневой папки сайта [LocalLibrary](#django-сайт-местной-библиотеки). Вы должны увидеть вывод, который похож на следующий.
```bash
>python manage.py test

Creating test database for alias 'default'...
setUpTestData: Run once to set up non-modified data for all class methods.
setUp: Run once for every test method to setup clean data.
Method: test_false_is_false.
.setUp: Run once for every test method to setup clean data.
Method: test_false_is_true.
.setUp: Run once for every test method to setup clean data.
Method: test_one_plus_one_equals_two.
.
======================================================================
FAIL: test_false_is_true (catalog.tests.tests_models.YourTestClass)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "D:\Github\django_tmp\library_w_t_2\locallibrary\catalog\tests\tests_models.py", line 22, in test_false_is_true
    self.assertTrue(False)
AssertionError: False is not true

----------------------------------------------------------------------
Ran 3 tests in 0.075s

FAILED (failures=1)
Destroying test database for alias 'default'...
```

Как видите, один тест провалился и мы можем точно увидеть в какой именно функции это произошло и почему (так и было задумано, поскольку `False` не равен `True`!).

> **Примечание:** Самая важная вещь, которую нужно извлечь из тестового выхода выше, заключается в том, что это гораздо более ценно, если вы используете описательные/информативные имена для ваших объектов и методов.

Текст выделенный жирным, обычно не должен появляться в тестовом выводе (это результат работы функций `print()` в наших тестах). Он показывает, что вызов метода `setUpTestData()` происходит один раз для всего класса в целом, а вызовы `setUp()` осуществляются перед каждым методом.

Следующий раздел показывает как запускать отдельные тесты и как контролировать процесс вывода информации.

[Назад к Django](#django)

### Ещё больше тестовой информации

Если вы желаете получать больше информации о тестах вы должны изменить значение параметра verbosity. Например, для вывода списка успешных и неуспешных тестов (и всю информацию о том, как прошла настройка базы данных) вы можете установить значение verbosity равным "2":
```bash
python3 manage.py test --verbosity 2
```

Доступными значениями для verbosity являются 0, 1 (значение по умолчанию), 2 и 3.

### Запуск определённых тестов

Если вы хотите запустить подмножество тестов, тогда вам надо указать полный путь к вашему пакету, модулю/подмодулю, классу наследнику TestCase, или методу:
```bash
python3 manage.py test catalog.tests   # Run the specified module
python3 manage.py test catalog.tests.test_models  # Run the specified module
python3 manage.py test catalog.tests.test_models.YourTestClass # Run the specified class
python3 manage.py test catalog.tests.test_models.YourTestClass.test_one_plus_one_equals_two  # Run the specified method
```

### Тестирование LocalLibrary

Теперь, когда мы знаем как запустить наши тесты и что именно мы должны тестировать, давайте рассмотрим некоторые практические примеры.

> **Примечание:** Мы не будем расписывать все тесты, а просто покажем вам пример того, как они должны работать и что ещё вы можете с ними сделать.

Модели
Как было отмечено ранее, мы должны тестировать все то, что является частью нашего кода, а не библиотеки/код, которые уже были протестированы командами разработчиков Django, или Python.

Рассмотрим модель `Author`. Мы должны провести тесты текстовых меток всех полей, поскольку, даже несмотря на то, что не все они определены, у нас есть проект, в котором сказано, что все их значения должны быть заданы. Если мы не проведём их тестирование, тогда мы не будем знать, что данные метки действительно содержат необходимые значения. Мы уверены в том, что Django создаст поле заданной длины, таким образом наши тесты будут проверять нужный нам размер поля, а заодно и его содержимое.
```python
class Author(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    date_of_birth = models.DateField(null=True, blank=True)
    date_of_death = models.DateField('Died', null=True, blank=True)

    def get_absolute_url(self):
        return reverse('author-detail', args=[str(self.id)])

    def __str__(self):
        return '%s, %s' % (self.last_name, self.first_name)
```

Откройте файл **/catalog/tests/test_models.py** и замените все его содержимое кодом, приведённом во фрагменте для тестирования модели `Author` (фрагмент представлен ниже).

В первой строке мы импортируем класс `TestCase`, а затем наследуемся от него, создавая класс с описательным именем (`AuthorModelTest`), оно поможет нам идентифицировать места провалов в тестах во время вывода информации на консоль. Затем мы создаём метод `setUpTestData()`, в котором создаём объект автора, который мы будем использовать в тестах, но нигде не будем изменять.
```py
from django.test import TestCase

# Create your tests here.

from catalog.models import Author

class AuthorModelTest(TestCase):

    @classmethod
    def setUpTestData(cls):
        #Set up non-modified objects used by all test methods
        Author.objects.create(first_name='Big', last_name='Bob')

    def test_first_name_label(self):
        author=Author.objects.get(id=1)
        field_label = author._meta.get_field('first_name').verbose_name
        self.assertEquals(field_label,'first name')

    def test_date_of_death_label(self):
        author=Author.objects.get(id=1)
        field_label = author._meta.get_field('date_of_death').verbose_name
        self.assertEquals(field_label,'died')

    def test_first_name_max_length(self):
        author=Author.objects.get(id=1)
        max_length = author._meta.get_field('first_name').max_length
        self.assertEquals(max_length,100)

    def test_object_name_is_last_name_comma_first_name(self):
        author=Author.objects.get(id=1)
        expected_object_name = '%s, %s' % (author.last_name, author.first_name)
        self.assertEquals(expected_object_name,str(author))

    def test_get_absolute_url(self):
        author=Author.objects.get(id=1)
        #This will also fail if the urlconf is not defined.
        self.assertEquals(author.get_absolute_url(),'/catalog/author/1')
```

Тесты полей проверяют значения текстовых меток (verbose_name), включая их ожидаемую длину. Все методы имеют описательные имена, а их логика придерживается одной и той же структуры:
```py
# Получение объекта для тестирования
author=Author.objects.get(id=1)

# Получение метаданных поля для получения необходимых значений
field_label = author._meta.get_field('first_name').verbose_name

# Сравнить значение с ожидаемым результатом
self.assertEquals(field_label,'first name')
```

Интересно отметить следующее:

- Мы не можем получить поле `verbose_name` напрямую через `author.first_name.verbose_name`, потому что `author.first_name` является строкой. Вместо этого, нам надо использовать атрибут `_meta` объекта автора для получения того экземпляра поля, который будет использоваться для получения дополнительной информации.
- Мы выбрали метод `assertEquals(field_label,'first name')` вместо `assertTrue(field_label == 'first name')`, потому что, в случае провала теста, в выводе будет указано какое именно значение содержит метка и это немного облегчит нам задачу по отладке кода.

> **Примечание:** Тесты для текстовых меток `last_name` и `date_of_birth`, а также тест длины поля `last_name` были опущены. Добавьте свою версию этих тестов, соблюдая соглашение об именовании и следуя структуре логики, представленной выше.

Кроме того, нам надо провести тесты наших собственных методов. Они просто проверяют, что имена объектов имеют следующие значения "Last Name, First Name" и что URL-адрес, по которому мы получаем экземпляр `Author`, такой как ожидается.
```py
Copy to Clipboard
def test_object_name_is_last_name_comma_first_name(self):
    author=Author.objects.get(id=1)
    expected_object_name = '%s, %s' % (author.last_name, author.first_name)
    self.assertEquals(expected_object_name,str(author))

def test_get_absolute_url(self):
    author=Author.objects.get(id=1)
    #This will also fail if the urlconf is not defined.
    self.assertEquals(author.get_absolute_url(),'/catalog/author/1')
```

Теперь запустите тесты. Если вы создали модель Author, в соответствии с разделом о моделях данного руководства, то весьма вероятно, что вы получите сообщение об ошибке для метки `date_of_death`, как показано ниже. Тест провалился потому что, в соответствии с соглашением Django, первый символ имени метки должен быть в верхнем регистре (Django делает это автоматически).
```bash
======================================================================
FAIL: test_date_of_death_label (catalog.tests.test_models.AuthorModelTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "D:\...\locallibrary\catalog\tests\test_models.py", line 32, in test_date_of_death_label
    self.assertEquals(field_label,'died')
AssertionError: 'Died' != 'died'
- Died
? ^
+ died
? ^
```

Это несущественный баг, но он демонстрирует нам то, что написание тестов может более тщательно проверить все неточности, которые вы можете сделать.

> **Примечание:** Измените значение метки для поля `date_of_death` (**/catalog/models.py**) на "`died`" и перезапустите тесты.

Тот же подход применяется к тестированию других моделей. Самостоятельно создайте свои собственные тесты для оставшихся моделей.

[Назад к Django](#django)

### Формы

Смысл проведения тестов для форм тот же, что и для моделей; надо проверить весь собственный код и другие особенности проекта, но не то, что касается фреймворка, или сторонних библиотек.

В основном это означает, что вы должны протестировать то, что формы имеют соответствующие поля и что они показываются с соответствующими метками и вспомогательными текстами. Вам не надо проверять то, что Django правильно осуществляет валидацию полей (если только вы не создали своё собственное поле и валидацию) — то есть вам не надо проверять что, например, поле ввода электронного адреса принимает только электронного адреса. Но вы должны протестировать каждую дополнительную валидацию, которую вы добавляете для полей и любые сообщения, который ваш код генерирует в случае ошибок.

Рассмотрим форму для обновления книг. Она имеет только одно поле обновления даты, которое будет иметь текстовую метку и вспомогательный текст, который вам надо проверить.
```py
class RenewBookForm(forms.Form):
    """
    Форма обновления книг для библиотекарей
    """
    renewal_date = forms.DateField(help_text="Enter a date between now and 4 weeks (default 3).")

    def clean_renewal_date(self):
        data = self.cleaned_data['renewal_date']

        #Проверка, что дата не в прошлом.
        if data < datetime.date.today():
            raise ValidationError(_('Invalid date - renewal in past'))
        #Если дата в "далёком" будущем (+4 недели)
        if data > datetime.date.today() + datetime.timedelta(weeks=4):
            raise ValidationError(_('Invalid date - renewal more than 4 weeks ahead'))

        # Всегда надо возвращать очищенные данные.
        return data
```

Откройте файл **/catalog/tests/test_forms.py** и замените весь существующий в нем код, следующим кодом теста для формы `RenewBookForm`. Мы начали его с импорта нашей формы и некоторых библиотек Python и Django, которые помогут нам провести тесты. Затем, тем же способом как мы делали для моделей, объявляем тестовый класс нашей формы, то есть применяя описательное имя класс наследника `TestCase`.
```py
from django.test import TestCase

# Создайте ваши тесты здесь

import datetime
from django.utils import timezone
from catalog.forms import RenewBookForm

class RenewBookFormTest(TestCase):

    def test_renew_form_date_field_label(self):
        form = RenewBookForm()
        self.assertTrue(form.fields['renewal_date'].label == None or form.fields['renewal_date'].label == 'renewal date')

    def test_renew_form_date_field_help_text(self):
        form = RenewBookForm()
        self.assertEqual(form.fields['renewal_date'].help_text,'Enter a date between now and 4 weeks (default 3).')

    def test_renew_form_date_in_past(self):
        date = datetime.date.today() - datetime.timedelta(days=1)
        form_data = {'renewal_date': date}
        form = RenewBookForm(data=form_data)
        self.assertFalse(form.is_valid())

    def test_renew_form_date_too_far_in_future(self):
        date = datetime.date.today() + datetime.timedelta(weeks=4) + datetime.timedelta(days=1)
        form_data = {'renewal_date': date}
        form = RenewBookForm(data=form_data)
        self.assertFalse(form.is_valid())

    def test_renew_form_date_today(self):
        date = datetime.date.today()
        form_data = {'renewal_date': date}
        form = RenewBookForm(data=form_data)
        self.assertTrue(form.is_valid())

    def test_renew_form_date_max(self):
        date = timezone.now() + datetime.timedelta(weeks=4)
        form_data = {'renewal_date': date}
        form = RenewBookForm(data=form_data)
        self.assertTrue(form.is_valid())
```

Первые две функции проверяют текст который должны содержать поля `label` и `help_text`. Доступ к полю мы получаем при помощи словаря (то есть, `form.fields['renewal_date']`). Отметим, что мы должны проверять содержит ли метка значение `None`, иначе в поле текста метки вы увидите "`None`".

Оставшиеся функции проверяют валидность дат, то есть их нахождение внутри определённого интервала, а также невалидность для значений, которые находятся вне заданного интервала. Для получения исходного значения мы использовали функцию получения текущей даты (`datetime.date.today()`), а также функцию `datetime.timedelta()` (которая принимает определённое число дней, или недель). Затем мы просто создали форму, передавая ей наши данные и проверяя её на валидность.

> **Примечание:** В данном примере мы не использовали ни базу данных, ни тестовый клиент. Рассмотрите модификацию этих тестов при помощи класса [SimpleTestCase](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#django.test.SimpleTestCase).
> 
> Нам также надо бы проверять возникновение ошибок, которые появляются если форма не валидна. Но, обычно, это относится к процессу вывода информации, таким образом, мы позаботимся об этом в следующем разделе.

На этом с формами можно закончить; у нас имеются и другие тесты, но они были созданы обобщёнными классами отображения для редактирования! Запустите тесты и убедитесь, что наш код все ещё им соответствует!

[Назад к Django](#django)

### Отображения

Для проверки поведения отображения мы используем тестовый клиент Django [Client](https://docs.djangoproject.com/en/1.10/topics/testing/tools/#django.test.Client). Данный класс действует как упрощённый веб-браузер который мы применяем для имитации `GET` и `POST` запросов и проверки ответов. Про ответы мы можем узнать почти все, начиная с низкоуровневого HTTP (итоговые заголовки и коды статусов) и вплоть до применяемых шаблонов, которые используются для HTML-рендера, а также контекста, который передаётся в соответствующий шаблон. Кроме того, мы можем отследить последовательность перенаправлений (если имеются), проверить URL-адреса и коды статусов на каждом шаге. Все это позволит нам проверить, что каждое отображение выполняет то, что ожидается.

Давайте начнём с одного из простейших отображений которое возвращает список всех авторов. Вы можете его увидеть по URL-адресу **/catalog/authors/** (данный URL-адрес можно найти в разделе приложения catalog, в файле настроек **urls.py** по имени 'authors').
```py
class AuthorListView(generic.ListView):
    model = Author
    paginate_by = 10
```

Поскольку это обобщённое отображение списка, то почти все за нас делает Django. Если вы доверяете Django, то единственной вещью, которую вам нужно протестировать, является переход к данному отображению по указанному URL-адресу. Таким образом, если вы применяете методику TDD (test-driven development, разработка через тесты), то начните проект с написания тестов, которые будут проверять, что данное отображение выводит всех авторов и, к тому же, например, блоками по 10.

Откройте файл **/catalog/tests/test_views.py** замените все его содержимое на следующий код теста для класса `AuthorListView`. Как и ранее, мы импортируем нашу модель и некоторые полезные классы. В методе `setUpTestData()` мы задаём число объектов класса `Author` которые мы тестируем при постраничном выводе.
```py
from django.test import TestCase

# Create your tests here.

from catalog.models import Author
from django.urls import reverse

class AuthorListViewTest(TestCase):

    @classmethod
    def setUpTestData(cls):
        #Create 13 authors for pagination tests
        number_of_authors = 13
        for author_num in range(number_of_authors):
            Author.objects.create(first_name='Christian %s' % author_num, last_name = 'Surname %s' % author_num,)

    def test_view_url_exists_at_desired_location(self):
        resp = self.client.get('/catalog/authors/')
        self.assertEqual(resp.status_code, 200)

    def test_view_url_accessible_by_name(self):
        resp = self.client.get(reverse('authors'))
        self.assertEqual(resp.status_code, 200)

    def test_view_uses_correct_template(self):
        resp = self.client.get(reverse('authors'))
        self.assertEqual(resp.status_code, 200)

        self.assertTemplateUsed(resp, 'catalog/author_list.html')

    def test_pagination_is_ten(self):
        resp = self.client.get(reverse('authors'))
        self.assertEqual(resp.status_code, 200)
        self.assertTrue('is_paginated' in resp.context)
        self.assertTrue(resp.context['is_paginated'] == True)
        self.assertTrue( len(resp.context['author_list']) == 10)

    def test_lists_all_authors(self):
        #Get second page and confirm it has (exactly) remaining 3 items
        resp = self.client.get(reverse('authors')+'?page=2')
        self.assertEqual(resp.status_code, 200)
        self.assertTrue('is_paginated' in resp.context)
        self.assertTrue(resp.context['is_paginated'] == True)
        self.assertTrue( len(resp.context['author_list']) == 3)
```

Все тесты используют клиент (принадлежащего классу `TestCase`, от которого мы наследовались) для имитации `GET`-запроса и получения ответа (`resp`). Первая версия проверяет заданный URL-адрес (заметьте, - просто определённый путь без указания домена), в то время как второй генерирует URL-адрес при помощи его имени, указанного в настройках.
```py
resp = self.client.get('/catalog/authors/')
resp = self.client.get(reverse('authors'))
```

Когда мы получаем ответ, то мы извлекаем код статуса, используемый шаблон, "включён" ли постраничный вывод, количество элементов в подмножестве (на странице) и общее число элементов.

Наиболее интересной переменной является `resp.context`, которая является объектом контекста, который передаётся шаблону из отображения. Он (объект контекста) очень полезен для тестов, поскольку позволяет нам убедиться, что наш шаблон получает все данные которые ему необходимы. Другими словами мы можем проверить, что мы используем правильный шаблон с данными, которые проделывают долгий путь проверок чтобы соответствовать данному шаблону.

[Назад к Django](#django)

### Отображения и регистрация пользователей

В некоторых случаях вам нужно провести тесты отображений к которым имеют доступ только зарегистрированные пользователи. Например, `LoanedBooksByUserListView` очень похоже на наше предыдущее отображение, но доступно только для залогинившихся пользователей и показывает только те записи (`BookInstance`), которые соответствуют текущему пользователю, имеют статус 'on loan' (книга взята домой), а также забронированы.
```py
from django.contrib.auth.mixins import LoginRequiredMixin

class LoanedBooksByUserListView(LoginRequiredMixin,generic.ListView):
    """
    Обобщённый класс отображения списка взятых книг текущим пользователем
    """
    model = BookInstance
    template_name ='catalog/bookinstance_list_borrowed_user.html'
    paginate_by = 10

    def get_queryset(self):
        return BookInstance.objects.filter(borrower=self.request.user).filter(status__exact='o').order_by('due_back')
```

Добавьте тестовый код следующего фрагмента в **/catalog/tests/test_views.py**. В нем, для создания нескольких аккаунтов и объектов `BookInstance` которые будут использоваться в дальнейших тестах, мы используем метод `SetUp()` (вместе с соответствующими книгами и другими записями). Половина книг бронируется тестовыми пользователями, но в начале для них всех мы устанавливаем статус "доступно". Использование метода `SetUp()` предпочтительнее чем `setUpTestData()`, поскольку в дальнейшем мы будем модифицировать некоторые объекты.

> **Примечание:** Метод `setUp()` создаёт книгу с заданным языком `Language`, но *ваш* код может не включать в себя модель `Language`, поскольку это было *домашним заданием*. В таком случае просто закомментируйте соответствующие строки. Поступите также и в следующем разделе, посвящённом `RenewBookInstancesViewTest`.

```python
import datetime
from django.utils import timezone

from catalog.models import BookInstance, Book, Genre, Language
from django.contrib.auth.models import User # Необходимо для представления User как borrower

class LoanedBookInstancesByUserListViewTest(TestCase):

    def setUp(self):
        # Создание двух пользователей
        test_user1 = User.objects.create_user(username='testuser1', password='12345')
        test_user1.save()
        test_user2 = User.objects.create_user(username='testuser2', password='12345')
        test_user2.save()

        # Создание книги
        test_author = Author.objects.create(first_name='John', last_name='Smith')
        test_genre = Genre.objects.create(name='Fantasy')
        test_language = Language.objects.create(name='English')
        test_book = Book.objects.create(title='Book Title', summary = 'My book summary', isbn='ABCDEFG', author=test_author, language=test_language)
        # Create genre as a post-step
        genre_objects_for_book = Genre.objects.all()
        test_book.genre.set(genre_objects_for_book) # Присвоение типов many-to-many напрямую недопустимо
        test_book.save()

        # Создание 30 объектов BookInstance
        number_of_book_copies = 30
        for book_copy in range(number_of_book_copies):
            return_date= timezone.now() + datetime.timedelta(days=book_copy%5)
            if book_copy % 2:
                the_borrower=test_user1
            else:
                the_borrower=test_user2
            status='m'
            BookInstance.objects.create(book=test_book,imprint='Unlikely Imprint, 2016', due_back=return_date, borrower=the_borrower, status=status)

    def test_redirect_if_not_logged_in(self):
        resp = self.client.get(reverse('my-borrowed'))
        self.assertRedirects(resp, '/accounts/login/?next=/catalog/mybooks/')

    def test_logged_in_uses_correct_template(self):
        login = self.client.login(username='testuser1', password='12345')
        resp = self.client.get(reverse('my-borrowed'))

        # Проверка что пользователь залогинился
        self.assertEqual(str(resp.context['user']), 'testuser1')
        # Проверка ответа на запрос
        self.assertEqual(resp.status_code, 200)

        # Проверка того, что мы используем правильный шаблон
        self.assertTemplateUsed(resp, 'catalog/bookinstance_list_borrowed_user.html')
```

Если пользователь не залогирован то, чтобы убедиться в том что отображение перейдёт на страницу входа (логирования), мы используем метод `assertRedirects`, что продемонстрировано в методе `test_redirect_if_not_logged_in()`. Затем мы осуществляем вход для пользователя и проверяем что полученный статус `status_code` равен 200 (успешно).

Остальные тесты проверяют, соответственно, что наше отображение показывает только те книги которые взяты текущим пользователем. Скопируйте код, показанный ниже, в нижнюю часть предыдущего класса.
```py
    def test_only_borrowed_books_in_list(self):
        login = self.client.login(username='testuser1', password='12345')
        resp = self.client.get(reverse('my-borrowed'))

        #Проверка, что пользователь залогинился
        self.assertEqual(str(resp.context['user']), 'testuser1')
        #Check that we got a response "success"
        self.assertEqual(resp.status_code, 200)

        #Проверка, что изначально у нас нет книг в списке
        self.assertTrue('bookinstance_list' in resp.context)
        self.assertEqual( len(resp.context['bookinstance_list']),0)

        #Теперь все книги "взяты на прокат"
        get_ten_books = BookInstance.objects.all()[:10]

        for copy in get_ten_books:
            copy.status='o'
            copy.save()

        #Проверка, что все забронированные книги в списке
        resp = self.client.get(reverse('my-borrowed'))
        #Проверка, что пользователь залогинился
        self.assertEqual(str(resp.context['user']), 'testuser1')
        #Проверка успешности ответа
        self.assertEqual(resp.status_code, 200)

        self.assertTrue('bookinstance_list' in resp.context)

        #Подтверждение, что все книги принадлежат testuser1 и взяты "на прокат"
        for bookitem in resp.context['bookinstance_list']:
            self.assertEqual(resp.context['user'], bookitem.borrower)
            self.assertEqual('o', bookitem.status)

    def test_pages_ordered_by_due_date(self):

        #Изменение статуса на "в прокате"
        for copy in BookInstance.objects.all():
            copy.status='o'
            copy.save()

        login = self.client.login(username='testuser1', password='12345')
        resp = self.client.get(reverse('my-borrowed'))

        #Пользователь залогинился
        self.assertEqual(str(resp.context['user']), 'testuser1')
        #Check that we got a response "success"
        self.assertEqual(resp.status_code, 200)

        #Подтверждение, что из всего списка показывается только 10 экземпляров
        self.assertEqual( len(resp.context['bookinstance_list']),10)

        last_date=0
        for copy in resp.context['bookinstance_list']:
            if last_date==0:
                last_date=copy.due_back
            else:
                self.assertTrue(last_date <= copy.due_back)
```

Если хотите, то вы, безусловно, можете добавить тесты проверяющие постраничный вывод!

[Назад к Django](#django)

### Тестирование форм и отображений

Процесс тестирования отображений с формами немного более сложен, чем в представленных ранее случаях, поскольку вам надо протестировать большее количество кода: начальное состояние показа формы, показ формы и её данных в случае ошибок, а также показ формы в случае успеха. Хорошей новостью является то, что мы применяем клиент для тестирования практически тем же способом, как мы делали это в случае отображений, которые отвечают только за вывод информации.

В качестве демонстрации давайте напишем некоторые тесты для отображения, которые отвечают за обновление книг (`renew_book_librarian()`):
```py
from .forms import RenewBookForm

@permission_required('catalog.can_mark_returned')
def renew_book_librarian(request, pk):
    """
    Функция отображения обновления экземпляра BookInstance библиотекарем
    """
    book_inst=get_object_or_404(BookInstance, pk = pk)

    # Если это POST-запрос, тогда обработать данные формы
    if request.method == 'POST':

        # Создать объект формы и заполнить её данными из запроса (связывание/биндинг):
        form = RenewBookForm(request.POST)

        # Проверка валидности формы:
        if form.is_valid():
            # process the data in form.cleaned_data as required (here we just write it to the model due_back field)
            book_inst.due_back = form.cleaned_data['renewal_date']
            book_inst.save()

            # переход по URL-адресу:
            return HttpResponseRedirect(reverse('all-borrowed') )

    # Если это GET-запрос (или что-то ещё), то создаём форму по умолчанию
    else:
        proposed_renewal_date = datetime.date.today() + datetime.timedelta(weeks=3)
        form = RenewBookForm(initial={'renewal_date': proposed_renewal_date,})

    return render(request, 'catalog/book_renew_librarian.html', {'form': form, 'bookinst':book_inst})
```

Нам надо проверить что к данному отображению имеют доступ только те пользователи, которые имеют разрешение типа `can_mark_returned`, а кроме того, что пользователи перенаправляются на страницу ошибки HTTP 404 если они пытаются обновить экземпляр книги `BookInstance`, который не существует. Мы должны проверить что начальное значение формы соответствует дате через 3 недели в будущем, а также то, что если форма прошла валидацию, то мы переходим на страницу отображения книг "all-borrowed" (забронированных). Для тестов, отвечающих за проверку "провалов", мы также должны удостовериться что они отправляют соответствующие сообщения об ошибках.

В нижнюю часть файла **/catalog/tests/test_views.py** добавьте класс тестирования (показан во фрагменте, ниже). Он создаёт двух пользователей и два экземпляра книги, но только один пользователь получает необходимый доступ к соответствующему отображению. Код, который "присваивает" соответствующий доступ, выделен в коде жирным:
```py
from django.contrib.auth.models import Permission # Required to grant the permission needed to set a book as returned.

class RenewBookInstancesViewTest(TestCase):

    def setUp(self):
        #Создание пользователя
        test_user1 = User.objects.create_user(username='testuser1', password='12345')
        test_user1.save()

        test_user2 = User.objects.create_user(username='testuser2', password='12345')
        test_user2.save()
        permission = Permission.objects.get(name='Set book as returned')
        test_user2.user_permissions.add(permission)
        test_user2.save()

        #Создание книги
        test_author = Author.objects.create(first_name='John', last_name='Smith')
        test_genre = Genre.objects.create(name='Fantasy')
        test_language = Language.objects.create(name='English')
        test_book = Book.objects.create(title='Book Title', summary = 'My book summary', isbn='ABCDEFG', author=test_author, language=test_language,)
        #Создание жанра Create genre as a post-step
        genre_objects_for_book = Genre.objects.all()
        test_book.genre=genre_objects_for_book
        test_book.save()

        #Создание объекта BookInstance для для пользователя test_user1
        return_date= datetime.date.today() + datetime.timedelta(days=5)
        self.test_bookinstance1=BookInstance.objects.create(book=test_book,imprint='Unlikely Imprint, 2016', due_back=return_date, borrower=test_user1, status='o')

        #Создание объекта BookInstance для для пользователя test_user2
        return_date= datetime.date.today() + datetime.timedelta(days=5)
        self.test_bookinstance2=BookInstance.objects.create(book=test_book,imprint='Unlikely Imprint, 2016', due_back=return_date, borrower=test_user2, status='o')
```

В нижнюю часть класса тестирования добавьте следующие методы (из следующего фрагмента). Они проверяют, что только пользователь с соответствующим доступом (*testuser2*) имеет доступ к отображению. Мы проверяем все случаи: когда пользователь не залогинился, когда залогинился, но не имеет соответствующего доступа, когда имеет доступ, но не является заёмщиком книги (тест должен быть успешным), а также, что произойдёт если попытаться получить доступ к книге `BookInstance` которой не существует. Кроме того, мы проверяем то, что используется правильный (необходимый) шаблон.
```py
    def test_redirect_if_not_logged_in(self):
        resp = self.client.get(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}) )
        #Manually check redirect (Can't use assertRedirect, because the redirect URL is unpredictable)
        self.assertEqual( resp.status_code,302)
        self.assertTrue( resp.url.startswith('/accounts/login/') )

    def test_redirect_if_logged_in_but_not_correct_permission(self):
        login = self.client.login(username='testuser1', password='12345')
        resp = self.client.get(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}) )

        #Manually check redirect (Can't use assertRedirect, because the redirect URL is unpredictable)
        self.assertEqual( resp.status_code,302)
        self.assertTrue( resp.url.startswith('/accounts/login/') )

    def test_logged_in_with_permission_borrowed_book(self):
        login = self.client.login(username='testuser2', password='12345')
        resp = self.client.get(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance2.pk,}) )

        #Check that it lets us login - this is our book and we have the right permissions.
        self.assertEqual( resp.status_code,200)

    def test_logged_in_with_permission_another_users_borrowed_book(self):
        login = self.client.login(username='testuser2', password='12345')
        resp = self.client.get(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}) )

        #Check that it lets us login. We're a librarian, so we can view any users book
        self.assertEqual( resp.status_code,200)

    def test_HTTP404_for_invalid_book_if_logged_in(self):
        import uuid
        test_uid = uuid.uuid4() #unlikely UID to match our bookinstance!
        login = self.client.login(username='testuser2', password='12345')
        resp = self.client.get(reverse('renew-book-librarian', kwargs={'pk':test_uid,}) )
        self.assertEqual( resp.status_code,404)

    def test_uses_correct_template(self):
        login = self.client.login(username='testuser2', password='12345')
        resp = self.client.get(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}) )
        self.assertEqual( resp.status_code,200)

        #Check we used correct template
        self.assertTemplateUsed(resp, 'catalog/book_renew_librarian.html')
```

Добавьте ещё один тестовый метод, показанный ниже. Он проверяет что начальная дата равна трём неделям в будущем. Заметьте, что мы имеем возможность получить доступ к начальному значению из поля формы (выделено жирным).
```py
    def test_form_renewal_date_initially_has_date_three_weeks_in_future(self):
        login = self.client.login(username='testuser2', password='12345')
        resp = self.client.get(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}) )
        self.assertEqual( resp.status_code,200)

        date_3_weeks_in_future = datetime.date.today() + datetime.timedelta(weeks=3)
        self.assertEqual(resp.context['form'].initial['renewal_date'], date_3_weeks_in_future )
```

Следующий тест (тоже добавьте его в свой класс) проверяет что отображение, в случае успеха, перенаправляет пользователя к списку всех забронированных книг. Здесь мы показываем как при помощи клиента вы можете создать и передать данные в `POST`-запросе. Данный запрос передаётся вторым аргументом в пост-функцию и представляет из себя словарь пар ключ/значение.
```py
    def test_redirects_to_all_borrowed_book_list_on_success(self):
        login = self.client.login(username='testuser2', password='12345')
        valid_date_in_future = datetime.date.today() + datetime.timedelta(weeks=2)
        resp = self.client.post(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}), {'renewal_date':valid_date_in_future} )
        self.assertRedirects(resp, reverse('all-borrowed') )
```

> **Предупреждение:** Вместо перехода к отображению all-borrowed, добавленного в качестве домашнего задания, вы можете перенаправить пользователя на домашнюю страницу '/'. В таком случае, исправьте две последние строки тестового кода на код, показанный ниже. Присваивание `follow=True`, в запросе, гарантирует что запрос вернёт окончательный URL-адрес пункта назначения (следовательно проверяется `/catalog/`, а не `/`).
> ```python
>  resp = self.client.post(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}), {'renewal_date':valid_date_in_future},follow=True )
>  self.assertRedirects(resp, '/catalog/')
> ```

Скопируйте две последние функции в класс, представленные ниже. Они тоже проверяют `POST`-запросы, но для случая неверных дат. Мы используем функцию `assertFormError()`, чтобы проверить сообщения об ошибках.

```py
    def test_form_invalid_renewal_date_past(self):
        login = self.client.login(username='testuser2', password='12345')
        date_in_past = datetime.date.today() - datetime.timedelta(weeks=1)
        resp = self.client.post(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}), {'renewal_date':date_in_past} )
        self.assertEqual( resp.status_code,200)
        self.assertFormError(resp, 'form', 'renewal_date', 'Invalid date - renewal in past')

    def test_form_invalid_renewal_date_future(self):
        login = self.client.login(username='testuser2', password='12345')
        invalid_date_in_future = datetime.date.today() + datetime.timedelta(weeks=5)
        resp = self.client.post(reverse('renew-book-librarian', kwargs={'pk':self.test_bookinstance1.pk,}), {'renewal_date':invalid_date_in_future} )
        self.assertEqual( resp.status_code,200)
        self.assertFormError(resp, 'form', 'renewal_date', 'Invalid date - renewal more than 4 weeks ahead')
```

Такие же способы тестирования могут применяться для проверок других отображений.

[Назад к Django](#django)

### Шаблоны

Django предоставляет API для тестирования, которое проверяет что функции отображения вызывают правильные шаблоны, а также позволяют убедиться, что им передаётся соответствующая информация. Кроме того, в Django имеется возможность использовать сторонние API для проверок того, что ваш HTML показывает то, что надо.

### Другие рекомендованные инструменты для тестирования

Django фреймворк для тестирования помогает вам создавать эффективные юнит- и интеграционные тесты — мы рассмотрели только небольшую часть того, что может делать фреймворк **unittest** и совсем не упоминали дополнения Django (например, посмотрите на модуль [unittest.mock](https://docs.python.org/3.5/library/unittest.mock-examples.html), который подключает сторонние библиотеки тестирования).

Из всего множества сторонних инструментов тестирования, мы кратко опишем возможности двух:

- [Coverage](http://coverage.readthedocs.io/en/latest/): это инструмент Python, который формирует отчёты о том, какое количество кода выполняется во время проведения тестов. Это полезно для уточнения степени "покрытия" кода тестами.
- [Selenium](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Testing/Your_own_automation_environment): это фреймворк проведения автоматического тестирования в настоящем браузере. Он позволяет вам имитировать взаимодействие пользователя с вашим сайтом (что является следующим шагом в проведении интеграционных тестов).

[Назад к Django](#django)

### Домашняя работы

Существуют другие модели и отображения, которые мы могли бы протестировать. В качестве простого упражнения, попробуйте создать тестовый вариант для отображения `AuthorCreate`.
```py
class AuthorCreate(PermissionRequiredMixin, CreateView):
    model = Author
    fields = '__all__'
    initial={'date_of_death':'12/10/2016',}
    permission_required = 'catalog.can_mark_returned'
```

**Помните**, вам надо проверить все, что касается вашего кода, или структуры. Это включает в себя: кто имеет доступ к отображению, начальную дату, применяемый шаблон, а также перенаправление из отображения в случае успеха.

### Итоги

Написание тестов не является ни весельем, ни развлечением и, соответственно, при создании сайтов часто остаётся напоследок (или вообще не используется). Но тем не менее, они являются действенным механизмом, который позволяет вам убедиться, что ваш код в находится безопасности, даже если в него добавляются какие-либо изменения. Кроме того, тесты повышают эффективность поддержки вашего кода.

В данном руководстве мы продемонстрировали вам принципы написания тестов для ваших моделей, форм и отображений. Мы кратко перечислили что именно необходимо тестировать, что обычно сложно выявить в самом начале разработки. Существует много аспектов которые необходимо изучить, но даже с тем что мы уже узнали, вы имеете возможность создавать эффективные юнит-тесты для значительного улучшения процесса разработки.

Следующая и последняя часть руководства покажет вам как запустить ваш чудесный (и полностью протестированный!) веб-сайт Django.

- **Смотрите также**
- [Написание и запуск тестов](https://docs.djangoproject.com/en/1.10/topics/testing/overview/) (Django docs)
- [Написание вашего первого приложения Django, часть 5 > Введение в автоматическое тестирование](https://docs.djangoproject.com/en/1.10/intro/tutorial05/) (Django docs)
- [Инструменты для тестирования](https://docs.djangoproject.com/en/1.10/topics/testing/tools/) (Django docs)
- [Продвинутое тестирование](https://docs.djangoproject.com/en/1.10/topics/testing/advanced/) (Django docs)
- [Путеводитель по тестированию в Django](http://toastdriven.com/blog/2011/apr/10/guide-to-testing-in-django/) (Toast Driven Blog, 2011)
- [Мастерская: Разработка через тесты с Django (TDD)](http://test-driven-django-development.readthedocs.io/en/latest/index.html) (San Diego Python, 2014)
- [Тестирование в Django (Часть 1) - Лучшие практики и Примеры](https://realpython.com/blog/python/testing-in-django-part-1-best-practices-and-examples/) (RealPython, 2013)

[Назад к Django](#django)

## Django 11: разворачивание сайта на сервере

Теперь, когда вы создали (и протестировали) свой шикарный сайт [LocalLibrary](#django-сайт-местной-библиотеки), у вас скорее всего, есть желание разместить его на публичном веб-сервере, чтобы он стал доступен через интернет персоналу и посетителям библиотеки. Данная статья даёт общее представление о том, каким образом подойти к поиску хостинга для размещения сайта, а также, что нужно сделать чтобы подготовить свой сайт к публикации.

| Требования: | Завершить изучение всех предыдущих частей руководства, включая [Django Руководство часть 10: Тестирование веб-приложений в Django](#django-10-тестрование-приложений-django).
|---|---
| Цель: | Изучить, где и как вы можете развернуть приложение Django для публичного доступа.

Обзор

Даже когда разработка вашего сайта завершена (или "достаточно" завершена для начала публичного тестирования), то для публичного доступа вам надо его где-то разместить.

До сего момента вы работали в каком-то рабочем окружении - чтобы получать отладочную и другую частную информацию, вы использовали веб-сервер Django в локальной сети при этом запускали сайт с (небезопасными) настройками разработки. Перед тем как разместить сайт публично, вы должны сделать следующее:

- Сделать несколько изменений в настройках проекта.
- Выбрать/Настроить окружение для хостинга приложения Django.
- Выбрать/Настроить окружение для размещения статических файлов.
- В целях обслуживания сайта настроить инфраструктуру для его развёртывания.

Данное руководство предоставляет небольшой обзор выбора хостинга, приготовления сайта к публичному размещению, а также практический пример установки сайта [LocalLibrary](#django-сайт-местной-библиотеки) на облачный сервис [Heroku](https://www.heroku.com/).

### Что такое окружение развёртывания?

Окружение развёртывания - это среда, которую предоставляет сервер, на котором вы будете размещать свой веб-сайт для публичного запуска и доступа. Данное окружение включает в себя:

- Железо на котором будет запускаться сайт.
- Операционную систему (Linux, Windows).
- Языки программирования времени выполнения (скриптовые) и библиотеки, которые использует ваш сайт.
- Веб-сервер, используемый для обслуживания страниц и другого контента (Nginx, Apache).
- Сервер приложений, который передаёт "динамические" запросы между сайтом Django и веб-сервером.
- Базу данных, от которой зависит ваш сайт.

> **Примечание:** У вас может быть потребность в обратном прокси, балансировщике загрузки и так далее.

Сервер может быть вашим собственным с подключением к интернету по скоростному каналу, но более общим подходом является применение "облачных решений". Что действительно имеет значение, так это то, что ваш код запускается на некотором удалённом компьютере (возможно и "виртуальном"), в хостинговом дата-центре. Удалённый сервер обычно предоставляет определённый доступ к компьютерным ресурсам (процессору, оперативной памяти, памяти на жёстких носителях и так далее) и соединение с интернетом за некоторую цену.

Такой тип удалённого доступа к вычислительному/сетевому железу называется *Инфраструктура как Сервис* (*Infrastructure as a Service* - **IaaS**). Множество IaaS поставщиков предлагают услуги по предустановке какой-либо операционной системы, на которую вы можете установить необходимые для вашего рабочего окружения компоненты. Другие поставщики предлагают вам выбрать уже готовые полноценные рабочие окружения, возможно, включающие в себя Django и настроенный веб-сервер.

> **Примечание:** Готовые окружения могут сделать настройку вашего веб-сайта очень простой задачей, поскольку они имеют минимальную конфигурацию, однако, либо количество доступных опций может быть недостаточным, или они будут соответствовать устаревшей операционной системе. Часто, более предпочтительно установить необходимые компоненты самостоятельно, таким образом вы получите то, что вам необходимо, а в последующем, при обновлении системы, уже будете знать что нужно делать!

Некоторые провайдеры поддерживают Django как часть своего предложения *Платформа как Сервис* (*Platform as a Service* - **PaaS**). При данном виде хостинга вам не нужно беспокоиться о большей части окружения (веб-сервере, сервере приложений, балансировщике загрузки), так как сама платформа берёт это на себя (включая все моменты, касающиеся роста и развития вашего приложения). В данном случае развёртывание приложения является достаточно простой задачей, - вам нужно сконцентрироваться только на вашем приложении, а не на инфраструктуре.

Некоторые разработчики выбирают более гибкое решение, предоставляемое IaaS, в то время как другие предпочитают иметь наименьшие накладные расходы и простое масштабирование, предоставляемое PaaS. Когда вы только начинаете, то система типа PaaS является предпочтительной и это именно то, что мы будем использовать в данном руководстве.

> **Примечание:** Если вы выбираете хостинг с поддержкой Python/Django, то он должен иметь инструкцию по установке веб-сайта Django, учитывающую различные конфигурации веб-сервера, сервера приложений, обратного прокси и так далее (это не имеет значение, если вы выбрали PaaS). Например, существует множество инструкций "шаг-за-шагом" для различный конфигураций в [Документации DigitalOcean по Django](https://www.digitalocean.com/community/tutorials?q=django).

### Выбор хостинг провайдера

Существует более 100 хорошо известных хостинг провайдеров, которые либо активно поддерживают, или работают с Django (их список можно увидеть в [Django-дружественные хостинги](https://djangofriendly.com/index.html)). Данные поставщики предоставляют различные типы окружений (IaaS, PaaS), и различные уровни доступа к вычислительным и сетевым ресурсам, за разную цену.

Некоторые вещи на которые надо обратить внимание при выборе хостинга:

- Насколько требовательным к вычислительным ресурсам является ваш сайт.
- Уровень поддержки горизонтального (добавление большего количества машин) и вертикального масштабирования (переход на более мощное железо), а также стоимость всего этого.
- Где расположены дата-центры и, следовательно, откуда будет более быстрый доступ.
- Время непрерывной работы хостинга, а также время и количество простоя.
- Инструменты, которые предоставляются для управления сайтом — простота и безопасность их использования (SFTP и FTP).
- Встроенные фреймворки для мониторинга вашего сервера.
- Ограничения. Некоторые хостинги могут блокировать некоторые сервисы (например, электронную почту) . Другие предлагают только определённое количество часов "живого времени" за определённую цену, или небольшое количество места для данных.
- Преимущества. Некоторые провайдеры могут предложить бесплатные доменные имена и поддержку сертификатов SSL, которые, в других случаях, должны были бы купить.
- Что будет при истечении времени использования "бесплатного" хостинга, какова "стоимость" миграции на более "дорогие" тарифы и так далее?

Хорошей новостью является то, что для того, чтобы начать существует достаточное количество компаний, которые предоставляют пробные "бесплатные" тарифы типа "evaluation" (для пробы), "developer" (разработка), или "hobbyist" (хобби). Всегда существуют ресурсы с ограниченным окружением, при использовании которых вам надо беспокоиться лишь о том, что они могут быть доступны лишь в течении определённого периода времени. Тем не менее, они являются отличным решением для тестирования сайтов с небольшим трафиком в реальном окружении, а также могут предоставлять простой доступ к платным ресурсам, в случае необходимости. Наиболее популярными провайдерами являются [Heroku](https://www.heroku.com/), [Python Anywhere](https://www.pythonanywhere.com/), [Amazon Web Services](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/billing-free-tier.html), [Microsoft Azure](https://azure.microsoft.com/en-us/pricing/details/app-service/) и так далее.

Многие провайдеры имеют "basic" (базовый) тариф, предоставляющий достаточный уровень вычислительной мощности с небольшим количеством ограничений. [Digital Ocean](https://www.digitalocean.com/) и [Python Anywhere](https://www.pythonanywhere.com/) являются примерами провайдеров, которые предлагают относительно недорогой базовый тариф (от $5 до $10USD в месяц).

> **Примечание:** Необходимо помнить, что цена не является единственным критерием выбора. Если ваш сайт успешен, то может так случиться, что масштабирование станет самым важным элементом вашего внимания при выборе услуг хостинга.

### Подготовка веб-сайта к публикации

[Скелет сайта](#django-2-создание-скелета) был создан при помощи инструментов *django-admin* и *manage.py*, которые настроены таким образом, чтобы сделать разработку проще. Многие настройки файла проекта (определённых в **settings.py**) должны быть изменены перед публикацией сайта, либо из-за вопросов безопасности, либо производительности.

> **Примечание:** Общепринятым решением является иметь отдельный файл **settings.py** для публикации, который импортирует важные настройки из внешних файлов, или из переменных окружения. Доступ к данному файлу должен быть ограничен, даже если остальная часть исходного кода доступна в публичном репозитории.

- **Критически важные настройки файла settings.py:**

- `DEBUG`. При развёртывании сайта должен быть установлен в `False` (`DEBUG = False`). Тем самым, прекратится вывод важной отладочной информации.
- `SECRET_KEY`. Это большое случайное число, применяемое для защиты от CSRF. Важно, чтобы ключ, используемый в продакшене, не указывался в исходном коде, и/или не запрашивался с другого сервера. Django рекомендует размещать значение ключа либо в переменной окружения, или в файле с доступом только на чтение.
```bash
# Чтение SECRET_KEY из переменной окружения
import os
SECRET_KEY = os.environ['SECRET_KEY']

#ИЛИ

#Чтение ключа из файла
with open('/etc/secret_key.txt') as f:
    SECRET_KEY = f.read().strip()
```

Давайте изменим приложение [LocalLibrary](#django-сайт-местной-библиотеки) таким образом, чтобы читать `SECRET_KEY` и `DEBUG` из переменных окружения, если те определены, иначе использовать значения по умолчанию.

Откройте **/locallibrary/settings.py**, закомментируйте исходное значение `SECRET_KEY` и добавьте новые строки, как указано ниже. В течении разработки, никаких переменных окружения определено не было, таким образом будут использоваться значения по умолчанию (не имеет значения какой ключ вы используете в процессе разработки, поскольку при развёртывании проекта вы будете использовать другой).
```py
# SECURITY WARNING: keep the secret key used in production secret!
# SECRET_KEY = 'cg#p$g+j9tax!#a3cup@1$8obt2_+&k3q+pmu)5%asj6yjpkag'
import os
SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY', 'cg#p$g+j9tax!#a3cup@1$8obt2_+&k3q+pmu)5%asj6yjpkag')
```

Затем закомментируйте строку с настройкой `DEBUG`, а затем, добавьте новую, указанную ниже.
```py
# SECURITY WARNING: don't run with debug turned on in production!
# DEBUG = True
DEBUG = bool( os.environ.get('DJANGO_DEBUG', True) )
```

Значение `DEBUG` будет `True` по умолчанию и станет `False`, в том случае, если переменная окружения `DJANGO_DEBUG` будет проинициализирована пустой строкой, то есть, `DJANGO_DEBUG=''`.

> **Примечание:** Было бы более понятным, если бы мы могли просто установить и снять с `DJANGO_DEBUG` непосредственно на `True` и `False` , напрямую, а не использовать «любую строку» или «пустую строку» (соответственно). К сожалению, значения переменных среды хранятся как строки Python и единственная строка, которая оценивается как `False` является пустой строкой (например, `bool('')==False`).

Весь перечень настроек для разворачивания вашего сайта находится по ссылке [Deployment checklist](https://docs.djangoproject.com/en/1.10/howto/deployment/checklist/) (Django docs). Кроме того, вы можете получить список настроек, выполнив в терминале команду:
```py
python3 manage.py check --deploy
```

### Пример: Установка LocalLibrary на Heroku

Данный раздел предоставляет демонстрацию того, как установить [LocalLibrary](#django-сайт-местной-библиотеки) на [Heroku PaaS cloud](http://heroku.com/).

### Почему Heroku?

**Heroku** - один из самых продолжительных и популярных облачных сервисов PaaS. Первоначально он поддерживал только приложения Ruby, но теперь его можно использовать для размещения приложений из многих сред программирования, включая Django!

Мы выбираем для использования Heroku по нескольким причинам:

- У Heroku есть [свободный уровень](https://www.heroku.com/pricing), который *действительно* свободен (хотя и с некоторыми ограничениями)
- Как PaaS, Heroku заботится о большой веб-инфраструктуре для нас. Это значительно облегчает работу, потому что вы не беспокоитесь о серверах, балансирах нагрузки, обратных прокси или любой другой веб-инфраструктуре, которую Heroku предоставляет нам под капотом.

- Хотя у этого есть некоторые ограничения, это не повлияет на это конкретное приложение. Например:

  - Heroku предоставляет только недолговечное хранилище, поэтому загруженные пользователем файлы нельзя безопасно хранить на самом Heroku.
  - Свободный уровень будет спать с неактивным веб-приложением, если в течение получаса не будет запросов.После этого сайт может занять несколько секунд, чтобы ответить, когда он проснулся.
  - Свободный уровень ограничивает время, в течение которого ваш сайт работает до определённого количества часов каждый месяц (не включая время, когда сайт «спит»).Это нормально для сайта с низким уровнем использования / демонстрации, но не подходит, если требуется 100% время безотказной работы.
  - Другие ограничения перечислены в [Limits](https://devcenter.heroku.com/articles/limits) (документы Heroku).

- В основном это просто работает, и если вы в конечном итоге полюбите его, масштабирование вашего приложения будет очень простым.

Хотя Heroku идеально подходит для проведения этой демонстрации, она может быть не идеальна для вашего реального сайта. Heroku упрощает настройку и масштабирование за счёт меньшей гибкости и, возможно, обойдётся намного дороже, когда вы выходите из свободного уровня.

### Как работает Heroku?

Heroku запускает сайты Django внутри одного, или более, изолированных друг от друга ["Dynos"](https://devcenter.heroku.com/articles/dynos), которые являются виртуальными Unix-контейнерами, предоставляющими необходимое окружение для вашего приложения. Данные dynos полностью изолированы и имеют *эфемерную* файловую систему ("короткоживущая" файловая система, которая полностью очищается и обновляется каждый раз, когда dyno перезапускается). Единственной сущностью, которую предоставляет dynos по умолчанию, является приложение по [конфигурации переменных](https://devcenter.heroku.com/articles/config-vars). Heroku внутри себя применяет балансировщик загрузки для распределения веб-трафика среди всех "веб"-dynos. Поскольку dynos изолированы, Heroku может масштабировать приложение горизонтально, просто добавляя больше dynos (хотя, конечно, у вас может появиться необходимость расширить базу данных для обработки дополнительных соединений).

Файловая система эфемерна, поэтому вы не можете напрямую установить необходимые для вашего приложения сервисы (то есть, базы данных, очереди, системы кеширования, хранения, сервисы электронной почты и так далее). Взамен этого, Heroku предоставляет сервисы, доступные как независимые "дополнения" ("add-ons") либо от самой Heroku, или от сторонних разработчиков. В тот момент когда ваше приложение запускается в системе, dynos получает доступ к сервисам, используя информацию, содержащуюся в переменных настройки вашего приложения.

Для того, чтобы выполнить ваше приложение Heroku необходимо иметь возможность установить соответствующее окружение и зависимости, а также понимать как его (приложение) запустить. В случае приложений Django мы предоставляем соответствующую информацию в нескольких текстовых файлах:

- **runtime.txt**: язык программирования и его версию.
- **requirements.txt**: необходимые для Python компоненты, включая Django.
- **Procfile**: Список процессов, которые будут выполнены для старта веб-приложения. Для Django это обычно сервер веб-приложений Gunicorn (скрипт `.wsgi`).
- **wsgi.py**: конфигурация [WSGI](http://wsgi.readthedocs.io/en/latest/what.html) для вызова нашего приложения Django в окружении Heroku.

Разработчики Developers взаимодействуют с Heroku при помощи специального клиентского приложения/терминала, который сильно похож на **bash-скрипт Unix**. Оно позволяет вам загружать код, находящийся в **git-репозитории**, контроллировать выполняемые процессы, смотреть логи, устанавливать конфигурационные переменные и многое другое!

Для того, чтобы заставить ваше приложение работать с Heroku, нам нужно разместить наше веб-приложение в git-репозитории, добавить, перечисленные ранее, файлы, подключить дополнение (add-on) базы данных и выполнить настройки для правильной работы со статическими файлами.

Когда мы выполним все, что необходимо для нашего сайта мы можем создать аккаунт Heroku, получить доступ к клиенту Heroku и использовать его, для установки нашего веб-сайта.

> **Примечание:** Инструкции, перечисленные ниже, соответствуют процессу работы с Heroku во время написания данной статьи (английской версии - прим. перев.). Если Heroku значительно изменит этот процесс, вы можете воспользоваться соответствующим описанием: [Heroku начало работы с Django](https://devcenter.heroku.com/articles/getting-started-with-python#introduction).

На этом завершается краткий обзор начала работы с Heroku (более подробное руководство [Как работает Heroku](https://devcenter.heroku.com/articles/how-heroku-works)).

### Создание репозитория приложения на Github

Heroku тесно интегрирована с системой управления версиями исходного кода **git**, используя её для загрузки / синхронизации любых изменений, которые вы вносите в живую систему. Он делает это, добавляя новый «удалённый» репозиторий heroku с именем heroku, указывающий на репозиторий для вашего источника в облаке Heroku. Во время разработки вы используете **git** для хранения изменений в вашем «master» репозитории. Когда вы хотите развернуть свой сайт, вы синхронизируете свои изменения в репозитории Heroku.

> **Примечание:** Если вы привыкли следовать хорошей практике разработки программного обеспечения, вы, вероятно, уже используете **git** или какую-либо другую систему **SCM** (*Source Code Management*). Если у вас уже есть git-репозиторий, вы можете пропустить этот шаг.

Существует множество способов работы с git, но одним из самых простых является создание учётной записи в [Github](https://github.com/), создание репозитория там, а затем синхронизация с ним локально:

1. Посетите https://github.com/ и создайте аккаунт.
2. После входа в систему нажмите ссылку в верхней панели инструментов и выберите **Новый репозиторий**.
3. Заполните все поля на этой форме. Хотя они не являются обязательными, они настоятельно рекомендуются.

    - Введите имя нового репозитория (например *django_local_library*), и комментарий к репозиторию (например "Local Library website written in Django".
    - Нажмите на кнопку **Add .gitignore** и в появившемся списке выберите **Python**.
    - Выберите подходящую вам лицензию из списка **Add license**. Если не знаете для чего это - оставьте как было.
    - Установите галочку напротив ***Initialize this repository with a README***.

4. Нажмите кнопку **Create repository**, тем самым создав ваш репозиторий.
5. Перейдите на страницу вашего репозитория. Там нажмите на зелёную кнопку **Clone or download**. Скопируйте URL из текстового поля из появившегося диалогового окна (Это будет похоже на: `https://github.com/<your_git_user_id>/django_local_library.git`). Здесь `<your_git_user_id>` - это будет ваш **id** пользователя **git**.

Когда ваш репозиторий будет создан - загрузите его себе на компьютер, следуя инструкции, описанной ниже:

1. Установите **git** себе на компьютер (Вы можете найти версию для своей платформы [здесь](https://git-scm.com/downloads)).
2. Откройте командную строку (или терминал) и выполните в нём следующую команду, используя ссылку, которую вы получили с **github**:
```bash
git clone https://github.com/<your_git_user_id>/django_local_library.git
```

Это создаст подпапку (с содержанием вашего репозитория и именем вашего репозитория) внутри папки, в которой выполнялась команда.

3. Перейдите в эту папку:
```bash
cd django_local_library.git
```

Последний шаг. Нужно скопировать ваше Django-приложение и добавить его файлы в новый репозиторий, используя **git**:

1. Скопируйте ваше приложение в папку репозитория (все файлы с таким же уровнем, как у **manage.py**, **БЕЗ** папки проекта, в которой эти файлы находятся).
2. Откройте файл с расширением **.gitignore** в текстовом редакторе, вставьте в самый его конец строки, приведённые ниже, а затем сохраните (этот файл "говорит" о файлах, которые не должны быть загружены в git по умолчанию).
```bash
# Text backup files
*.bak

#Database
*.sqlite3
```

3. Откройте командную строку или терминал и используйте `add` команду с флагом `-A`. Эта команда сохранит изменения в репозиторий:
```bash
git add -A
```

4. Используйте команду `status`, что бы убедиться, что все файлы, которые вы собираетесь добавить верны (вы хотите включить исходные файлы, а не бинарные файлы, временные файлы и т. д.). В консоль выведется что то вроде этого:
```bash
> git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   .gitignore
        new file:   catalog/__init__.py
        ...
        new file:   catalog/migrations/0001_initial.py
        ...
        new file:   templates/registration/password_reset_form.html
```

5. Теперь, зафиксируйте файлы в локальном репозитории:
```bash
git commit -m "First version of application moved into github"
```

6. Синхронизируете свой локальный репозиторий с сайтом Github:
```bash
git push origin master
```

Когда эти операции завершатся, вернитесь на страницу Github где вы создали свой репозиторий, обновите страницу, и убедитесь, что ваше приложение полностью загружено. При надобности обновить файлы на репозитории - повторите цикл ввода команд **add/commit/push**.

> **Примечание:** Это хороший момент для создания резервной копии вашего «ванильного» проекта — в то время как некоторые изменения, которые мы собираемся сделать в следующих разделах, могут быть полезны для развёртывания на любой платформе (или разработке), которые другие могут не использовать.
>
> *Лучший* способ сделать это - использовать *git* для управления вашими изменениями. С *git* вы можете не только вернуться к определённой старой версии, но и сохранить её в отдельной «ветке» ваших производственных изменений, and cherry-pick - выбрать любые изменения для перемещения между ветвями производства и развития. [Изучение Git](https://help.github.com/articles/good-resources-for-learning-git-and-github/) будет стоить усилий, но это выходит за рамки данной темы. Самый простой способ сделать это - просто скопировать файлы в другое место. Используйте тот подход, который наилучшим образом соответствует вашим знаниям git!

### Обновить приложение для Heroku

В этой части говорится об изменениях, которые мы должны сделать на нашем приложении [LocalLibrary](#django-сайт-местной-библиотеки), что бы оно работало на Heroku. В то время как документация ["начало работы с Heroku с инструкциями Django"](https://devcenter.heroku.com/articles/getting-started-with-python) предполагает, что вы будете использовать [Heroku client](https://devcenter.heroku.com/articles/getting-started-with-python#set-up) для запуска локальной среды разработки, наши изменения здесь совместимы с существующим сервером разработки Django и способами работы, которые мы уже узнали.

- **Procfile**

Создайте файл с именем `Procfile` (без расширения) в корне нашего GitHub репозитории объявить типы процессов и точки входа приложения. Скопируйте в него следующий текст:
```bash
web: gunicorn locallibrary.wsgi --log-file -
```

«`web:`» сообщает Heroku, что это веб динамический и может быть отправлен HTTP-трафик. Процесс, который начнётся в этом динамически, - это **gunicorn**, который является популярным сервером веб-приложений, который рекомендует Heroku. Мы запускаем **Gunicorn**, используя конфигурационную информацию в модуле **locallibrary.wsgi** (созданный с помощью нашего скелета приложения: **/locallibrary/wsgi.py**).

- **Gunicorn**

[Gunicorn](http://gunicorn.org/) рекомендуемый http сервер с Django на Heroku (Как указано в Procfile выше). Это чистый python http сервер для WSGI приложений которые могут запускать множество параллельных python процессов в пределах одного динамического (посмотрите [Deploying Python applications with Gunicorn](https://devcenter.heroku.com/articles/python-gunicorn) для получения большей информации).

Также нам не понадобится **Gunicorn** для обслуживания нашей [LocalLibrary](#django-сайт-местной-библиотеки) приложения в течение разработки, мы установим это так, чтобы он стал частью наших требований к Heroku для настройки на удалённом сервере.

Установка **Gunicorn** локально в командной строке используя пакетный менеджер **pip** (которые мы установили когда [настраивали среду разработки](#setting-up-a-django-development-environment)):
```bash
pip3 install gunicorn
```

### Настройка Базы Данных

Мы не можем использовать базу данных SQLite по умолчанию на Heroku, потому что она основана на файлах, и она будет удалена из эфемерной файловой системы каждый раз, когда приложение перезагружается (обычно один раз в день и каждый раз, когда изменяется приложение или его переменные конфигурации).

Механизм Heroku для обработки этой ситуации заключается в использовании [надстройки базы данных](https://elements.heroku.com/addons#data-stores) и настройке веб-приложения с использованием информации из [переменной конфигурации среды](https://devcenter.heroku.com/articles/config-vars), установленной надстройкой. Существует множество опций базы данных, но мы будем использовать [hobby уровень](https://devcenter.heroku.com/articles/heroku-postgres-plans#plan-tiers) в базе данных *postgres Heroku*, поскольку это бесплатно, поддерживается Django и автоматически добавляется в наши новые приложения Heroku при использовании бесплатного уровня динамического плана для хобби.

Информация о подключении базы данных предоставляется на web dyno, используя конфигурационную переменную с именем `DATABASE_URL`. Вместо того, чтобы жёстко кодировать эту информацию в Django, Heroku рекомендует разработчикам использовать [dj-database-url](https://warehouse.python.org/project/dj-database-url/) пакет для анализа `DATABASE_URL` переменную окружения и автоматически преобразовать её в желаемый формат конфигурации Django. В дополнение к установке пакета *dj-database-url* нам также потребуется установить [psycopg2](http://initd.org/psycopg/), поскольку Django нуждается в этом, чтобы взаимодействовать с базами данных Postgres.

- **dj-database-url** (Django конфигурации базы данных из переменной окружения)

Установите dj-database-url локально, чтобы он стал частью наших требований к настройке Heroku на удалённом сервере:
```bash
pip3 install dj-database-url
```

- **settings.py**

Откройте **/locallibrary/settings.py** и скопируйте следующую конфигурацию в нижнюю часть файла:
```bash
# Heroku: Update database configuration from $DATABASE_URL.
import dj_database_url
db_from_env = dj_database_url.config(conn_max_age=500)
DATABASES['default'].update(db_from_env)
```

> **Примечание:**
> 
> - Мы все ещё будем использовать SQLite во время разработки, поскольку `DATABASE_URL` переменная среды не будет установлена на нашем компьютере разработки.
> - Значение `conn_max_age=500` делает соединение постоянным, что намного эффективнее, чем воссоздавать соединение в каждом цикле запросов. Однако это необязательно и при необходимости можно удалить.

- **psycopg2** (Python Postgres database support)

**Django** нуждается в **psycopg2** для работы с базами данных **Postgres**, и вам нужно будет добавить это в файл требований txt для Heroku, чтобы установить это на удалённом сервере (как описано в разделе требований ниже).

Django будет использовать нашу базу данных `SQLite` локально по умолчанию, поскольку переменная среды `DATABASE_URL` не задана в нашей локальной среде. Если вы хотите полностью перейти на Postgres и использовать нашу бесплатную базу данных Heroku для разработки и производства, то вы можете. Например, чтобы установить `psycopg2` и его зависимости локально в системе на базе Linux, вы должны использовать следующие команды bash / terminal:
```bash
sudo apt-get install python-pip python-dev libpq-dev postgresql postgresql-contrib
pip3 install psycopg2
```

Инструкции по установке для других платформ можно найти на веб-сайте psycopg2.

Однако вам не нужно это делать - вам не нужно, чтобы PostGreSQL был активным на локальном компьютере, если вы передаёте его в Heroku в качестве требования в файле требований.txt (см. ниже).

### Обслуживание статических файлов в производстве

Во время разработки мы использовали Django и веб-сервер разработки Django для обслуживания наших статических файлов (CSS, JavaScript и т. Д.). В производственной среде вместо этого мы обычно обслуживаем статические файлы из сети доставки контента (CDN) или веб-сервера.

> **Примечание:** Обслуживание статических файлов через Django / веб-приложение неэффективно, потому что запросы должны проходить через ненужный дополнительный код (Django), а не обрабатываться непосредственно веб-сервером или полностью отдельным CDN. Хотя это не имеет значения для местного использования во время разработки, это будет иметь значительное влияние на производительность, если мы будем использовать тот же подход в производстве.

Чтобы упростить размещение статических файлов отдельно от веб-приложения Django, Django предоставляет средство сбора данных для сбора этих файлов для развёртывания (имеется переменная параметров, определяющая, где файлы должны собираться при запуске **collectstatic**). Шаблоны Django относятся к месту размещения статических файлов относительно переменной параметров (`STATIC_URL`), так что это можно изменить, если статические файлы перемещаются на другой хост / сервер.

Соответствующими параметрами настройки являются:

- `STATIC_URL`: это базовое расположение URL, из которого будут загружены статические файлы, например, на CDN. Это используется для переменной статического шаблона, доступ к которой осуществляется в нашем базовом шаблоне (см. [Учебник по Django Part 5: Создание нашей домашней страницы](#django-5-cоздание-домашней-страницы)). 
- `STATIC_ROOT`: Это абсолютный путь к каталогу, в котором инструмент **«collectstatic»** Django будет собирать любые статические файлы, упомянутые в наших шаблонах. После их сбора они затем могут быть загружены в группу, где бы файлы не размещались. 
- `STATICFILES_DIRS`: В этом списке перечислены дополнительные каталоги, в которых инструмент коллективного поиска Django должен искать статические файлы.

### settings.py

Откройте **/locallibrary/settings.py** и скопируйте следующую конфигурацию в нижнюю часть файла. `BASE_DIR` уже должен быть определён в вашем файле (`STATIC_URL`, возможно, уже был определён в файле, когда он был создан. В то время как это не причинит вреда, вы также можете удалить дублируемую предыдущую ссылку).
```bash
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.10/howto/static-files/

# The absolute path to the directory where collectstatic will collect static files for deployment.
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# The URL to use when referring to static files (where they will be served from)
STATIC_URL = '/static/'
```

Фактически мы будем делать файл, используя библиотеку **WhiteNoise**, которую мы устанавливаем и настраиваем в следующем разделе.

Для получения дополнительной информации см. [Django и Static Assets](https://devcenter.heroku.com/articles/django-assets) (документы Heroku).

### WhiteNoise

Существует множество способов обслуживания статических файлов на производстве (мы видели соответствующие настройки Django в предыдущих разделах). Heroku рекомендует использовать проект WhiteNoise для обслуживания статических активов непосредственно из Gunicorn в производстве.

> **Примечание:** Heroku автоматически вызывает collectstatic и готовит ваши статические файлы для использования WhiteNoise после того, как он загрузит ваше приложение. Посмотрите [WhiteNoise](https://warehouse.python.org/project/whitenoise/) документацию для объяснения того, как она работает, и почему реализация является относительно эффективным методом для обслуживания этих файлов.

Шаги по настройке *WhiteNoise* для использования в проекте:

- **Установка WhiteNoise**

Установите *WhiteNoise* локально, используя следующую команду:
```bash
pip3 install whitenoise
```

- **settings.py**

Чтобы установить *WhiteNoise* в приложение Django, откройте **/locallibrary/settings.py**, найдите параметр `MIDDLEWARE` и добавьте `WhiteNoiseMiddleware` в верхней части списка, чуть ниже `SecurityMiddleware`:
```bash
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

При желании вы можете уменьшить размер статических файлов при их обслуживании (это более эффективно). Просто добавьте следующее в конец /**locallibrary/settings.py**:
```bash
# Simplified static file serving.
# https://warehouse.python.org/project/whitenoise/
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
```

- **Requirements**

Требования Python вашего веб-приложения должны храниться в файле **requirements.txt** в корневом каталоге вашего репозитория. После этого Heroku автоматически установит их при восстановлении вашей среды. Вы можете создать этот файл с помощью pip в командной строке (запустите в корне repo):
```bash
pip3 freeze > requirements.txt
```

После установки всех разных зависимостей выше, файл **requirements.txt** должен иметь по меньшей мере эти перечисленные элементы (хотя номера версий могут отличаться). Удалите любые другие зависимости, не перечисленные ниже, если вы явно не добавили их для этого приложения.
```bash
dj-database-url==0.4.1
Django==1.10.2
gunicorn==19.6.0
psycopg2==2.6.2
whitenoise==3.2.2
```

> **Примечание:** Убедитесь, что строка **psycopg2**, подобная приведённой выше, присутствует! Даже если вы не установили это локально, вы должны добавить это в **requirements.txt**.

- **Среда выполнения**

Файл **runtime.txt**, если определён, говорит Heroku, какой язык программирования использовать. Создайте файл в корне репо и добавьте следующий текст:
```bash
python-3.5.2
```

> **Примечание:** Heroku поддерживает только небольшое количество [Python runtimes](https://devcenter.heroku.com/articles/python-support#supported-python-runtimes). (на момент написания статьи, в том числе и выше). Heroku будет использовать поддерживаемую среду выполнения независимо от значения, указанного в этом файле.

- **Сохраните изменения в Github и перепроверьте**

Далее мы сохраним все наши изменения в Github. В терминале (whist внутри нашего репозитория) введите следующие команды:
```py
git add -A
git commit -m "Added files and changes required for deployment to heroku"
git push origin master
```

Прежде чем продолжить, дайте возможность проверить сайт снова локально и убедиться, что это не повлияло ни на одно из наших изменений выше. Запустите веб-сервер разработки как обычно, а затем проверьте, работает ли сайт, как вы ожидаете в своём браузере.
```bash
python3 manage.py runserver
```

Теперь мы должны быть готовы начать развёртывание [LocalLibrary](#django-сайт-местной-библиотеки) на Heroku.

### Получить аккаунт в heroku

Чтобы начать использовать Heroku, вам сначала нужно создать учётную запись:

- Перейдите [www.heroku.com](https://www.heroku.com/) и нажмите **SIGN UP FOR FREE** кнопку.
- Введите ваши данные, а затем нажмите **CREATE FREE ACCOUNT**. Вам будет предложено проверить свою учётную запись по адресу электронной почты для регистрации.
- Нажмите ссылку активации учётной записи в электронной почте для регистрации. Вы вернётесь в свою учётную запись в веб-браузере.
- Введите свой пароль и нажмите **SET PASSWORD AND LOGIN**.
- Затем вы войдёте в систему и попадёте в приборную панель Heroku: https://dashboard.heroku.com/apps.

### Установка клиента

Загрузите и установите клиент Heroku, следуя [инструкциям Heroku](https://devcenter.heroku.com/articles/getting-started-with-python#set-up) здесь.

После установки клиента вам будут доступны команды. Например, чтобы получить справку о клиенте:
```bash
heroku help
```

### Создание и загрузка веб-сайта

Чтобы создать приложение, мы запускаем команду «create» в корневом каталоге нашего репозитория. Это создаёт git remote («указатель на удалённый репозиторий»), названный heroku в нашей локальной среде git.
```bash
heroku create
```

> **Примечание:** Вы можете назвать удалённый, если хотите, указав значение после «create». Если вы этого не сделаете, вы получите случайное имя. Имя используется в URL-адресе по умолчанию.

Затем мы можем подтолкнуть (push) наше приложение в репозиторий heroku как показано ниже. Это позволит загрузить приложение, упаковать его в dyno, запустить collectstatic, и запустить сам сайт.
```bash
git push heroku master
```

Если нам повезёт, приложение «заработает» на сайте, но оно не будет работать должным образом, потому что мы не настроили таблицы базы данных для использования нашим приложением. Для этого нам нужно использовать команду `heroku run` и запустить "[one off dyno](https://devcenter.heroku.com/articles/deploying-python#one-off-dynos)" для выполнения операции переноса. Введите в терминал следующую команду:
```bash
heroku run python manage.py migrate
```

Мы также должны будем иметь возможность добавлять книги и авторов, поэтому давайте также создадим суперпользователя, снова используя одноразовый динамический режим:
```bash
heroku run python manage.py createsuperuser
```

Как только это будет завершено, мы можем посмотреть сайт. Он должен работать, хотя в нем ещё нет книг. Чтобы открыть браузер на новом веб-сайте, используйте команду:
```bash
heroku open
```

Создайте несколько книг на сайте администратора и проверьте, работает ли сайт, как вы ожидаете.

### Управление аддонами

Вы можете проверить дополнения в своём приложении, используя `heroku addons` команду. Это будет список всех аддонов, их ценовая категория и состояние.
```bash
>heroku addons

Add-on                                     Plan       Price  State
─────────────────────────────────────────  ─────────  ─────  ───────
heroku-postgresql (postgresql-flat-26536)  hobby-dev  free   created
 └─ as DATABASE
```

Здесь мы видим, что у нас есть только одна надстройка, база данных postgres SQL. Это бесплатно и автоматически создаётся при создании приложения. Вы можете открыть веб-страницу, чтобы более подробно изучить надстройку базы данных (или любое другое дополнение), используя следующую команду:
```bash
heroku addons:open heroku-postgresql
```

Другие команды позволяют создавать, уничтожать, обновлять и понижать аддоны (используя аналогичный синтаксис для открытия). Для получения дополнительной информации см. [Managing Add-ons](https://devcenter.heroku.com/articles/managing-add-ons) (Heroku docs).

### Настройка переменных конфигурации

Вы можете проверить конфигурационные переменные для сайта, используя команду `heroku config`. Ниже вы можете видеть, что у нас есть только одна переменная `DATABASE_URL` , используемая для настройки нашей базы данных.
```bash
>heroku config

=== locallibrary Config Vars
DATABASE_URL: postgres://uzfnbcyxidzgrl:j2jkUFDF6OGGqxkgg7Hk3ilbZI@ec2-54-243-201-144.compute-1.amazonaws.com:5432/dbftm4qgh3kda3
```

Если вы вспомните из раздела, посвящённого [разворачиванию сайта на сервере](#django-11-разворачивание-сайта-на-сервере), мы должны установить переменные среды для `DJANGO_SECRET_KEY` и `DJANGO_DEBUG`. Давайте сделаем это сейчас.

> **Примечание:** Секретный ключ должен быть действительно секретным! Один из способов генерации нового ключа - создать новый проект Django (`django-admin startproject someprojectname`) а затем получить ключ, который генерируется для вас в его **settings.py**.

Мы устанавливаем `DJANGO_SECRET_KEY` используя команду `config:set` (как показано ниже). Не забудьте использовать свой секретный ключ!
```bash
>heroku config:set DJANGO_SECRET_KEY=eu09(ilk6@4sfdofb=b_2ht@vad*$ehh9-)3u_83+y%(+phh&=

Setting DJANGO_SECRET_KEY and restarting locallibrary... done, v7
DJANGO_SECRET_KEY: eu09(ilk6@4sfdofb=b_2ht@vad*$ehh9-)3u_83+y%(+phh
```

Аналогично мы устанавливаем `DJANGO_DEBUG`:
```bash
Copy to Clipboard
>heroku config:set DJANGO_DEBUG=''

Setting DJANGO_DEBUG and restarting locallibrary... done, v8
```

Если вы посетите веб-сайт сейчас, вы получите ошибку "Bad request" , потому что в [ALLOWED_HOSTS](https://docs.djangoproject.com/en/1.10/ref/settings/#allowed-hosts) надо внести параметры, если у вас `DEBUG=False` (в качестве меры безопасности). Откройте **/locallibrary/settings.py** и измените `ALLOWED_HOSTS` для включения вашего базового URL-адреса приложения (например, '**locallibrary1234.herokuapp.com**') URL, который вы обычно используете на локальном сервере разработки.
```python
ALLOWED_HOSTS = ['<your app URL without the https:// prefix>.herokuapp.com','127.0.0.1']
# For example:
# ALLOWED_HOSTS = ['fathomless-scrubland-30645.herokuapp.com','127.0.0.1']
```

Затем сохраните настройки и передайте их в репозиторий Github и в Heroku:
```bash
git add -A
git commit -m 'Update ALLOWED_HOSTS with site and development server URL'
git push origin master
git push heroku master
```

> **Примечание:** После завершения обновления сайта на Heroku введите URL-адрес, который не существует (например, **/catalog/doesnotexist/**). Раньше это отображало бы подробную страницу отладки, но теперь вы должны просто увидеть простую страницу *«Не найдено»*.

### Отладка

Клиент Heroku предоставляет несколько инструментов для отладки:
```bash
heroku logs  # Show current logs
heroku logs --tail # Show current logs and keep updating with any new results
heroku config:set DEBUG_COLLECTSTATIC=1 # Add additional logging for collectstatic (this tool is run automatically during a build)
heroku ps   #Display dyno status
```

Если вам нужно больше информации, предоставленной здесь, вам нужно будет начать изучать [Django Logging](https://docs.djangoproject.com/en/1.10/topics/logging/).

### Итоги

Это конец этого руководства по настройке и развёртывании приложений Django, а также серия руководств по работе с Django. Надеемся, вы нашли их полезными. Вы можете проверить полностью проработанную версию по исходникам на Github. Следующий шаг - прочитать наши последние несколько статей, а затем завершить оценочную задачу.

**Смотрите также**
- [Развёртывание Django](https://docs.djangoproject.com/en/1.10/howto/deployment/) (Django docs)
  - [Контрольный список развёртывания](https://docs.djangoproject.com/en/1.10/howto/deployment/checklist/) (Django docs)
  - [Развёртывание статических файлов](https://docs.djangoproject.com/en/1.10/howto/static-files/deployment/) (Django docs)
  - [Как развернуть с WSGI](https://docs.djangoproject.com/en/1.10/howto/deployment/wsgi/) (Django docs)
  - [Как использовать Django с Apache и mod_wsgi](https://docs.djangoproject.com/en/1.10/howto/deployment/wsgi/modwsgi/) (Django docs)
  - [Как использовать Django с Gunicorn](https://docs.djangoproject.com/en/1.10/howto/deployment/wsgi/gunicorn/) (Django docs)

- Heroku
  - [Настройка Django приложений для Heroku](https://devcenter.heroku.com/articles/django-app-configuration) (Heroku docs)
  - [Начало работы в Heroku с Django](https://devcenter.heroku.com/articles/getting-started-with-python#introduction) (Heroku docs)
  - [Django and Static Assets](https://devcenter.heroku.com/articles/django-assets) (Heroku docs)
  - [Параллелизм и подключение к базе данных в Django](https://devcenter.heroku.com/articles/python-concurrency-and-database-connections) (Heroku docs)
  - [Как Heroku работает](https://devcenter.heroku.com/articles/how-heroku-works) (Heroku docs)
  - [Dynos and the Dyno Manager](https://devcenter.heroku.com/articles/dynos) (Heroku docs)
  - [Настройка и Config Vars](https://devcenter.heroku.com/articles/config-vars) (Heroku docs)
  - [Ограничения](https://devcenter.heroku.com/articles/limits) (Heroku docs)
  - [Развёртывание Python applications с Gunicorn](https://devcenter.heroku.com/articles/python-gunicorn) (Heroku docs)
  - [Развёртывание Python и Django apps в Heroku](https://devcenter.heroku.com/articles/deploying-python) (Heroku docs)
  - [Ещё о Heroku](https://devcenter.heroku.com/search?q=django) Django docs

- Digital Ocean
  - [Как обслуживать Django Applications вместе с uWSGI и Nginx в Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-serve-django-applications-with-uwsgi-and-nginx-on-ubuntu-16-04)
  - [Другие документы Digital Ocean Django](https://www.digitalocean.com/community/tutorials?q=django)

### Безопасность веб-приложения Django

Защита пользовательских данных - важная часть проектирования любого веб-сайта.Ранее мы рассматривали некоторые наиболее распространённые угрозы безопасности в теме Веб безопасность. В данной статье будет представлена практическая демонстрация того, как встроенные механизмы защиты Django's обрабатывают подобные угрозы.

|Требования: | Прочитайте тему Веб безопасность. Завершите изучение предыдущих частей руководства до [Руководство часть 9: Работа с формами включительно](#django-9-работа-с-формами).
|----|----
|Цель: | Понять, что нужно делать (или наоборот не делать), для обеспечения безопасности вашего веб-приложения.


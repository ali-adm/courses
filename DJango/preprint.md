# Django 
[Источник](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Introduction)

- [Django](#django)
  - [Введение](#введение)
    - [Как выглядит код Django?](#как-выглядит-код-django)
    - [Отправка запроса в правильное view (urls.py)](#отправка-запроса-в-правильное-view-urlspy)
    - [Обработка запроса (views.py)](#обработка-запроса-viewspy)
    - [Определение данных модели (models.py)](#определение-данных-модели-modelspy)
    - [Запросы данных (views.py)](#запросы-данных-viewspy)
    - [Вывод данных (HTML-шаблоны)](#вывод-данных-html-шаблоны)
    - [Что ещё можно сделать?](#что-ещё-можно-сделать)
    - [Резюме](#резюме)
  - [Setting up a Django development environment](#setting-up-a-django-development-environment)
    - [Обзор среды разработки Django](#обзор-среды-разработки-django)
    - [Разновидности установки Django](#разновидности-установки-django)
    - [Установка Python 3](#установка-python-3)
    - [Использование Django внутри виртуальной среды Python](#использование-django-внутри-виртуальной-среды-python)
    - [Установка ПО виртуальной среды](#установка-по-виртуальной-среды)
    - [Создание и использование виртуальной среды](#создание-и-использование-виртуальной-среды)
    - [Установка Django, проверка установки](#установка-django-проверка-установки)
    - [Заключение](#заключение)
  - [Django: сайт местной библиотеки](#django-сайт-местной-библиотеки)
    - [Обзор руководства](#обзор-руководства)
    - [Сайт местной библиотеки](#сайт-местной-библиотеки)
  - [Django 2: создание скелета](#django-2-создание-скелета)
    - [Обзор](#обзор)
    - [Создание проекта](#создание-проекта)
    - [Создание приложения Каталог](#создание-приложения-каталог)
    - [Регистрация папки с приложением](#регистрация-папки-с-приложением)
    - [Настройка базы данных](#настройка-базы-данных)
    - [Другие настройки проекта](#другие-настройки-проекта)
    - [Подключение URL-адреса](#подключение-url-адреса)
    - [Тестирование работы скелета](#тестирование-работы-скелета)
    - [Запуск сайта](#запуск-сайта)
  - [Django 3: использование моделей](#django-3-использование-моделей)
    - [Обзор](#обзор-1)
    - [Проектирование моделей LocalLibrary](#проектирование-моделей-locallibrary)
    - [Модель для начинающих](#модель-для-начинающих)
    - [Определение модели](#определение-модели)
    - [Поля](#поля)
    - [Общие аргументы поля](#общие-аргументы-поля)
    - [Общие типы полей](#общие-типы-полей)
    - [Метаданные](#метаданные)
    - [Методы](#методы)
    - [Управление моделью](#управление-моделью)
    - [Определение моделей LocalLibrary](#определение-моделей-locallibrary)
    - [Модель жанра](#модель-жанра)
    - [Модель книги](#модель-книги)
    - [Модель BookInstance](#модель-bookinstance)
    - [Модель автора](#модель-автора)
    - [Повторно выполнить миграцию базы данных](#повторно-выполнить-миграцию-базы-данных)
    - [Языковая модель - вызов](#языковая-модель---вызов)
    - [Итог](#итог)
  - [Django 4: административная панель Django](#django-4-административная-панель-django)
    - [Обзор](#обзор-2)
    - [Регистрация моделей](#регистрация-моделей)
    - [Создание суперпользователя](#создание-суперпользователя)
    - [Вход в админ-панель и её использование](#вход-в-админ-панель-и-её-использование)
    - ["Продвинутая" конфигурация](#продвинутая-конфигурация)
    - [Регистрация класса ModelAdmin](#регистрация-класса-modeladmin)
    - [Настройка отображения списков](#настройка-отображения-списков)
    - [Добавление фильтров списка](#добавление-фильтров-списка)
    - [Формирование макета с подробным представлением](#формирование-макета-с-подробным-представлением)
    - [Управление отображаемыми и вложенными полями](#управление-отображаемыми-и-вложенными-полями)
    - [Разделение на секции/Выделение подробного представления](#разделение-на-секциивыделение-подробного-представления)
    - [Встроенное редактирование связанных записей](#встроенное-редактирование-связанных-записей)
    - [Проверьте себя](#проверьте-себя)
    - [Заключение](#заключение-1)

## Введение

**Django** — это высокоуровневый Python веб-фреймворк, который позволяет быстро создавать безопасные и поддерживаемые веб-сайты. Созданный опытными разработчиками, Django берёт на себя большую часть хлопот веб-разработки, поэтому вы можете сосредоточиться на написании своего веб-приложения без необходимости изобретать велосипед. Он бесплатный и с открытым исходным кодом, имеет растущее и активное сообщество, отличную документацию и множество вариантов как бесплатной, так и платной поддержки.

**Django** помогает писать программное обеспечение, которое будет:

- **Полным** (философия «Всё включено»)
- **Разносторонним** (создание любого типа сайтов, работа с любой клиентской средой, доставка контента в любом формате, может быть расширен сторонними компонентами)
- **Безопасным** (управление учётными записями, хэши паролей, защита от многих уязвимостей - SQL-инъекции, межсайтовый скриптинг, подделка межсайтовых запросов и кликджекинг)
- **Масштабируемым** (**"shared-nothing"** архитектура - чёткое разделение частей означает, что Django может масштабироваться при увеличении трафика, путём добавления оборудования на любом уровне: серверы кеширования, серверы баз данных или серверы приложений )
- **Удобным в сопровождении** (используется принцип **«Don't Repeat Yourself»** - **DRY**, «не повторяйся», группирует связанный код в модули шаблона MVC)
- **Переносным** (мультиплатформа)

**Django** «умеренно гибкий». Он предоставляет набор компонентов для обработки большинства задач веб-разработки и один (или два) предпочтительных способа их использования. Однако такая архитектура Django означает, что вы обычно можете выбирать из нескольких различных опций или при необходимости добавлять поддержку для совершенно новых.

[Назад к Django](#django)

### Как выглядит код Django?

На традиционном информационном веб-сайте веб-приложение ожидает HTTP-запросы от веб-браузера (или другого клиента). Когда запрос получен, приложение разрабатывает то, что необходимо на основе URL-адреса и, возможно, данных в POST или GET запросах. В зависимости от того, что требуется, далее он может читать или записывать информацию из базы данных или выполнять другие задачи, необходимые для удовлетворения запроса. Затем приложение вернёт ответ веб-браузеру, часто динамически создавая HTML-страницу для отображения в браузере, вставляя полученные данные в HTML-шаблон.

Веб-приложения, написанные на Django, обычно группируют код, который обрабатывает каждый из этих шагов, в отдельные файлы:

![Блок-схема работы Django](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Introduction/basic-django.png)

- **URLs:** Хотя можно обрабатывать запросы с каждого URL-адреса с помощью одной функции, гораздо удобнее писать отдельную функцию для обработки каждого ресурса. URL-маршрутизатор используется для перенаправления HTTP-запросов в соответствующее представление на основе URL-адреса запроса. Кроме того, URL-маршрутизатор может извлекать данные из URL-адреса в соответствии с заданным шаблоном и передавать их в соответствующую функцию отображения (view) в виде аргументов.
- **View:** View (англ. «отображение») — это функция обработчика запросов, которая получает HTTP-запросы и возвращает ответы. Функция view имеет доступ к данным, необходимым для удовлетворения запросов, и делегирует ответы в шаблоны через модели.
- **Models:** Модели представляют собой объекты Python, которые определяют структуру данных приложения и предоставляют механизмы для управления (добавления, изменения, удаления) и выполнения запросов в базу данных.
- **Templates:** Template (англ. «шаблон») — это текстовый файл, определяющий структуру или разметку страницы (например HTML-страницы), с полями для подстановки, которые используются для вывода актуального содержимого. View может динамически создавать HTML-страницы, используя HTML-шаблоны и заполняя их данными из модели (model). Шаблон может быть использован для определения структуры файлов любых типов, не обязательно HTML.

> **Примечание:** Django реализует уровневую архитектуру "Model View Template (MVT)". Она имеет много общего с более известной архитектурой Model View Controller.

[Назад к Django](#django)

### Отправка запроса в правильное view (urls.py)

Сопоставитель URL-адресов обычно содержится в файле **urls.py**. В примере ниже сопоставитель (`urlpatterns`) определяет список сопоставлений между *маршрутами* (определёнными URL-*шаблонами*) и соответствующими функциями отображения (view). Если получен HTTP-запрос, который имеет URL-адрес, соответствующий определённому шаблону, то затем будет вызвана связанная функция отображения (view) и передана в запрос.
```py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('book/<int:id>/', views.book_detail, name='book_detail'),
    path('catalog/', include('catalog.urls')),
    re_path(r'^([0-9]+)/$', views.best),
]
```

Объект `urlpatterns` является списком функций `path()` и/или `re_path()` (в Python списки определяются с помощью квадратных скобок, внутри которых элементы разделены запятыми и могут содержать [необязательную завершающую запятую](https://docs.python.org/2/faq/design.html#why-does-python-allow-commas-at-the-end-of-lists-and-tuples). Например: `[item1, item2, item3,]`).

Первый аргумент в обоих методах - маршрут (шаблон), который будет сопоставлен. В методе `path()` угловые скобки используются для определения частей URL-адреса, которые будут захвачены и переданы в функцию отображения (view) в качестве именованных аргументов. Функция `re_path()` использует гибкий подход к сопоставлению с шаблоном, известный как регулярное выражение. Мы поговорим об этом в следующей статье!

Второй аргумент — это ещё одна функция, которая будет вызываться при сопоставлении шаблона. Обозначение `views.book_detail` указывает, что функция называется `book_detail()` и может быть обнаружена в модуле с именем `views` (т.е. внутри файла с именем `views.py`).

[Назад к Django](#django)

### Обработка запроса (views.py)

Отображения (views) — это сердце веб-приложения, принимающего HTTP-запросы от веб-клиентов и возвращающего HTTP-ответы. Между этим они используют другие ресурсы фреймворка для доступа к базам данных, шаблонам визуализации и т. д.

В приведённом ниже примере показана минимальная функция представления `index()`, которая могла быть вызвана нашим сопоставителем URL-адресов в предыдущем разделе. Как и все функции отображения (view), она получает объект `HttpRequest` в качестве параметра (`request`) и возвращает объект `HttpResponse`. В этом случае мы ничего не делаем с запросом, и наш ответ просто возвращает жёстко запрограммированную строку. Мы покажем вам запрос, который делает что-то более интересное в следующем разделе.
```py
## filename: views.py (Django view functions)

from django.http import HttpResponse

def index(request):
    # Получить HttpRequest — параметр запроса
    # Выполнить операции, используя информацию из запроса.
    # Вернуть HttpResponse
    return HttpResponse('Hello from Django!')
```

> **Примечание:** Немного о Python:
> 
>[Модули Python](https://docs.python.org/3/tutorial/modules.html) это библиотеки функций, сохранённые в различных файлах, которые мы можем использовать в нашем коде. Здесь мы импортируем только объект `HttpResponse` из модуля `django.http` чтобы использовать его в нашем отображении (view): `from django.http import HttpResponse`. Также есть другие способы импортирования некоторых или всех объектов модуля.
>
>Функции объявляются с помощью ключевого слова `def`, как показано выше, с именованными параметрами, перечисленными в скобках после имени функции; строка завершается двоеточием. Заметьте, что следующие строки содержат отступы. Отступы важны, так как они определяют, какие строки кода находятся внутри конкретного блока (обязательные отступы — это ключевая особенность Python и одна из причин, почему код на Python так легко читать).

Отображения (view) обычно содержатся в файле **views.py**.

[Назад к Django](#django)

### Определение данных модели (models.py)

Веб-приложения Django обрабатывают и запрашивают данные через объекты Python, называемые моделями. Модели определяют структуру хранимых данных, включая типы полей и, возможно, их максимальный размер, значения по умолчанию, параметры списка выбора, текст справки для документации, текст меток для форм и т. д. Определение модели не зависит от используемой базы данных — ваши модели будут работать в любой из них. После того как вы выбрали базу данных, которую хотите использовать, вам не нужно напрямую обращаться к ней — вы просто пишете свою структуру модели и другой код, а Django выполняет всю «грязную работу» по обращению к базе данных за вас.

В приведённом ниже фрагменте кода показана очень простая модель Django для объекта `Team`. Класс `Team` наследуется от класса `models.Model`. Он определяет имя команды и командный уровень в качестве полей символов и задаёт максимальное количество символов, которые могут быть сохранены для каждой записи. `Team_level` может быть одним из нескольких значений, поэтому мы определяем его как поле выбора и предоставляем сопоставление между отображаемыми вариантами и хранимыми данными вместе со значением по умолчанию.
```py
# filename: models.py

from django.db import models

class Team(models.Model):
    team_name = models.CharField(max_length=40)

    TEAM_LEVELS = (
        ('U09', 'Under 09s'),
        ('U10', 'Under 10s'),
        ('U11', 'Under 11s'),
        ...  #список других командных уровней
    )
    team_level = models.CharField(max_length=3,choices=TEAM_LEVELS,default='U11')
```
> **Примечание:** Немного о Python:
> 
> Python поддерживает «объектно-ориентированное программирование», то есть стиль программирования, в котором мы организуем наш код в объекты, которые включают связанные данные и функции для работы с этими данными. Объекты также могут наследовать / расширять / выводить из других объектов, позволяя использовать одинаковое поведение между связанными объектами. В Python мы используем ключевое слово `class`, чтобы определить «скелет» для объекта. Мы можем создать несколько конкретных экземпляров типа объекта на основе модели в классе.
> 
> Так, например, мы имеем класс `Team`, который происходит от класса `Model`. Это означает, что эта модель будет содержать все методы модели, но мы также можем дать ей специализированные возможности. В нашей модели мы определяем поля нашей базы данных, в которой будем хранить данные, присваивая им конкретные имена. Django использует эти определения, включая имена полей, для создания основной базы данных.

[Назад к Django](#django)

### Запросы данных (views.py)

Модель Django предоставляет простой API запросов для поиска в базе данных. Поиск может осуществляться по нескольким полям одновременно, используя различные критерии (такие как exact («точный»), case-insensitive («без учёта регистра»), greater than («больше чем») и т. д.), и может поддерживать сложные выражения (например, вы можете указать поиск в командах U11, у которых есть имя команды, начинающееся с «Fr» или заканчивается на «al»).

Фрагмент кода показывает функцию view (обработчик ресурсов) для отображения всех команд U09. Выделенная жирным строка показывает, как мы можем использовать модель API-запросов для того, чтобы отфильтровать все записи, где поле `team_level` в точности содержит текст 'U09' (обратите внимание, как эти критерии передаются функции `filter()` в качестве аргумента с именем поля и типом соответствия, разделённым двойным подчёркиванием: **`team_level__exact`**).
```py
## filename: views.py

from django.shortcuts import render
from .models import Team

def index(request):
    list_teams = Team.objects.filter(team_level__exact="U09")
    context = {'youngest_teams': list_teams}
    return render(request, '/best/index.html', context)
```

Данная функция использует функцию `render()` для того, чтобы создать `HttpResponse`, который будет отправлен назад браузеру. Эта функция является *ярлыком*; она создаёт HTML-файл, комбинируя указанный HTML-шаблон и некоторые данные для вставки в шаблон (предоставляется в переменной с именем `«context»`). В следующем разделе мы покажем как данные вставляются в шаблон для создания HTML-кода.

[Назад к Django](#django)

### Вывод данных (HTML-шаблоны)

Системы шаблонов позволяют указать структуру выходного документа, используя заполнители для данных, которые будут вставлены при генерировании страницы. Шаблоны часто используются для создания HTML, но также могут создавать другие типы документов. Django «из коробки» поддерживает как собственную систему шаблонов, так и другую популярную библиотеку Python под названием Jinja2 (она также может быть использована для поддержки других систем, если это необходимо).

Фрагмент кода показывает, как может выглядеть HTML-шаблон, вызванный функцией `render()` из предыдущего раздела. Этот шаблон был написан с предположением, что во время отрисовки он будет иметь доступ к переменной списка, названной `youngest_teams` (содержащейся в контекстной переменной внутри функции `render()` выше). Внутри скелета HTML мы имеем выражение, которое сначала проверяет, существует ли переменная `youngest_teams`, а затем повторяет её в цикле `for`. При каждом повторе шаблон отображает значение `team_name` каждой команды в элементе `<li>`.
```html
## filename: best/templates/best/index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Home page</title>
</head>
<body>
  {% if youngest_teams %}
    <ul>
      {% for team in youngest_teams %}
        <li>{{ team.team_name }}</li>
      {% endfor %}
    </ul>
  {% else %}
    <p>No teams are available.</p>
  {% endif %}
</body>
</html>
```

[Назад к Django](#django)

### Что ещё можно сделать?

В предыдущих разделах показаны основные особенности, которые вы будете использовать почти в каждом веб-приложении: сопоставление URL-адресов, отображение, модели и шаблоны. Также Django предоставляет несколько других вещей:

- **Формы:** HTML-формы используются для сбора пользовательских данных для обработки на сервере. Django упрощает создание, проверку и обработку формы.
- **Аутентификация пользователя и разрешения:** Django включает надёжную систему аутентификации и авторизации пользователей, которая была построена с учётом безопасности.
- **Кеширование:** Создание динамического контента намного более интенсивно (и медленнее), чем обслуживание статического содержимого. Django обеспечивает гибкое кеширование, чтобы вы могли хранить всю или часть отображаемой страницы, для того, чтобы она не вызывалась повторно, за исключением случаев, когда это необходимо.
- **Админ-панель:** Административная панель в Django включена по умолчанию при создании приложения с использованием основного каркаса. Это упрощает управление админкой администраторам сайта для создания, редактирования и просмотра любых данных на вашем сайте.
- **Сериализация данных (преобразование в последовательную форму):** Django упрощает сериализацию и обслуживание ваших данных в таких форматах как XML или JSON. Это может быть полезно при создании веб-сервисов (веб-сайтов, которые исключительно служат для использования данных другими приложениями или сайтами и сами ничего не отображают) или при создании веб-сайта, на котором клиентский код обрабатывает весь рендеринг данных.

### Резюме

Поздравляем, вы завершили первый шаг в своём путешествии по Django! Теперь вы должны понимать основные преимущества Django, и примерно как может выглядеть каждая из основных частей приложения Django. Вы должны также изучить несколько вещей о языке программирования Python, включая синтаксис списков, функций и классов.

Вы уже видели код на Django выше, но в отличие от клиентского кода вам нужно настроить среду разработки для её запуска. Это наш следующий шаг.

[Назад к Django](#django)

## Setting up a Django development environment

Теперь, когда вы знаете, что такое Django, мы покажем вам, как настроить и протестировать среду разработки Django для Windows, Linux (Ubuntu) и Mac OS X - какую бы операционную систему вы не использовали, эта статья должна дать вам все, что необходимо для возможности начать разрабатывать приложения Django.

|Требования | Знание как открыть терминал / командную строку, как устанавливать программные пакеты в операционной системе вашего компьютера.
|-|--------
|Задача | Создать среду разработки для Django (1.10) и запустить её на вашем компьютере.

### Обзор среды разработки Django

В этом разделе объясняется, что входит в состав среды разработки, и даётся обзор некоторых параметров настройки и конфигурации. В оставшейся части статьи объясняется рекомендуемый метод установки среды разработки Django на Ubuntu, Mac OS X и Windows, и как вы можете её протестировать.

**Среда разработки** - это установка Django на вашем локальном компьютере, которую вы можете использовать для разработки и тестирования приложений Django до их развёртывания в производственной среде.

Основными инструментами, которые предоставляет сам Django, является набор скриптов Python для создания и работы с проектами Django, а также простой веб-сервер *разработки*, который можно использовать для тестирования локальных (то есть на вашем компьютере, а не на внешнем веб-сервере) веб-приложений Django на веб-браузере вашего компьютера.

Существуют и другие периферийные инструменты, являющиеся частью среды разработки, которые мы не будем освещать здесь. К ним относятся такие вещи, как текстовый редактор или IDE для редактирования кода, и инструмент управления исходным кодом, например Git, для безопасного управления различными версиями вашего кода. Мы предполагаем, что у вас уже установлен текстовый редактор.

[Назад к Django](#django)

### Разновидности установки Django

Django очень гибок с точки зрения способа и места установки и настройки. Django может быть:

- установлен на различных операционных системах,
- установлен из исходного кода, из Python Package Index (PyPi) и во многих случаях из любого менеджера пакетов,
- настроен на использование различных баз данных, которые должны быть установлены и настроены отдельно,
- запущен в основной системе окружения Python или в отдельном виртуальном окружении Python.
- Каждый из этих вариантов требует немного разной настройки и установки. Следующие подразделы объяснят некоторые аспекты вашего выбора. Далее мы покажем вам, как установить Django на некоторые операционные системы, и эта установка будет предполагаться на всём протяжении данного модуля.

> **Примечание:** Другие возможные способы установки можно найти в официальной документации Django. Мы ссылаемся на соответствующие документы.

- **Какие операционные системы поддерживаются?**

Веб-приложения Django можно запускать почти на любых машинах, которые поддерживают язык программирования Python 3, среди прочих: Windows, Mac OS X, Linux/Unix, Solaris. Почти любой компьютер имеет необходимую производительность для запуска Django во время разработки.

В этой статье мы предоставляем инструкции для Windows, Mac OS X, and Linux/Unix.

- **Какую версию Python стоит использовать?**

Мы рекомендуем использовать самую последнюю доступную версию - на момент написания статьи это Python 3.6.

> **Примечание:** Python 2.7 не может быть использован вместе с Django 2.0 (последние поддерживаемые серии для Python 2.7 - Django 1.11.x).

- **Откуда можно скачать Django?**

Для загрузки Django можно воспользоваться 3 источниками:

- The Python Package Repository (PyPi), при помощи инструмента pip. Это лучший способ получения последней стабильной версии Django.
- Использование версии из менеджера пакетов вашего компьютера. Такие дистрибутивы Django, собранные для конкретных операционных систем, предлагают знакомый механизм установки. Однако обратите внимание на то, что пакетные версии могут быть достаточно старыми и установлены только в системную среду Python (что может отличаться от ваших желаний).
- Установка из исходного кода. Вы можете получить и установить последний выпуск Django из исходного кода. Этот способ не рекомендован для новичков, но необходим в случае, когда вы готовы начать вносить собственный вклад в проект Django.

Данный материал описывает способ установки Django из PyPi с целью получения последней стабильной версии.

- **Какую базу данных выбрать?**

Django поддерживает 4 основных базы данных (PostgreSQL, MySQL, Oracle и SQLite), также есть публичные библиотеки, которые предоставляют разные уровни поддержки других SQL и NoSQL баз данных. Мы рекомендуем вам выбрать одинаковую БД для обеих рабочей и разрабатываемой сред (несмотря на то, что Django нивелирует множество различий баз данных при помощи Object-Relational Mapper (ORM), всё равно возможны потенциальные проблемы, которых лучше избегать.

Для данной статьи (и большей части модуля) мы будем использовать базу данных SQLite, которая сохраняет свои данные в файл. SQLite предназначен для использования в качестве облегчённой базы данных и не может поддерживать высокий уровень параллелизма. Это, однако, отличный выбор для приложений, которые в основном предназначены только для чтения.

> **Примечание:** Django сконфигурирован для использования SQLite по умолчанию, при создании вашего проекта с использованием стандартных инструментов (django-admin). Это отличный выбор для начала работы, потому что он не требует дополнительной настройки.

- **Глобальная установка или установка в виртуальную среду Python?**

Если вы устанавливаете Django в среду по умолчанию (глобальную), то будете способны сфокусироваться на одной версии Django на вашем компьютере. Это может быть проблемой в случае, если вы захотите создать новые веб-сайты (при помощи новой версии Django) во время поддержки веб-сайтов со старой версией.

По этой причине опытные разработчики Python / Django часто предпочитают вместо этого запускать свои приложения Python в независимых виртуальных средах Python. Это позволяет разработчикам иметь несколько разных сред Django на одном компьютере. Команда разработчиков Django сама рекомендует использовать виртуальные среды Python!

Этот модуль предполагает вашу установку Django в виртуальную среду, и мы покажем, как это сделать.

[Назад к Django](#django)

### Установка Python 3

Для использования Django вам необходимо установить Python 3 на свою операционную систему. Вам также понадобится инструмент [Python Package Index](https://pypi.python.org/pypi) — *pip3* — который используется для управления (установка, обновление и удаление) библиотек/пакетов Python, используемых Django и другими вашими приложениями Python.

Этот раздел коротко описывает то, как вы можете проверить имеющиеся версии и при необходимости установить новые для Ubuntu Linux 16.04, Mac OS X, and Windows 10.

> **Примечание:** В зависимости от платформы, вы можете иметь возможность установки Python/pip из собственного менеджера пакетов операционной системы или при помощи других инструментов. Для большинства платформ вы можете скачать необходимые установочные файлы из https://www.python.org/downloads/ и установить их при помощи соответствующего специфичного для платформы метода.

- **Ubuntu 16.04**

Ubuntu Linux включает в себя Python 3 по умолчанию. Вы можете удостовериться в этом, выполнив следующую команду в терминале:
```bash
python3 -V
 Python 3.5.2
```

Однако, инструмент Python Package Index, при помощи которого вам нужно будет установить пакеты для Python 3 (включая Django), по умолчанию не установлен. Вы можете установить pip3 через терминал bash при помощи:
```bash
sudo apt-get install python3-pip
```

- **Mac OS X**

Mac OS X "El Capitan" не включает Python 3. Вы можете удостовериться в этом, выполнив следующую команду в терминале:
```bash
python3 -V
 -bash: python3: command not found
```

Вы можете легко установить Python 3 (вместе с инструментом pip3) с [python.org](https://www.python.org/):

1. Скачайте нужный установочный файл:
   - Перейдите в https://www.python.org/downloads/
   - Нажмите на кнопку **Скачать Python 3.6.4** (точная основная версия может отличаться).
2. Найдите файл при помощи *Finder*, дважды кликните по нему и следуйте подсказкам по установке.

Удостовериться в успешной установке вы можете проверкой на наличие Python 3, как показано ниже:
```bash
python3 -V
 Python 3.5.20
```

Подобным образом вы можете проверить установку pip3, отобразив список доступных пакетов:
```bash
pip3 list
```

- **Windows 10**

Windows не включает Python по умолчанию, но вы можете легко установить его (вместе с инструментом pip) с [python.org](https://www.python.org/):

1. Скачайте нужный установочный файл:
    - Перейдите в https://www.python.org/downloads/
    - Нажмите на кнопку **Скачать Python 3.6.4** (точная основная версия может отличаться).
2. Установите Python, дважды кликнув на скачанный файл и следуя инструкциям по установке.

После этого вы сможете подтвердить успешную установку Python путём выполнения следующего текста в командной строке:
```bash
py -3 -V
 Python 3.5.2
```

Установщик Windows включает в себя pip3 (менеджер пакетов Python) по умолчанию. Вы можете отобразить список установленных пакетов, как показано далее:
```bash
pip list
```

> **Примечание:** Установщик должен сделать все, что необходимо для корректной работы указанной команды. Однако, если вы видите сообщение о том, что Python не может быть найден, вам может потребоваться добавить его в системный путь.

[Назад к Django](#django)

### Использование Django внутри виртуальной среды Python

Для создания виртуальных сред мы будем использовать библиотеки [virtualenvwrapper](https://virtualenvwrapper.readthedocs.io/en/latest/index.html) (Linux и macOS X) и [virtualenvwrapper-win](https://pypi.python.org/pypi/virtualenvwrapper-win) (Windows), которые в свою очередь обе используют инструмент [virtualenv](https://github.com/mdn/archived-content/tree/main/files/en-us/mozilla/virtualenv). Инструмент обёртки предоставляет совместимый интерфейс для управления интерфейсами на всех платформах.

### Установка ПО виртуальной среды

- **Установка виртуальной среды для Ubuntu**

После установки Python и pip вы можете установить *virtualenvwrapper* (который включает в себя *virtualenv*). Вы можете либо воспользоваться официальной инструкций по установке [отсюда](http://virtualenvwrapper.readthedocs.io/en/latest/install.html), либо следовать следующим инструкциям:

Установите инструмент при помощи pip3:
```bash
sudo pip3 install virtualenvwrapper
```

Затем добавьте следующие строки в конец файла загрузки программной оболочки (shell) (это скрытый файл в вашей домашней директории с именем **.bashrc**). Они устанавливают расположение виртуальных сред, расположение каталога разрабатываемого проекта и расположение установленного с этим пакетом скрипта.
```bash
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
export VIRTUALENVWRAPPER_VIRTUALENV_ARGS=' -p /usr/bin/python3 '
export PROJECT_HOME=$HOME/Devel
source /usr/local/bin/virtualenvwrapper.sh
```

Затем перезагрузите файл загрузки, выполнив в терминале следующую команду:
```bash
source ~/.bashrc
```

В этот момент вы должны увидеть запуск группы скриптов, как показано ниже:
```bash
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/premkproject
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/postmkproject
...
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/preactivate
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/postactivate
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/get_env_details
```

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualenv`.

- **Установка виртуальной среды для macOS X**

Установка *virtualenvwrapper* на macOS X почти идентична Ubuntu (и снова вы можете воспользоваться либо [официальными](http://virtualenvwrapper.readthedocs.io/en/latest/install.html), либо следующими инструкциями).

Установите инструмент при помощи *pip3*:
```bash
sudo pip3 install virtualenvwrapper
```

Затем добавьте следующие строки в конец вашего файла загрузки программной оболочки:
```bash
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
export PROJECT_HOME=$HOME/Devel
source /usr/local/bin/virtualenvwrapper.sh
```

> **Примечание:** Переменная `VIRTUALENVWRAPPER_PYTHON` указывает на обычное расположение Python3. Если virtualenv не работает во время тестирования, то вам следует проверить, находится ли интерпретатор Python в нужном расположении (и затем поменять его соответствующим образом в значении переменной).

Эти строки такие же, как в случае с Ubuntu, но файл загрузки в вашей домашней директории назван иначе - **.bash_profile**.

> **Примечание:** Если вы не можете найти и изменить .bash_profile при помощи Finder, то можно также открыть его при помощи редактора терминала nano.
>
> Команды в этом случае выглядят примерно так:
> ```bash
> cd ~ # Navigate to my home directory
> ls -la #List the content of the directory. You should see .bash_profile
> nano .bash_profile # Open the file in the nano text editor, within the terminal
> # Scroll to the end of the file, and copy in the lines above
> # Use Ctrl+X to exit nano, Choose Y to save the file.
> ```

После этого перезагрузите файл загрузки путём выполнения следующей команды в терминале:
```bash
source ~/.bash_profile
```

В этот момент вы должны увидеть запуск группы скриптов (те же скрипты, что и в случае установки на Ubuntu).

Теперь вы должны иметь возможность создания новой виртуальной среды при помощи команды `mkvirtualenv`.

- **Установка виртуальной среды для Windows 10**

Установка [virtualenvwrapper-win](https://pypi.python.org/pypi/virtualenvwrapper-win) ещё более проста, чем установка *virtualenvwrapper*, потому что вам не нужно настраивать расположения сохранения информации о виртуальной среде инструментом (эти значения заданы по умолчанию). Все, что вам нужно сделать, это запустить следующую команду в командной строке:
```bash
pip3 install virtualenvwrapper-win
```

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualen`.

[Назад к Django](#django)

### Создание и использование виртуальной среды

После установки *virtualenvwrapper* и *virtualenvwrapper-win* работа с виртуальными средами становится одинаковой для всех платформ.

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualenv`. Во время запуска команды вы увидите установку виртуальной среды (конкретные результаты команды очень зависят от платформы). После выполнения команды активируется новая виртуальная среда — заметить это вы можете по тому, что началом ввода будет название виртуальной среды в круглых скобках (как показано ниже).
```bash
$ mkvirtualenv my_django_environment
Running virtualenv with interpreter /usr/bin/python3 ...
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/t_env7/bin/get_env_details
(my_django_environment) ubuntu@ubuntu:~$
```

Теперь вы находитесь внутри виртуальной области и можете установить Django и начать разработку.

> **Примечание:** С этого момента в этой статье (и всем модуле) пожалуйста учитывайте, что любые команды запускаются в виртуальной среде Python, как та, что мы показали выше.

- **Использование виртуальной среды**

Есть ещё несколько полезных команд, которые вам следует знать (в документации по инструменту их гораздо больше, но эти вы будете использовать регулярно):

- `deactivate` — Выход из текущей виртуальной среды Python
- `workon` — Список доступных виртуальных сред
- `workon name_of_environment` — Активация конкретной виртуальной среды Python
- `rmvirtualenv name_of_environment` — Удаление конкретной виртуальной среды.

[Назад к Django](#django)

### Установка Django, проверка установки

После создания виртуальной среды и вызова `workon` для входа в неё вы можете использовать *pip3* для установки Django.
```bash
pip3 install django
```

Вы можете проверить установку Django, выполнив следующую команду (она просто проверяет, что Python может найти модуль Django):
```bash
# Linux/Mac OS X
python3 -m django --version
 1.10.10

# Windows
py -3 -m django --version
 1.10.10
```

> **Примечание:** Для Windows вы запускаете скрипты Python 3 с префиксом команды py -3, в то время как для Linux/Mac OSX префикс - python3.

>> **Предупреждение: Важно:** В оставшейся части материала используется вариант команды Linux для вызова Python 3 (python3) . Если вы работаете в Windows, то просто замените этот префикс на: py -3

- **Проверка вашей установки**

Указанная выше проверка работает, но не представляет особого интереса. Более интересная проверка заключается в создании шаблона проекта и проверки его работы. Для её выполнения перейдите в командной строке/терминале в место, где планируете сохранять приложения Django. Создайте папку для теста и перейдите в неё.
```bash
mkdir django_test
cd django_test
```

Затем вы можете создать шаблон сайта *"mytestsite"* при помощи инструмента **django-admin**. После создания сайта вы можете перейти в папку, где найдёте основной скрипт для управления проектами с именем **manage.py**.

```bash
django-admin startproject mytestsite
cd mytestsite
```

Мы можем запустить веб-сервер разработки из этой папки при помощи **manage.py** и команды `runserver`, как показано ниже.
```bash
$ python3 manage.py runserver
Watching for file changes with StatReloader
Performing system checks…

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
March 01, 2022 - 01:19:16
Django version 4.0.2, using settings 'mytestsite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

> **Примечание:** Указанная команда демонстрирует выполнение для Linux/Mac OS X. В настоящий момент вы можете проигнорировать предупреждения о "13 непримененных миграциях"!

Как только сервер запущен, вы можете посмотреть сайт, перейдя по следующему адресу в вашем браузере: `http://127.0.0.1:8000/`. Вы должны увидеть, что сайт выглядит следующим образом:

![Django site](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/development_environment/django_skeleton_website_homepage.png)

### Заключение
Теперь у вас на компьютере установлена и запущена среда разработки Django.

В разделе проверки вам коротко был показан способ создания нового сайта на Django при помощи `django-admin startproject` и его запуск в вашем браузере при помощи веб-сервера разработки (`python3` `manage.py` `runserver`). В следующей статье мы подробнее рассмотрим этот процесс создания простого, но полноценного веб-приложения.

[Назад к Django](#django)

## Django: сайт местной библиотеки

Первая статья в цикле объясняет и разбирает пример сайта "местная библиотека".

|Необходимо: | Прочитайте [вступление](#введение). Для последующих статей вам так же потребуется настроить [среду разработки](#создание-и-использование-виртуальной-среды).
|---|--- 
|Цель: | Представить читателю пример веб-приложения, которое будет использоваться в нашем руководстве и показать, какие темы будут изучены в этом цикле статей.

### Обзор руководства
Добро пожаловать на руководство MDN "Сайт местной библиотеки" по фреймворку Django, который может использоваться для управления архивом библиотеки.

В цикле статей мы научимся:

- При помощи Django создавать прототип сайта.
- Запускать и останавливать сервер для разработки.
- Создавать модели для представления данных.
- Использовать админ-панель Django для управления сайтом
- Создавать представления для того, чтобы формировать из данных ответы на различные запросы и превращать их в HTML разметку, которая будет отображаться в браузере.
- Создавать маршруты, чтобы определённые URL адреса ассоциировались сервером с определёнными представлениями
- Создавать авторизацию пользователей и сессии, чтобы управлять доступом к сайту.
- Работать с формами.
- Тестировать ваше веб-приложение.
- Эффективно использовать средства безопасности Django.
- Размещать ваш сайт в Сети.

С некоторыми темами вы уже сталкивались, а про некоторые только знаете, что они существуют. По окончанию цикла статей вы должны будете иметь достаточно знаний, чтобы разрабатывать несложные сайты на Django для своих целей.

### Сайт местной библиотеки

Это название сайта, который мы создадим и будем улучшать, в течение этого цикла статей. Как можно догадаться, цель этого сайта в том, чтобы представить небольшой онлайн каталог маленькой местной библиотеки, где пользователи смогут загружать доступные книги и управлять своими профилями.

Этот пример был выбран потому, что его можно масштабировать, чтобы рассказать настолько детально или поверхностно, насколько это требуется, о почти любой особенности Django. Что более важно, этот пример позволяет показать последовательный путь по самым важным функциям фреймворка Django:

- В самом начале, мы создадим библиотеку, в которой пользователи смогут только просматривать доступные книги. Это позволит нам исследовать операции, которые присутствуют почти на каждом сайте: чтение и отображение информации из базы данных.
- По мере продвижения, на сайте станут использоваться более продвинутые возможности Django. Например, мы сможем расширить библиотеку и позволить пользователям резервировать книги, чтобы показать как использовать формы и авторизацию.

Несмотря на то, что это довольно обширный пример, проект называется сайтом местной библиотеки потому, что мы надеемся показать минимум достаточной информации, которая поможет вам быстро научиться разрабатывать на Django. Поэтому мы будем хранить данные о книгах, копиях книг, авторах и другую ключевую информацию. Однако мы не будем хранить другую информацию, которая могла бы быть полезной библиотеке, или создавать обширную инфраструктуру для поддержки нескольких сайтов библиотек или другие особенности "крупных библиотек".

- **Я застрял, где мне взять код?**

По мере усложнения руководства, мы будем предоставлять необходимый код, который можно скопировать и вставить, а так же будет и другой код, который, мы надеемся, вы улучшите самостоятельно.

Если вы застряли, то можете найти полноценную версию сайта на [Github](https://github.com/mdn/django-locallibrary-tutorial).

- **Подводя итоги**

Теперь вы знаете чуть больше о сайте, который мы будем разрабатывать, и теперь самое время создать скелет нашего сайта.

[Назад к Django](#django)

## Django 2: создание скелета

Это вторая статья из нашего [руководства по Django](#django-сайт-местной-библиотеки), которая показывает, как можно создать "скелет" сайта, как фундамент, на котором можно строить всё остальное: настройки, ссылки, модели, контроллеры и представления.

|Необходимо: |[Настройка окружения](#setting-up-a-django-development-environment). Прочитать первую статью [руководства по Django](#django-сайт-местной-библиотеки).
|----|----
|Цель: |Научиться использовать инструменты Django для создания новых веб-сайтов.

### Обзор

Эта статья показывает, как можно создать "скелет"(прототип) сайта, который затем можно расширить при помощи различных настроек, url адресов, моделей, представлений, и шаблонов (эти темы будут объясняться в последующих статьях).

Алгоритм следующий:

1. Использовать `django-admin` для создания папки проекта, шаблонов остальных файлов, и скрипта для управления проектом (**manage.py**).

2. Использовать **manage.py** для *создания одного или нескольких* приложений.

> **Примечание:** Сайт может состоять из одной или нескольких различных частей, например: основная часть, блог, вики, раздел загрузок, и так далее. Философия Django подталкивает разработчиков создавать эти части, как разные **приложения**, которые, если понадобится, могут быть использованы повторно в других проектах.

3. Зарегистрировать в настройках эти приложения, чтобы использовать их в проекте.

4. Настроить маршруты url адресов для каждого из приложений.

Для [Сайта местной библиотеки](#django-сайт-местной-библиотеки) папка сайта и проекта будет называться *locallibrary*, и у нас будет одно приложение с названием *catalog*. Верхняя структура проекта будет следующей:
```bash
locallibrary/         # Папка сайта
    manage.py         # Скрипт для управления проектов (создан manage.py)
    locallibrary/     # Папка сайта/проекта (создана manage.py)
    catalog/          # Папка приложения (также создана manage.py)
```

Следующие разделы статьи разложат по полочкам этапы создания "скелета", и покажут вам, как можно проверить сделанные изменения. В конце статьи мы обсудим некоторые другие настройки сайта, которые можно назначить на этом этапе.

[Назад к Django](#django)

### Создание проекта

Для начала откройте командную строку/терминал, перейдите в ту папку, куда вы хотите поместить проект Django(лучше в папке профиля пользователя `C:\Users\user_name`, при запуске командной строки используется именно эта директория), и создайте папку для вашего нового сайта (в данном случае: *locallibrary*). Затем войдите в эту папку, используя команду cd:
```bash
mkdir locallibrary
cd locallibrary
```

Создайте новую папку, используя команду `django-admin startproject` как в примере ниже, и затем зайдите в созданную папку.
```bash
  django-admin startproject locallibrary .
cd locallibrary
```

Команда `django-admin` создаст файловую структуру, как в примере ниже:
```bash
locallibrary/
    manage.py
    locallibrary/
        settings.py
        urls.py
        wsgi.py
```

Подпапка проекта *locallibrary* это ключевая директория нашего проекта:

- **settings.py** содержит в себе все настройки проекта. Здесь мы регистрируем приложения, задаём размещение статичных файлов, настройки базы данных и так далее.
- **urls.py** задаёт ассоциации url адресов с представлениями. Несмотря на то, что этот файл может содержать все настройки url, обычно его делят на части, по одной на приложение, как будет показано далее.
- **wsgi.py** используется для налаживания связи между вашим Django приложением и веб-сервером. Вы можете воспринимать его, как утилиту.

Скрипт **manage.py** используется для создания приложений, работы с базами данных и для запуска отладочного сервера.

[Назад к Django](#django)

### Создание приложения Каталог

Выполнив предыдущие шаги, запустите следующую команду для создания приложения *catalog*, который будет размещён внутри папки locallibrary (команду необходимо выполнять из папки, в которой находится **manage.py**):
```bash
python3 manage.py startapp catalog
```

> **Примечание:** Приведённая выше команда справедлива для GNU Linux/Mac OS. На Windows команда должна иметь вид: `py -3 manage.py startapp catalog`
>
>Если вы работаете под Windows, заменяйте команду `python3` на `py -3` в этой и следующих статьях.

Эта команда создаст новую папку и наполнит её файлами различных частей приложения (выделенные **полужирным** ниже). Большинство файлов названы, исходя из их назначения (например контроллеры(views) должны находится во **views.py**, модели в **models.py**, тесты в **tests.py**, настройки административной части в **admin.py**, регистрация приложения в **apps.py**) и уже содержат некоторый шаблонный код для работы с вышеназванными объектами.

Обновлённая директория должна выглядеть следующим образом:
```bash
locallibrary/
    manage.py
    locallibrary/
    catalog/
        admin.py
        apps.py
        models.py
        tests.py
        views.py
        __init__.py
        migrations/
```

Кроме перечисленных выше файлов были созданы:

- Папка *migrations* используется, чтобы хранить"миграции" — файлы, которые позволяют вам автоматически обновлять базу данных по мере изменения моделей.
- `__init__.py` — пустой файл для того, чтобы Django и Python распознавали папку как [Python модуль](https://docs.python.org/3/tutorial/modules.html#packages) и позволяет нам использовать его объекты внутри других частей проекта.
> **Примечание:** Заметили, что некоторых файлов не хватает? В то время, как там нашли себе место файлы для контроллеров(views) и моделей(models), файлов для настройки url соотносителя, шаблонов, и статичных файлов создано не было. Далее мы покажем, как их создать (они не обязательны для каждого сайта, но нужны в данном примере).

[Назад к Django](#django)

### Регистрация папки с приложением

После создания приложения, нам нужно зарегистрировать его в проекте, чтобы различные утилиты затрагивали его своим действием (например при добавлении моделей в базу данных). Приложения регистрируются добавлением их названий в список `INSTALLED_APPS` в настройках проекта(который, как мы помним, называется **settings.py**).

Откройте файл **locallibrary/locallibrary/settings.py** и найдите в нём список `INSTALLED_APPS`. Затем добавьте новую строку в конец списка, как показано ниже.
```bash
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'catalog.apps.CatalogConfig',
]
```

Новая строка указывает на файл конфигурации приложения (`CatalogConfig`), который был создан в **/locallibrary/catalog/apps.py**, когда вы создали приложение.

Примечание: Легко заметить, что в `INSTALLED_APPS` уже подключено большое количество приложений (и объектов `MIDDLEWARE`, ниже в файле конфигурации). Они добавляют поддержку [админ-панели Django](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site) и, как следствие, огромное количество функциональности (включая сессии, аутентификацию и прочее).

[Назад к Django](#django)

### Настройка базы данных

На этом шаге обычно указывают базу данных для будущего проекта — имеет смысл использовать для разработки и размещённого в Сети одну и ту же базу данных, по возможности, чтобы исключить различия в поведении. Про различные варианты вы можете прочитать в документации Django в разделе [Базы данных](#базы-данных).

Мы будем использовать базу данных SQLite для этого проекта, потому что не предполагаем большое количество одновременных запросов на неё, а ещё потому, что для её настройки совсем не надо ничего делать! Вы можете видеть, что база данных уже настроена в **settings.py** (подробная информация указана ниже):
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
```

Так как мы используем SQLite, то нам не нужно ничего делать.

[Назад к Django](#django)

### Другие настройки проекта

Файл **settings.py** так же применяется и для некоторых других настроек, но на данном шаге имеет смысл поменять разве что [TIME_ZONE](https://docs.djangoproject.com/en/1.10/ref/settings/#std:setting-TIME_ZONE) — это значение должно быть представлено строкой, указанной в [списке часовых поясов tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (колонка TZ в таблице, в строке временной зоны, которая вам нужна). Измените `TIME_ZONE` на одну из строк из таблицы, которая отвечает вашему часовому поясу. Например:
```python
TIME_ZONE = 'Asia/Bishkek'
```

В файле присутствует две настройки, которые не нужно менять сейчас, но о назначении которых следует знать:

- `SECRET_KEY`. Это секретный ключ, который используется Django для поддержки безопасности сайта. Если вы раскроете этот ключ в процессе разработки кому-либо, то необходимо будет его сменить (возможно считать его с какого-либо файла на сервере или переменной окружения) когда будете размещать проект на сервер.
- `DEBUG`. Включает подробные сообщения об ошибках, вместо стандартных HTTP статусов ответов. Должно быть изменено на `False` на сервере, так как эта информация очень много расскажет взломщикам.

[Назад к Django](#django)

### Подключение URL-адреса

При создании сайта, был создан файл сопоставления URL (**urls.py**) в корне проекта. Хотя можно использовать его для обработки всех URL адресов, более целесообразно подключать отдельные файлы сопоставлений для каждого приложения.

Откройте **locallibrary/locallibrary/urls.py** и обратите внимание на закомментированный текст, который объясняет суть происходящего.
```python
"""
locallibrary URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/1.10/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.conf.urls import url, include
    2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
"""
from django.urls import path
from django.contrib import admin

urlpatterns = [
    path('admin/', admin.site.urls),
]
```

URL соотношения хранятся в переменной `urlpatterns`, которая является списком функций `path()`. Каждая `path()` функция или ассоциирует шаблон URL_ *с контроллером(views) или же его с другим таким списком (во втором случае, первый URL становится "базовым" для других, которые определяются в дочернем списке). Список `urlpatterns` инициализирует список функции, которая, например, соотносит _admin/* с модулем `admin.site.urls` , который содержит собственный файл-соотноситель.

Добавьте строчки, приведённые ниже в низ файла **urls.py**, чтобы добавить новый элемент в список `urlpatterns`. Этот элемент содержит `url()` который направляет запросы с URL `catalog/` к модулю `catalog.urls` (файл с относительным путём **/catalog/urls.py**).
```python
# Используйте include() чтобы добавлять URL из каталога приложения
from django.urls import include
from django.urls import path
urlpatterns += [
     path('catalog/', include('catalog.urls')),
]
```

Теперь давайте перенаправим корневой URL нашего сайта (например `127.0.0.1:8000`) на URL `127.0.0.1:8000/catalog/`; это единственное приложение, которое мы собираемся использовать, поэтому это вполне разумно. Чтобы это использовать, нам понадобится специальная функция (`RedirectView`), которая принимает первым параметром новый относительный URL на который следует перенаправлять (`/catalog/`) когда указанный в функции `url()` адрес соотносится с адресом запроса (корневой URL, в данном случае).

Добавьте следующие строчки, тоже в конец файла:
```python
# Добавьте URL соотношения, чтобы перенаправить запросы с корневого URL, на URL приложения
from django.views.generic import RedirectView
urlpatterns += [
    path('', RedirectView.as_view(url='/catalog/', permanent=True)),
]
```

Django не размещает статические файлы(CSS, JavaScript, и изображения) по умолчанию, но это было бы крайне полезно на этапе разработки нашего сайта. В самом конце нашего URL соотносителя, можно включить размещение статических файлов.

Добавьте последнюю часть в конец файла:
```py
# Используйте static() чтобы добавить соотношения для статических файлов
# Только на период разработки
from django.conf import settings
from django.conf.urls.static import static

urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

> **Примечание:** Существуют различные способы дополнения списка `urlpatterns` (в примере мы просто добавляли объект, используя оператор `+=` чтобы чётко разделить изначальный и дописанный код). Вместо этого, мы могли бы добавить соотношения внутрь определения переменной:
>```py
>urlpatterns = [   path('admin/', admin.site.urls),
>path('catalog/', include('catalog.urls')),path('',
>RedirectView.as_view(url='/catalog/', permanent=True)), ] +
>static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
>```
>Кроме того, мы добавили import вниз файла (`from django.urls import include`) ,чтобы видеть, что мы добавили, но обычно все инструкции import добавляются в верхнюю часть файла.

Напоследок, создайте файл **urls.py** внутри папки **catalog**, и добавьте следующий код, чтобы определить (пустой) `urlpatterns`. Сюда мы будем добавлять наши URL соотношения, по мере разработки сайта.
```python
from django.urls import path
from . import views

urlpatterns = [

]
```

[Назад к Django](#django)

### Тестирование работы скелета

На этом, мы создали прототип сайта. Пока сайт ничего не умеет делать, но стоит запустить его, чтобы убедиться, что мы ничего не сломали.

До этого, нам предстоит впервые запустить *миграцию базы данных*. Это обновит нашу базу данных и добавит туда необходимые модели (и уберёт некоторые предупреждения, которые были бы показаны при попытке запуска).

- **Запуск миграций базы данных**

Django использует **Объектный Соотноситель Связей (ORM)** чтобы соотносить определения моделей в Django приложении со структурами данных, которые используются базой данных. Когда мы меняем наши модели, Django отслеживает изменения и может создать файлы миграций (в папке **/locallibrary/catalog/migrations/**) чтобы применить соответствующие структуры данных к базе, чтобы та соответствовала модели.

При создании сайта, Django автоматически добавил несколько моделей, чтобы мы могли их использовать в админ-панели (о которой мы поговорим позже). Выполните следующие команды, чтобы создать нужные таблицы в базе данных, соответствующие этим моделям (убедитесь, что вы находитесь в папке с **manage.py**):
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

> **Предупреждение:** Необходимо выполнять команды выше каждый раз, когда вы меняете модели таким образом, что структура таблицы изменится(включая добавления и удаления как отдельных полей, так и целых моделей).

Команда `makemigrations` *создаёт* (но не применяет) миграции для всех приложений, которые установлены в ваш проект (вы так же можете указать в конце имя конкретного приложения, чтобы создать миграции только для него). Это даёт вам возможность проверить код перед тем, как их применить — когда вы станете хорошо разбираться в Django, то сможете даже менять их!

Команда `migrate` применяет созданные миграции к базе (Django отслеживает, какие миграции были созданы для данной базы).

> **Примечание:** Посмотрите раздел [Миграции](https://docs.djangoproject.com/en/2.2/topics/migrations/) в документации Django чтобы получить информацию о менее распространённых командах для управления миграциями.

[Назад к Django](#django)

### Запуск сайта

Во время разработки, вы можете проверить свой сайт, разместив его на *встроенном отладочном сервере*, и просмотрев его в своём браузере.

> **Примечание:** Отладочный веб-сервер не настолько функционален и производителен, для постоянного размещения , но это самый простой способ запустить свой сайт на Django и проверить его на наличие ошибок. По умолчанию, он разместит сайт на вашем компьютере (`http://127.0.0.1:8000/`), но вы так же можете указать различные компьютеры в вашей сети для этой цели. Для получения большего количества информации загляните в раздел [django-admin и manage.py: отладочный сервер](https://docs.djangoproject.com/en/2.2/ref/django-admin/) документации Django.

Запустите веб-сервер, используя команду `runserver` (в той же папке, что и **manage.py**):
```bash
python3 manage.py runserver

 Performing system checks...

 System check identified no issues (0 silenced).
 September 22, 2016 - 16:11:26
 Django version 1.10, using settings 'locallibrary.settings'
 Starting development server at http://127.0.0.1:8000/
 Quit the server with CTRL-BREAK.
```

Когда сервер запустится, вы сможете посетить сайт по адресу `http://127.0.0.1:8000/` в вашем веб-браузере. Вы должны увидеть страницу с ошибкой, навроде этой:

![/catalog/](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/skeleton_website/django_404_debug_page.png)

Не волнуйтесь! Эта страница должна появиться и сообщить нам, что мы ещё не настроили ни одной страницы в модуле `catalogs.urls` (на который мы были перенаправлены запросили корневой URL сайта).

> **Примечание:** Показанная выше страница открывает нам одно из замечательных свойств Django — автоматические отчёты об ошибках. На экране с ошибкой отображается множество полезной информации, когда страница не найдена, или ошибка была вызвана кодом. В данном случае, мы видим, что запрошенный URL не соответствует ни одному шаблону (из указанных). Подобные отчёты будут выключены при DEBUG=False (когда мы разместим приложение в Сеть), в этом случае будет показана менее информативная, но более дружелюбная к пользователю страница(которую вам надо будет создать - прим. переводчика).

На данном этапе, мы поняли, что Django работает должным образом!

> **Примечание:** Вам следует перезапускать миграцию и заново тестировать сайт, после того как вы делаете важные изменения. Поверьте, это не займёт много времени!

- **Домашнее задание**

Папка **catalog/** содержит файлы контроллеров(views), моделей(models), и других частей приложения. Просмотрите эти файлы.

Как было написано выше, URL соотноситель для админ-панели был подключён в файле **urls.py**. Войдите в административную часть и посмотрите, что произойдёт (вы можете найти URL из соотношения выше).

- **Подводя итоги**

Теперь вы создали полноценный скелет веб-приложения, который теперь вы можете расширить url соотносителями, контроллерами(views) и моделями(models).

Теперь скелет [Сайта местной библиотеки](#django-сайт-местной-библиотеки) сделан и запущен, теперь самое время начать писать код, который научит сайт делать то, что он должен делать.

- **Смотрите также**

- [Пишем своё первое приложение на Django - часть 1](https://docs.djangoproject.com/en/2.2/intro/tutorial01/) (документация Django)
- [Приложения](https://docs.djangoproject.com/en/2.2/ref/applications/) (документация Django). содержит информацию о настройке приложений.

[Назад к Django](#django)

## Django 3: использование моделей

В этой статье показано, как определить модели для [LocalLibrary](#django-сайт-местной-библиотеки) сайта. Она объясняет, что такое модель, как она объявляется, и некоторые из основных типов полей. В ней также кратко показаны некоторые из основных способов доступа к данным модели.

|Предпосылки |[Django Tutorial Part 2: Creating a skeleton website](#django-2-создание-скелета).
|-----|----
|Задача: |Научиться проектировать и создавать свои собственные модели, выбирая подходящие поля.

### Обзор

Веб-приложения Django получают доступ и управляют данными через объекты Python, называемые моделями. Модели определяют структуру хранимых данных, включая типы полей и, возможно, их максимальный размер, значения по умолчанию, параметры списка выбора, текст справки для документации, текст меток для форм и т. д. Определение модели не зависит от основной базы данных - вы можете выбрать один из нескольких компонентов вашей настройки проекта. После того, как вы выбрали какую базу данных хотите использовать, вам не нужно напрямую работать с ней - вы просто пишете свою структуру модели и код, а Django делает всю грязную работу, связанную с базой данных за вас.

В этом учебнике показано, как определить и получить доступ к моделям на примере [LocalLibrary website](#django-сайт-местной-библиотеки).

### Проектирование моделей LocalLibrary

Перед тем, как вы начнёте программировать модели, стоит потратить несколько минут, чтобы подумать о том, какие данные нам нужно хранить, и о взаимоотношениях между разными объектами.

Мы знаем, что нам нужно хранить информацию о книгах (название, резюме, автор, язык, на котором написана книга, категория, ISBN) и что у нас может быть несколько доступных экземпляров (с уникальным глобальным идентификатором, статусом доступности и т. Д.). Нам может потребоваться хранить больше информации об авторе, чем просто их имя, и могут быть несколько авторов с одинаковыми или похожими именами. Мы хотим иметь возможность сортировать информацию на основе названия книги, автора, письменного языка и категории.

При проектировании ваших моделей имеет смысл иметь отдельные модели для каждого «объекта» (группа связанной информации). В этом случае очевидными объектами являются книги, экземпляры книг и авторы.

Вы также можете использовать модели для представления параметров списка выбора (например, как выпадающий список вариантов), вместо жёсткого кодирования выбора на самом веб-сайте - это рекомендуется, когда все варианты неизвестны заранее или могут измениться. Очевидные кандидаты на модели в этом случае включают жанр книги (например, «Научная фантастика», «Французская поэзия» и т. д.) И язык (английский, французский, японский).

Как только мы определились с нашими моделями и полями, нам нужно подумать об отношениях. Django позволяет вам определять отношения, как один к одному (`OneToOneField`), один ко многим (`ForeignKey`) и многие ко многим (`ManyToManyField`).

Диаграмма ассоциации UML, приведённая ниже показывает модели, которые мы определили в этом случае (в виде блоков). Как и выше, мы создали модели для книги (общие сведения о книге), экземпляр книги (статус конкретных физических копий книги, доступных в системе) и автора.Мы также решили создать модель для жанра, чтобы можно было создавать / выбирать значения через интерфейс администратора. Мы решили не иметь модель для BookInstance: status - мы жёстко закодировали значения (LOAN_STATUS), потому что мы не ожидаем их изменения. В каждом из полей вы можете увидеть имя модели, имена и типы полей, а также методы и их типы возврата.

На диаграмме также показаны зависимости между моделями, включая их *множители*. Множители представляют собой числа на диаграмме, показывающие минимум и максимум единиц каждой модели, которые могут присутствовать в этой связи. Например, соединительная линия между ящиками показывает, что книга и жанр связаны между собой. Цифры, близкие к модели жанра, показывают, что у книги может быть один или несколько жанров (сколько угодно), а числа на другом конце строки рядом с моделью книги показывают, что у жанра может быть ноль или более связанных книг.

![diargam](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Models/local_library_model_uml.png)

> **Примечание:** В следующем разделе приведён базовый пример, поясняющий, как модели определяются и используются. Когда вы его прочитаете, подумайте, как мы построим каждую из моделей на диаграмме выше.

[Назад к Django](#django)

### Модель для начинающих

В этом разделе представлен краткий обзор того, как определяется модель, и некоторые из наиболее важных полей и аргументы поля.

### Определение модели

Модели обычно определяются в приложении **models.py**. Они реализуются как подклассы `django.db.models.Model`, и могут включать поля, методы и метаданные. В приведённом ниже фрагменте кода показана «типичная» модель, названная `MyModelName`:
```py
from django.db import models
from django.urls import reverse

class MyModelName(models.Model):
    """Типичный класс модели, производный от класса Model."""

    # Поля
    my_field_name = models.CharField(max_length=20, help_text='Введите описание поля')
    # …

    # Метаданные
    class Meta:
        ordering = ['-my_field_name']

    # Methods
    def get_absolute_url(self):
        """Возвращает URL-адрес для доступа к определенному экземпляру MyModelName."""
        return reverse('model-detail-view', args=[str(self.id)])

    def __str__(self):
        """Строка для представления объекта MyModelName (например, в административной панели и т.д.)."""
        return self.my_field_name
```

В следующих разделах мы подробно рассмотрим каждый элемент внутри модели:

### Поля

Модель может иметь произвольное количество полей любого типа - каждый представляет столбец данных, который мы хотим сохранить в одной из наших таблиц базы данных. Каждая запись (строка) базы данных будет состоять из одного значения каждого поля. Давайте рассмотрим приведённый выше пример:
```py
my_field_name = models.CharField(max_length=20, help_text="Введите описание поля")
```

Наш вышеприведённый пример имеет одно поле, называемое `my_field_name`, типа `models.CharField` — что означает, что это поле будет содержать строки буквенно-цифровых символов. Типы полей назначаются с использованием определённых классов, которые определяют тип записи, которая используется для хранения данных в базе данных, а также критерии проверки, которые должны использоваться, когда значения получены из формы HTML (то есть, что составляет действительное значение). Типы полей также могут принимать аргументы, которые дополнительно определяют, как поле хранится или может использоваться. В этом случае мы даём нашему полю два аргумента:

- `max_length=20` — Указывает, что максимальная длина значения в этом поле составляет 20 символов.
- `help_text="Введите описание поля"` — предоставляет текстовую метку для отображения, чтобы помочь пользователям узнать, какое значение необходимо предоставить, когда это значение должно быть введено пользователем через HTML-форму.

Имя поля используется для обращения к нему в запросах и шаблонах. В полях также есть метка, которая задаётся как аргумент (`verbose_name`), либо выводится путём заглавной буквы первой буквы имени переменной поля и замены любых символов подчёркивания пробелом (например, `my_field_name` будет иметь метку по умолчанию *My field name*).

Порядок, в котором объявляются поля, будет влиять на их порядок по умолчанию, если модель отображается в форме (например, на сайте администратора), хотя это может быть переопределено.

[Назад к Django](#django)

### Общие аргументы поля

Следующие общие аргументы могут использоваться при объявлении многих / разных типов полей:

- [help_text:](https://docs.djangoproject.com/en/2.1/ref/models/fields/#help-text) Предоставляет текстовую метку для HTML-форм (например, на сайте администратора), как описано выше.
- [verbose_name:](https://docs.djangoproject.com/en/2.1/ref/models/fields/#verbose-name) Удобочитаемое имя для поля, используемого в поле метки. Если не указано, Django выведет по умолчанию подробное название от имени поля.
- [default:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#default) Значение по умолчанию для поля. Это может быть значение или вызываемый объект, и в этом случае объект будет вызываться каждый раз, когда создаётся новая запись.
- [null:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#null) Если True, Django будет хранить пустые значения как NULL в базе данных для полей, где это уместно (CharField вместо этого сохранит пустую строку). По умолчанию используется значение False.
- [blank:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#blank) Если True, поле может быть пустым в ваших формах. По умолчанию используется значение False, что означает, что проверка формы Django заставит вас ввести значение. Это часто используется с null = True, потому что если вы хотите разрешить пустые значения, вы также хотите, чтобы база данных могла представлять их соответствующим образом.
- [choices:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#choices) Группа вариантов для этого поля. Если это предусмотрено, по умолчанию соответствующий виджет формы будет полем выбора с этими вариантами вместо стандартного текстового поля.
- [primary_key:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#primary-key) Если True, задаёт текущее поле в качестве первичного ключа для модели (первичный ключ - это специальный столбец базы данных, предназначенный для однозначной идентификации всех разных записей таблицы). Если в качестве первичного ключа не указано поле, Django автоматически добавит для этой цели поле.

Есть много других вариантов - вы можете просмотреть [full list of field options here](https://docs.djangoproject.com/en/2.2/ref/models/fields/).

[Назад к Django](#django)

### Общие типы полей

Следующие общие аргументы могут использоваться при объявлении многих / разных типов полей:

- [CharField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.CharField) Используется для определения строк фиксированной длины от короткой до средней. Вы должны указать max_length для хранения данных.
- [TextField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.TextField) используется для больших строк произвольной длины. Вы можете указать `max_length` для поля, но это используется только тогда, когда поле отображается в формах (оно не применяется на уровне базы данных).
- [IntegerField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.IntegerField) это поле для хранения значений (целого числа) и для проверки введённых значений в виде целых чисел в формах.
- [DateField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.DateField) и [DateTimeField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.DateTimeField) используются для хранения / представления дат и информации о дате / времени (как Python datetime.date и datetime.datetime, соответственно). Эти поля могут дополнительно объявлять (взаимоисключающие) параметры `auto_now=True` (для установки поля на текущую дату каждый раз, когда модель сохраняется), auto_now_add (только для установки даты, когда модель была впервые создана) и по умолчанию (чтобы установить дату по умолчанию, которую пользователь может переустановить).
- [EmailField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.EmailField) используется для хранения и проверки адресов электронной почты.
- [FileField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.FileField) и [ImageField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ImageField) используются для загрузки файлов и изображений соответственно (`ImageField` просто добавляет дополнительную проверку, что загруженный файл является изображением). Они имеют параметры для определения того, как и где хранятся загруженные файлы.
- [AutoField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.AutoField) - это особый тип IntegerField, который автоматически увеличивается. Первичный ключ этого типа автоматически добавляется в вашу модель, если вы явно не укажете его.
- [ForeignKey](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ForeignKey) Используется для указания отношения «один ко многим» к другой модели базы данных (например, автомобиль имеет одного производителя, но производитель может делать много автомобилей). «Одна» сторона отношения - это модель, содержащая ключ.
- [ManyToManyField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ManyToManyField) используется для определения отношения «многие ко многим» (например, книга может иметь несколько жанров, и каждый жанр может содержать несколько книг). В нашем приложении для библиотек мы будем использовать их аналогично ForeignKeys, но их можно использовать более сложными способами для описания отношений между группами. Они имеют параметр on_delete, чтобы определить, что происходит, когда связанная запись удаляется (например, значение `models.SET_NULL` просто установило бы значение NULL)

Существует много других типов полей, включая поля для разных типов чисел (большие целые числа, малые целые числа, дробные), логические значения, URL-адреса, slugs, уникальные идентификаторы и другие «связанные с временем» сведения (продолжительность, время и т. д.). Вы можете просмотреть [full list here](https://docs.djangoproject.com/en/1.10/ref/models/fields/#field-types).

[Назад к Django](#django)

### Метаданные

Вы можете объявить метаданные на уровне модели для своей модели, объявив класс Meta, как показано на рисунке.
```py
class Meta:
    ordering = ["-my_field_name"]
    ...
```

Одной из наиболее полезных функций этих метаданных является управление сортировка записей, возвращаемых при запросе типа модели. Вы можете сделать это, указав соответствия названия полей для сортировки, как показано выше. Порядок будет зависеть от типа поля (поля символов отсортированы в алфавитном порядке, а поля даты отсортированы в хронологическом порядке). Как показано выше, вы можете префикс имени поля минус-символом (`-`), чтобы изменить порядок сортировки.

Например, если мы решили сортировать книги по умолчанию:
```py
ordering = ["title", "-pubdate"]
```

Книги будут отсортированы по алфавиту по названию, от A-Z, а затем по дате публикации внутри каждого названия, от самого нового до самого старого.

Другим распространённым атрибутом является verbose_name, подробное имя для класса в единственной и множественной форме:
```py
verbose_name = "BetterName"
```

Другие полезные атрибуты позволяют создавать и применять новые «разрешения доступа» для модели (разрешения по умолчанию применяются автоматически), разрешить упорядочение на основе другого поля или объявить, что класс является «абстрактным» (базовый класс, для которого вы не можете создавать записи, и вместо этого будет создан для создания других моделей). Многие другие параметры метаданных управляют тем, какая база данных должна использоваться для модели и как хранятся данные (это действительно полезно, если вам нужно сопоставить модель с существующей базой данных). Полный список опций метаданных доступен здесь: [Model metadata options](https://docs.djangoproject.com/en/2.2/ref/models/options/#model-meta-options) (Django документация).

### Методы

Модель также может иметь методы. Минимально в каждой модели вы должны определить стандартный метод класса для Python `__str __ ()`, чтобы вернуть удобочитаемую строку для каждого объекта. Эта строка используется для представления отдельных записей на сайте администрирования (и в любом другом месте, где вам нужно обратиться к экземпляру модели). Часто это возвращает поле названия или имени из модели.
```py
Copy to Clipboard
def __str__(self):
    return self.field_name
```

Другим распространённым методом включения в модели Django является `get_absolute_url ()`, который возвращает URL-адрес для отображения отдельных записей модели на веб-сайте (если вы определяете этот метод, тогда Django автоматически добавит кнопку «Просмотр на сайте» на экранах редактирования записей модели на сайте администратора). Типичный шаблон для `get_absolute_url ()` показан ниже.
```py
def get_absolute_url(self):
    """
    Returns the url to access a particular instance of the model.
    """
    return reverse('model-detail-view', args=[str(self.id)])
```

> **Примечание:** Предполагается, что вы будете использовать URL-адреса, например **/myapplication/mymodelname/2**, для отображения отдельных записей для вашей модели (где «2» - это идентификатор для определённой записи), вам нужно будет создать URL-карту, чтобы передать ответ и идентификатор «Образцовое представление модели» (которое будет выполнять работу, необходимую для отображения записи). Вышеуказанная функция `reverse ()` может «перевернуть» ваш URL-адрес (в приведённом выше примере с именем «model-detail-view»), чтобы создать URL-адрес правильного формата.
>
>Конечно, для выполнения этой работы вам всё равно придётся писать сопоставление URL-адрес, просмотр и шаблон!

Вы также можете определить любые другие методы, которые вам нравятся, и вызывать их из вашего кода или шаблонов (при условии, что они не принимают никаких параметров).

[Назад к Django](#django)

### Управление моделью

После того, как вы определили свои классы моделей, вы можете использовать их для создания, обновления или удаления записей и для запуска запросов для получения всех записей или отдельных подмножеств записей. Мы покажем вам, как это сделать в учебнике, когда мы определяем наши представления, с кратким обзором.

- **Создание и изменение записей**

Чтобы создать запись, вы можете определить экземпляр модели, а затем вызвать метод `save()`.

```py
# Create a new record using the model's constructor.
a_record = MyModelName(my_field_name="Instance #1")

# Save the object into the database.
a_record.save()
```

> **Примечание:** Если вы не указали какое-либо поле в качестве primary_key, новая запись будет выдаваться автоматически, с идентификатором имени поля. Вы можете запросить это поле после сохранения указанной выше записи, и оно будет иметь значение 1.

Вы можете получить доступ к полям в этой новой записи с использованием синтаксиса точек и изменить значения. Вы должны вызвать `save()`, чтобы сохранить изменённые значения в базе данных.
```py
Copy to Clipboard
# Access model field values using Python attributes.
print(a_record.id) #should return 1 for the first record.
print(a_record.my_field_name) # should print 'Instance #1'

# Change record by modifying the fields, then calling save().
a_record.my_field_name="New Instance Name"
a_record.save()
```

- **Поиск записей**

Вы можете искать записи, соответствующие определённым критериям, используя атрибут объектов модели (предоставляемый базовым классом).

> **Примечание:** Объяснение того, как искать записи, используя «абстрактную» модель и имена полей, может быть немного запутанным. В приведённом ниже обсуждении мы будем ссылаться на модель книги с полями названия и жанра, где жанр также является моделью с единственным именем в поле.

Мы можем получить все записи для модели как объект **QuerySet**, используя `objects.all()`. **QuerySet** - это итерируемый объект, означающий, что он содержит несколько объектов, которые мы можем перебирать / прокручивать.
```py
all_books = Book.objects.all()
```

Метод `filter()` Django позволяет отфильтровать возвращаемый **QuerySet** для соответствия указанному текстовому или числовому полю по конкретным критериям. Например, чтобы отфильтровать книги, содержащие слово «wild» («дикие») в заголовке, а затем подсчитать их, мы могли бы сделать следующее.
```py
wild_books = Book.objects.filter(title__contains='wild')
number_wild_books = Book.objects.filter(title__contains='wild').count()
```

Соответствующие поля и тип соответствия определяются в имени параметра фильтра, используя формат: `field_name__match_type` (обратите внимание на двойное подчёркивание между заголовком выше). Выше мы фильтруем заголовок с учётом регистра. Есть много других типов совпадений, которые вы можете сделать: `icontains` (без учёта регистра), `iexact` (точное совпадение без учёта регистра), `exact` (точное совпадение с учётом регистра ) и `in`, `gt` (больше), `startswith` и т.д. [Смотреть полный список](https://docs.djangoproject.com/en/2.2/ref/models/querysets/#field-lookups) (Django Docs, [EN]).

В некоторых случаях вам нужно будет фильтровать поле, которое определяет отношение «один ко многим» к другой модели (например, `ForeignKey`). В этом случае вы можете «индексировать» поля в связанной модели с дополнительными двойными подчёркиваниями. Так, например, чтобы фильтровать книги с определённым жанровым рисунком, вам нужно будет указывать имя в поле жанра, как показано ниже:
```py
books_containing_genre = Book.objects.filter(genre__name__icontains='fiction')  # Will match on: Fiction, Science fiction, non-fiction etc.
```

> **Примечание:** Вы можете использовать символы подчёркивания (`__`) для навигации по многим уровням отношений (ForeignKey / ManyToManyField) по своему усмотрению. Например, книга, имеющая разные типы, определяемая с использованием дополнительной связи «обложка», может иметь имя параметра: type__cover__name__exact = 'hard'.

Существует гораздо больше возможностей для запросов, включая обратные поиски от связанных моделей, цепочки фильтров, возврат меньшего набора значений и т. д. Для получения дополнительной информации см. [Making queries](https://docs.djangoproject.com/en/2.2/topics/db/queries/) (Django Docs, [EN]).

[Назад к Django](#django)

### Определение моделей LocalLibrary

В этом разделе мы начнём определять модели для библиотеки. Откройте **models.py** (в / locallibrary / catalog /). Шаблон в верхней части страницы импортирует модуль моделей, который содержит базовый класс модели `models.Model`, от которого наследуются наши модели.
```py
from django.db import models

# Create your models here.
```

### Модель жанра

Скопируйте приведённый ниже код модели `Genre` и вставьте его в нижнюю часть вашего файла **models.py**. Эта модель используется для хранения информации о категории книг - например, будь то художественная или документальная, роман или военно-историческая и т. д. Как уже упоминалось выше, мы создали жанр как модель, а не как свободный текст или список выбора, чтобы возможные значения могли управляться через базу данных, а не были закодированными.
```py
Copy to Clipboard
class Genre(models.Model):
    """
    Model representing a book genre (e.g. Science Fiction, Non Fiction).
    """
    name = models.CharField(max_length=200, help_text="Enter a book genre (e.g. Science Fiction, French Poetry etc.)")

    def __str__(self):
        """
        String for representing the Model object (in Admin site etc.)
        """
        return self.name
```

Модель имеет один `CharField` field (имя), которое используется для описания жанра (оно ограничено 200 символами и имеет некоторый `help_text`. В конце модели мы объявляем метод `__str__()`, который просто возвращает имя жанра, определённого конкретной записью. Verbose name не был определён, поэтому поле будет называться `Name` в формах.

[Назад к Django](#django)

### Модель книги

Скопируйте модель книги ниже и снова вставьте её в нижнюю часть файла. Модель книги представляет всю информацию о доступной книге в общем смысле, но не конкретный физический «экземпляр» или «копию» для временного использования. Модель использует CharField для представления названия книги и isbn (обратите внимание, как isbn указывает свой ярлык как «ISBN», используя первый неименованный параметр, поскольку в противном случае ярлык по умолчанию был бы «Isbn»). Модель использует TextField для summary, потому что этот текст, возможно, должен быть очень длинным.
```py
from django.urls import reverse #Used to generate URLs by reversing the URL patterns

class Book(models.Model):
    """
    Model representing a book (but not a specific copy of a book).
    """
    title = models.CharField(max_length=200)
    author = models.ForeignKey('Author', on_delete=models.SET_NULL, null=True)
    # Foreign Key used because book can only have one author, but authors can have multiple books
    # Author as a string rather than object because it hasn't been declared yet in the file.
    summary = models.TextField(max_length=1000, help_text="Enter a brief description of the book")
    isbn = models.CharField('ISBN',max_length=13, help_text='13 Character <a href="https://www.isbn-international.org/content/what-isbn">ISBN number</a>')
    genre = models.ManyToManyField(Genre, help_text="Select a genre for this book")
    # ManyToManyField used because genre can contain many books. Books can cover many genres.
    # Genre class has already been defined so we can specify the object above.

    def __str__(self):
        """
        String for representing the Model object.
        """
        return self.title


    def get_absolute_url(self):
        """
        Returns the url to access a particular book instance.
        """
        return reverse('book-detail', args=[str(self.id)])
```

Жанр представляет из себя `ManyToManyField`, так что книга может иметь несколько жанров, а жанр может иметь много книг. Автор объявляется через `ForeignKey`, поэтому в каждой книге будет только один автор, но у автора может быть много книг (на практике книга может иметь несколько авторов, но не в такой реализации!)

В обоих типах полей соответствующий класс модели объявляется как первый неименованный параметр, используя либо класс модели, либо строку, содержащую имя соответствующей модели. Вы должны использовать имя модели как строку, если связанный класс ещё не был определён в этом файле до того, как он будет указан! Другими параметрами, представляющими интерес для поля автора, являются `null=True`, которое позволяет базе данных хранить значение `Null` , если автор не выбран, и on_delete = models. `SET_NULL` установит значение автора в Null, если связанная с автором запись будет удалена.

Модель также определяет `__str __()`, используя поле заголовка книги для представления книги. Окончательный метод `get_absolute_url()` возвращает URL-адрес, который можно использовать для доступа к подробной записи для этой модели (для этого нам нужно будет определить сопоставление URL-адресов, в котором содержится подробная информация о книге, и определить связанное представление и шаблон ).

[Назад к Django](#django)

### Модель BookInstance

Затем скопируйте модель BookInstance (показано ниже) под другие модели. BookInstance представляет собой определённую копию книги, которую кто-то может брать взаймы, и включает информацию о том, доступна ли копия или в какой день она ожидается, «отпечаток» или сведения о версии, а также уникальный идентификатор книги в библиотеке. Теперь некоторые из полей и методов будут знакомы. Модель использует

- `ForeignKey` для идентификации связанной книги (в каждой книге может быть много копий, но в копии может быть только одна книга).
- `CharField`, для представления данных (конкретного выпуска) о книге.
```py
import uuid # Required for unique book instances

class BookInstance(models.Model):
    """
    Model representing a specific copy of a book (i.e. that can be borrowed from the library).
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, help_text="Unique ID for this particular book across whole library")
    book = models.ForeignKey('Book', on_delete=models.SET_NULL, null=True)
    imprint = models.CharField(max_length=200)
    due_back = models.DateField(null=True, blank=True)

    LOAN_STATUS = (
        ('m', 'Maintenance'),
        ('o', 'On loan'),
        ('a', 'Available'),
        ('r', 'Reserved'),
    )

    status = models.CharField(max_length=1, choices=LOAN_STATUS, blank=True, default='m', help_text='Book availability')

    class Meta:
        ordering = ["due_back"]


    def __str__(self):
        """
        String for representing the Model object
        """
        return '%s (%s)' % (self.id,self.book.title)
```

Мы дополнительно объявляем несколько новых типов полей:

- `UUIDField` используется для поля **id**, чтобы установить его как **primary_key** для этой модели. Этот тип поля выделяет глобальное уникальное значение для каждого экземпляра (по одному для каждой книги, которую вы можете найти в библиотеке).
- `DateField` используется для данных **due_back** (при которых ожидается, что книга появится после заимствования или обслуживания). Это значение может быть `blank` или `null` (необходимо, когда книга доступна). Метаданные модели (Class Meta) используют это поле для упорядочивания записей, когда они возвращаются в запросе.
- status - это `CharField`, который определяет список **choice/selection**. Как вы можете видеть, мы определяем кортеж, содержащий кортежи пар ключ-значение и передаём его аргументу выбора. Значение в **key/value** паре - это отображаемое значение, которое пользователь может выбрать, а ключи - это значения, которые фактически сохраняются, если выбрана опция. Мы также установили значение по умолчанию **«m»** (техническое обслуживание), поскольку книги изначально будут созданы недоступными до того, как они будут храниться на полках.

Модель `__str__()` представляет объект BookInstance, используя комбинацию его уникального идентификатора и связанного с ним заголовка книги.

> **Примечание:** Немного о Python:
> Значение, возвращаемое `__str__()`, является форматированной строкой. В строке мы используем `%S` для объявления 'placeholders'. После строки укажем `%`, а затем кортеж, содержащий значения, которые будут вставлены в заполнители. Если у вас просто один заполнитель, вы можете опустить кортеж - например, 'Моё значение:% S' % переменная.
>
> Обратите также внимание на то, что, хотя этот подход совершенно применим, но он более не является предпочтительным. Начиная с Python 3, вы должны использовать метод format, например. `'{0} ({1})'.format(self.id, self.book.title)`. Вы можете узнать больше об этом [здесь](https://www.python.org/dev/peps/pep-3101/).

### Модель автора

Скопируйте модель автора (показано ниже) под существующим кодом в **models.py**.

Теперь все поля/методы должны быть знакомы. Модель определяет автора как имя, фамилию, дату рождения и (необязательную) дату смерти. Он указывает, что по умолчанию `__str__()` возвращает имя в фамилии, порядковый номер первого имени. Метод `get_absolute_url()` отменяет сопоставление URL-адреса автора с целью получения URL-адреса для отображения отдельного автора.
```py
class Author(models.Model):
    """
    Model representing an author.
    """
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    date_of_birth = models.DateField(null=True, blank=True)
    date_of_death = models.DateField('Died', null=True, blank=True)

    def get_absolute_url(self):
        """
        Returns the url to access a particular author instance.
        """
        return reverse('author-detail', args=[str(self.id)])


    def __str__(self):
        """
        String for representing the Model object.
        """
        return '%s, %s' % (self.last_name, self.first_name)
```

### Повторно выполнить миграцию базы данных

Теперь все ваши модели созданы. Теперь переустановите миграцию базы данных, чтобы добавить их в свою базу данных.
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

### Языковая модель - вызов

Представьте себе, что местный благотворитель жертвует ряд новых книг, написанных на другом языке (скажем, фарси). Задача состоит в том, чтобы определить, как они будут лучше всего представлены на нашем веб-сайте библиотеки, а затем добавить их в модели.

Некоторые вещи, которые следует учитывать:

- Должен ли «язык» ассоциироваться с Book, BookInstance или каким-либо другим объектом?
- Должны ли быть представлены разные языки с использованием модели, свободного текстового поля или жёстко запрограммированного списка выбора?
После того, как вы решили, добавьте поле. Вы можете увидеть наше решение на Github [here](https://github.com/mdn/django-locallibrary-tutorial/blob/master/catalog/models.py).

### Итог

В этой статье мы узнали, как определять модели, а затем использовать эту информацию в разработке и внедрении соответствующих моделей для сайта LocalLibrary.

На этом этапе мы отвлечёмся от создания сайта и проверим **Django Administration site**. Этот сайт позволит нам добавить некоторые данные в библиотеку, которые мы можем отобразить с помощью наших (ещё не созданных) представлений и шаблонов.

Смотрите также
[Writing your first Django app, part 2](https://docs.djangoproject.com/en/1.10/intro/tutorial02/) (Django Docs)
[Making queries](https://docs.djangoproject.com/en/1.10/topics/db/queries/) (Django Docs)
[QuerySet API Reference](https://docs.djangoproject.com/en/1.10/ref/models/querysets/) (Django Docs)


[Назад к Django](#django)

## Django 4: административная панель Django

Теперь, когда модели для сайта [местной библиотеки](#django-сайт-местной-библиотеки) созданы, добавим некоторые "настоящие" данные о книгах, используя административную панель Django Admin. Для начала мы покажем, как зарегистрировать в ней модели, потом как войти и создать какие-нибудь данные. В конце статьи мы покажем некоторые способы дальнейшего улучшения вида админ-панели.

|Предусловия: |	Сначала завершите: [Руководство часть 3:](#django-3-использование-моделей) использование моделей.
|----|----
|Цель: | Уяснить преимущества и ограничения админ-панели Django, научиться использовать её для создания записей для наших моделей.

### Обзор

*Приложение* **Django admin** может использовать ваши модели для автоматического создания части сайта, предназначенной для создания, просмотра, обновления и удаления записей. Это может сэкономить вам много времени в процессе разработки, упрощая тестирование ваших моделей на предмет правильности данных. Оно также может быть полезным для управления данными на стадии публикации, в зависимости от типа веб-сайта. Проект Django рекомендует это приложение только для управления внутренними данными (т.е.для использования администраторами, либо людьми внутри вашей организации), так как модельно-ориентированный подход не обязательно является наилучшим интерфейсом для всех пользователей и раскрывает много лишних подробностей о моделях.

Все необходимые настройки, которые необходимо включить в admin приложение вашего веб-сайта, были сделаны автоматически, когда вы [создали каркас проекта](#django-2-создание-скелета) (информацию о необходимых актуальных зависимостях смотрите здесь - [Django docs](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/)) . В результате все, что необходимо сделать для того, чтобы добавить модели в приложение admin, это *зарегистрировать* их. В конце этой статьи мы представим краткую демонстрацию того, каким образом можно дополнительно настроить админ-панель для лучшего отображения данные наших моделей.

После регистрации моделей мы покажем как создать нового суперпользователя , войти на сайт от его имени и создать книги, авторов, экземпляры книг и жанры. Это будет полезным для тестирования представлений и шаблонов, которые мы начнём создавать в следующей части руководства.

### Регистрация моделей

Вначале откройте файл **admin.py** в папке приложения (**/locallibrary/catalog/admin.py**). Пока он выглядит так (заметьте, что он уже содержит импорт `django.contrib.admin`):

```py
from django.contrib import admin

# Register your models here.
```

Зарегистрируйте модели путём вставки следующего текста в нижнюю часть этого файла. Этот код просто импортирует модели и затем вызывает `admin.site.register` для регистрации каждой из них.
```py
from .models import Author, Genre, Book, BookInstance

admin.site.register(Book)
admin.site.register(Author)
admin.site.register(Genre)
admin.site.register(BookInstance)
```

> **Примечание:** В строках выше предполагается, что вы приняли вызов создать модель, отражающую естественный язык книги ([см. обучающую статью о моделях](#django-3-использование-моделей))!

Это самый простой способ регистрации модели или моделей. Админ-панель имеет множество настроек. Мы рассмотрим другие способы регистрации ваших моделей ниже.

[Назад к Django](#django)

### Создание суперпользователя

Для того, чтобы войти в админ-панель, нам необходимо иметь учётную запись пользователя со статусом *Staff (сотрудники)*. Для просмотра и создания записей, пользователю также понадобится разрешение для управления всеми нашими объектами. Вы можете создать учётную запись **"superuser"**, которая даёт полный доступ к сайту и все необходимые разрешения, используя **manage.py**.

Для создания суперпользователя вызовите следующую команду из той же папки, где расположен **manage.py**. Вас попросят ввести имя пользователя, адрес электронной почты и надёжный пароль.
```bash
python3 manage.py createsuperuser
```

После выполнения этой команды новый суперпользователь будет добавлен в базу данных. Теперь перезапустите сервер, чтобы можно было протестировать вход на сайт:
```bash
python3 manage.py runserver
```

### Вход в админ-панель и её использование

Для входа в админ-панель откройте ссылку `/admin` (например `http://127.0.0.1:8000/admin`) и введите логин и пароль вашего нового суперпользователя (вас перенаправят на login-страницу и потом обратно на /admin после ввода всех деталей).

В этой части сайта отображаются все наши модели, сгруппированные по установленному приложению. Вы можете кликнуть на названии модели, чтобы получить список всех связанных записей, далее можете кликнуть на этих записях, для их редактирования . Также можно непосредственно кликнуть на ссылку **Add**, расположенную рядом с каждой моделью, чтобы начать создание записи этого типа.

![admin panel](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_home.png)

Кликните на ссылке **Add** справа от *Books*, чтобы создать новую книгу (появится диалоговое окно как на картинке внизу). Заметьте, что заголовок каждого поля - это тип используемого виджета, и `help_text` (если есть) совпадает со значением, которое вы указали в модели.

Введите значение для полей. Вы можете создавать новых авторов или жанры, нажимая на значок "`+`", расположенный рядом с соответствующим полем (или выберите существующее значение из списков, если вы уже создали их). Когда вы закончили, нажмите на **SAVE, Save and add another**, или **Save and continue editing**, чтобы сохранить записи.

![add book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_add.png)

> **Примечание:** А сейчас, хотелось бы, чтобы вы добавили несколько книг, авторов и жанров (например, Фэнтези) в ваше приложение. Удостоверьтесь, что каждый автор и жанр включает пару различных книг (позже, когда мы реализуем представления "list" и "detail", это сделает их более интересными).

После того, когда книги добавлены, для перехода на главную страницу админ-панели кликните на ссылке **Home** в верхней части страницы. Потом кликните на ссылке **Books** для отображения текущего списка книг (или на одной из других ссылок, чтобы увидеть список соответствующей модели). После добавления нескольких книг список может выглядеть наподобие скриншота ниже. Отображается название каждой из книг. Его возвращает метод `__str__()` в модели Book, созданной в предыдущей статье.

![add books](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_list.png)

Для удаления книги из этого списка выберите чекбокс рядом с ней и действие *delete*... из выпадающего списка *Action*, а затем нажмите кнопку **Go**. Также можно добавить новую книгу, нажав на кнопку **ADD BOOK**.

Вы можете редактировать книгу, кликнув по ссылке с её названием. Страница редактирования книги, приведённая ниже, практически идентична странице добавления новой книги. Основные отличия - это заголовок страницы (*Change book*) и наличие кнопок **Delete**, **HISTORY** и **VIEW ON SITE**. Последняя присутствует, так как мы определили метод `get_absolute_url()` в нашей модели.

![edit book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_modify.png)

Теперь перейдите назад на страницу **Home** (используя ссылку *Home* в навигационной цепочке вверху страницы) и просмотрите списки **Author** и **Genre**. В них уже должно быть несколько элементов, созданных при добавлении новых книг. Если хотите, добавьте ещё.

Однако у вас не будет ни одного экземпляра книги, потому что они не создаются из модели `Book` (хотя можно создать книгу из модели `BookInstance` — такова природа поля `ForeignKey`). Для отображения страницы *Add book instance* (см. рисунок ниже) вернитесь на страницу *Home* и нажмите кнопку **Add**. Обратите внимание на длинный уникальный **Id** для идентификации конкретного экземпляра книги в библиотеке.

![book instance](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_bookinstance_add.png)

Создайте несколько экземпляров для каждой из ваших книг. Установите статус *Available (доступен*) для некоторых экземпляров и *On loan (выдан)* для остальных. Если статус экземпляра **not** *Available (недоступен)*, то также установите дату возврата (*Due back*).

Вот и все! Вы изучили как запустить и использовать админ-панель. Также были созданы записи для `Book`, `BookInstance`, `Genre` и `Author`, которые можно будет использовать после создания наших собственных представлений и шаблонов.

[Назад к Django](#django)

### "Продвинутая" конфигурация

Django выполняет неплохую работу по созданию базовой админ-панели используя информацию из зарегистрированных моделей:

- Каждая модель имеет список записей, каждая из которых идентифицируется строкой, создаваемой методом `__str__()` модели, и связана с представлением для её редактирования. По умолчанию, в верхней части этого представления находится меню действий, которое может быть использовано для удаления нескольких записей за раз
- Формы для редактирования и добавления записей содержат все поля модели, которые расположены вертикально в порядке их объявления в модели.

Можно настроить интерфейс пользователя для упрощения его использования. Некоторые доступные настройки:

- List views:
  - добавление дополнительных отображаемых полей или информации для каждой записи.
  - добавление фильтров для отбора записей по разным критериям (например, статус выдачи книги).
  - добавление дополнительных вариантов выбора в меню действий и места расположения этого меню на форме.

- Detail views
  - выбор отображаемых полей, их порядка, группирования и т.д.
  - добавление связанных полей к записи (например, возможности добавления и редактирования записей книг при создании записи автора).

В этом разделе рассмотрим некоторые изменения для совершенствования интерфейса пользователя нашей местной библиотеки, а именно: добавление дополнительной информации в списки моделей `Book` и `Author` , а также улучшение расположения элементов соответствующих представлений редактирования. Пользовательский интерфейс моделей `Language` and `Genre` изменять не будем, так как это не даст заметного улучшения, поскольку он содержит только по одному полю!

Полное руководство по всем возможным вариантам настройки админ-панели можно найти в The [Django Admin site](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/) (документация Django).

### Регистрация класса ModelAdmin

Для изменения отображения модели в пользовательском интерфейсе админ-панели, необходимо определить класс [ModelAdmin](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#modeladmin-objects) (он описывает расположение элементов интерфейса, где Model - наименование модели) и зарегистрировать его для использования с этой моделью.

Давайте начнём с модели Author. Откройте файл **admin.py** в каталоге приложения (**/locallibrary/catalog/admin.py**). Закомментируйте исходную регистрацию (используя префикс #) этой модели:
```js
# admin.site.register(Author)
```

Теперь добавьте новый класс `AuthorAdmin` и зарегистрируйте его как показано ниже:
```py
# Define the admin class
class AuthorAdmin(admin.ModelAdmin):
    pass

# Register the admin class with the associated model
admin.site.register(Author, AuthorAdmin)
```

Сейчас мы добавим классы `ModelAdmin` для моделей `Book`, и `BookInstance`. Нам снова нужно закомментировать исходную регистрацию:
```js
# admin.site.register(Book)
# admin.site.register(BookInstance)
```

В этот раз для создания и регистрации новых моделей используем декоратор `@register` (он делает то же самое, что и метод `admin.site.register()`):
```py
# Register the Admin classes for Book using the decorator

@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    pass

# Register the Admin classes for BookInstance using the decorator

@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    pass
```

Пока что все наши admin-классы пустые (см. "`pass`"), поэтому ничего не изменится! Добавим код для задания особенностей интерфейса моделей.

[Назад к Django](#django)

### Настройка отображения списков

Сейчас приложение *LocalLibrary* отображает всех авторов, используя имя объекта, возвращаемое методом `__str__()` модели. Это приемлемо, когда есть только несколько авторов, но, если их количество значительно, возможны дубликаты. Чтобы различить их или просто отобразить более интересную информацию о каждом авторе, можно использовать [list_display](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display) (для добавления дополнительных полей).

Замените класс `AuthorAdmin` кодом, приведённым ниже. Названия полей, которые будут отображаться в списке, перечислены в кортеже **list_display** в требуемом порядке (это те же имена, что и в исходной модели).
```py
Copy to Clipboard
class AuthorAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'date_of_birth', 'date_of_death')
```

Перезапустите сайт и перейдите к списку авторов. Указанные поля должны отображаться следующим образом:

![autors list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_author_list.png)

Для нашей модели `Book` добавим отображение полей `author` и `genre`. Поле `author` - это внешний ключ (`ForeignKey` ) связи один к одному, поэтому оно будет представлено значением `__str()__` для связанной записи. Замените класс `BookAdmin` на версию, приведённую ниже.
```py
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'display_genre')
```

К сожалению, мы не можем напрямую поместить поле genre в `list_display`, так как оно является `ManyToManyField` (Django не позволяет это из-за большой "стоимости" доступа к базе данных). Вместо этого мы определим функцию `display_genre` для получения строкового представления информации (вызов этой функции есть в `list_display`, её определение см. ниже).

> **Примечание:** Получение здесь значения поля `genre` возможно не самая хорошая идея вследствие "стоимости" операции базы данных. Мы показываем это, потому что вызов функций в ваших моделях может быть очень полезен по другим причинам, например, для добавления ссылки *Delete* рядом с каждым пунктом списка.

Добавьте следующий код в вашу модель `Book` (**models.py**). В нем создаётся строка из первых трёх значений поля `genre` (если они существуют) и `short_description`, которое может быть использовано в админ-панели.
```py
    def display_genre(self):
        """
        Creates a string for the Genre. This is required to display genre in Admin.
        """
        return ', '.join([ genre.name for genre in self.genre.all()[:3] ])
    display_genre.short_description = 'Genre'
```

После сохранения модели и обновления админ-панели, перезапустите её и перейдите на страницу списка *Books*. Вы должны увидеть список книг, наподобие приведённого ниже:

![books](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_book_list.png)

Модель `Genre` (и модель `Language`, если вы её определили) имеет единственное поле. Поэтому нет необходимости создания для них дополнительных моделей с целью отображения дополнительных полей.

> **Примечание:** Целесообразно, чтобы в списке модели `BookInstance` отображались хотя бы статус и ожидаемая дата возврата. Мы добавили это в качестве "испытания" в конце этой статьи!

[Назад к Django](#django)

### Добавление фильтров списка

Если в вашем списке есть множество элементов, может быть полезной возможность фильтрации отображаемых пунктов. Это выполняется путём перечисления их в атрибуте `list_filter`. Замените класс `BookInstanceAdmin` на следующий:
```py
class BookInstanceAdmin(admin.ModelAdmin):
    list_filter = ('status', 'due_back')
```

Представление списка теперь будет содержать панель фильтрации справа. Обратите внимание, как выбирать даты и статус для фильтрации:

![filter panel](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_bookinstance_list_filters.png)

### Формирование макета с подробным представлением

По умолчанию в представлениях деталей отображаются все поля по вертикали в порядке их объявления в модели. Вы можете изменить порядок декларации, какие поля отображаются (или исключены), используются ли разделы для организации информации, отображаются ли поля горизонтально или вертикально, и даже какие виджеты редактирования используются в админ-формах.

> **Примечание:** Модели LocalLibrary относительно просты, поэтому нам не нужно менять макет, но мы всё равно внесём некоторые изменения, просто чтобы показать вам, как это сделать.

### Управление отображаемыми и вложенными полями

Обновите ваш AuthorAdmin класс, чтобы добавить строку полей, как показано ниже:
```py
class AuthorAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'date_of_birth', 'date_of_death')
    fields = ['first_name', 'last_name', ('date_of_birth', 'date_of_death')]
```

Атрибут полей перечисляет только те поля, которые должны отображаться в форме, по порядку. Поля отображаются по вертикали по умолчанию, но будут отображаться горизонтально, если вы дополнительно группируете их в кортеже (как показано в полях «date» выше).

Перезагрузите приложение и перейдите к подробному представлению автора - он должен теперь отображаться, как показано ниже:

![change autor](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_author_detail.png)

> **Примечание:** Так же, вы можете использовать `exclude` атрибут для объявления списка атрибутов, которые будут исключены из формы (все остальные атрибуты в модели, будут отображаться).

[Назад к Django](#django)

### Разделение на секции/Выделение подробного представления

Вы можете добавлять "разделы" (sections) для группировки связанной информации в модели в форме детализации, используя атрибут [fieldsets](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.fieldsets) .

В модели `BookInstance` мы имеем информацию соответствия конкретной книги (т.е. `name`, `imprint`, and `id`) и датой когда она вновь станет доступной (`status`, `due_back`). Мы можем добавить их в разные секции, добавив текст жирным шрифтом в наш `BookInstanceAdmin` класс.
```py
@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    list_filter = ('status', 'due_back')

    fieldsets = (
        (None, {
            'fields': ('book','imprint', 'id')
        }),
        ('Availability', {
            'fields': ('status', 'due_back')
        }),
    )
```

Каждая секция имеет свой заголовок (или `None`, если заголовок не нужен) и ассоциированный кортеж полей в словаре - формат сложный для описания, но относительно простой для понимания, если вы посмотрите на фрагмент кода, представленный выше.

Перезапустите сайт и перейдите к списку экземпляров; форма должна отображаться следующим образом:

![instace list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_bookinstance_detail_sections.png)

### Встроенное редактирование связанных записей

Иногда бывает полезно иметь возможность добавлять связанные записи одновременно. Например, имеет смысл иметь как информацию о книге, так и информацию о конкретных копиях, которые вы получили на той же странице подробностей. К примеру, вполне логично получить и информацию о книге, и информацию о конкретных копиях, зайдя на страницу детализации.

Вы можете это сделать, объявив [inlines](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.inlines), и указав тип [TabularInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.TabularInline) (горизонтальное расположение) или [StackedInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.StackedInline) (вертикальное расположение, так же как и в модели по умолчанию). Вы можете добавить `BookInstance` информацию в подробное описание `Book` , добавив строки, представленные ниже и располагающиеся рядом с `BookAdmin`:
```py
class BooksInstanceInline(admin.TabularInline):
    model = BookInstance

@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'display_genre')
    inlines = [BooksInstanceInline]
```

Попробуйте перезапустить приложение, а затем взгляните на представление книги — внизу вы должны увидеть экземпляры книги, относящиеся к этой книге:

![book instance](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_book_detail_inlines.png)

В этом случае, всё, что мы сделали - объявили наш встроенный класс tablular, который просто добавляет все поля из встроенной модели. Вы можете указать все виды дополнительной информации для макета, включая отображаемые поля, их порядок, независимо от того, являются ли они только для чтения или нет, и т. д. (См. [TabularInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.TabularInline) для получения дополнительной информации).

> **Примечание:** В этой функции есть некоторые неприятные ограничения! На скриншоте выше у нас есть три существующих экземпляра книги, за которыми следуют три поля для новых экземпляров книги (которые очень похожи!). Было бы лучше НЕ иметь лишних экземпляров книг по умолчанию и просто добавить их с помощью ссылки **Add another Book instance** или иметь возможность просто перечислять `BookInstances` как нечитаемые здесь ссылки. Первый вариант можно сделать, установив `extra` атрибут в 0 в модели `BookInstanceInline`, попробуйте сами.

[Назад к Django](#django)

### Проверьте себя

Мы многое изучили в этом разделе и теперь настало время вам самостоятельно попробовать несколько вещей:

1. Для представления списка `BookInstance` , добавьте код для отображения книги, статуса, даты возврата, и id (вместо значения по умолчанию возвращаемого `__str__()`).
2. Добавьте встроенный список перечня `Book` в представление списка `Author` , используя тот же самый подход, который мы применили для `Book`/`BookInstance`.

### Заключение

Вот и всё! Теперь вы узнали, как настроить сайт администрирования как в самой простой, так и в улучшенной форме, о создании суперпользователя и о том, как перемещаться по сайту администратора, просматривать, удалять и обновлять записи. По пути вы создали множество книг, экземпляров, жанров и авторов, которые мы сможем перечислить и отобразить, как только мы создадим собственный вид и шаблоны.

Дополнительные материалы

- [Writing your first Django app, part 2: Introducing the Django Admin](https://docs.djangoproject.com/en/1.10/intro/tutorial02/#introducing-the-django-admin) (Django docs)
- [The Django Admin site](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/) (Django Docs)

[Назад к Django](#django)


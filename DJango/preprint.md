# Django 
[Источник](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Introduction)

- [Django](#django)
  - [Введение](#введение)
    - [Как выглядит код Django?](#как-выглядит-код-django)
    - [Отправка запроса в правильное view (urls.py)](#отправка-запроса-в-правильное-view-urlspy)
    - [Обработка запроса (views.py)](#обработка-запроса-viewspy)
    - [Определение данных модели (models.py)](#определение-данных-модели-modelspy)
    - [Запросы данных (views.py)](#запросы-данных-viewspy)
    - [Вывод данных (HTML-шаблоны)](#вывод-данных-html-шаблоны)
    - [Что ещё можно сделать?](#что-ещё-можно-сделать)
    - [Резюме](#резюме)
  - [Setting up a Django development environment](#setting-up-a-django-development-environment)
    - [Обзор среды разработки Django](#обзор-среды-разработки-django)
    - [Разновидности установки Django](#разновидности-установки-django)
    - [Установка Python 3](#установка-python-3)
    - [Использование Django внутри виртуальной среды Python](#использование-django-внутри-виртуальной-среды-python)
    - [Установка ПО виртуальной среды](#установка-по-виртуальной-среды)
    - [Создание и использование виртуальной среды](#создание-и-использование-виртуальной-среды)
    - [Установка Django, проверка установки](#установка-django-проверка-установки)
    - [Заключение](#заключение)
  - [Django: сайт местной библиотеки](#django-сайт-местной-библиотеки)
    - [Обзор руководства](#обзор-руководства)
    - [Сайт местной библиотеки](#сайт-местной-библиотеки)
  - [Django 2: создание скелета](#django-2-создание-скелета)
    - [Обзор](#обзор)
    - [Создание проекта](#создание-проекта)
    - [Создание приложения Каталог](#создание-приложения-каталог)
    - [Регистрация папки с приложением](#регистрация-папки-с-приложением)
    - [Настройка базы данных](#настройка-базы-данных)
    - [Другие настройки проекта](#другие-настройки-проекта)
    - [Подключение URL-адреса](#подключение-url-адреса)
    - [Тестирование работы скелета](#тестирование-работы-скелета)
    - [Запуск сайта](#запуск-сайта)
  - [Django 3: использование моделей](#django-3-использование-моделей)
    - [Обзор](#обзор-1)
    - [Проектирование моделей LocalLibrary](#проектирование-моделей-locallibrary)
    - [Модель для начинающих](#модель-для-начинающих)
    - [Определение модели](#определение-модели)
    - [Поля](#поля)
    - [Общие аргументы поля](#общие-аргументы-поля)
    - [Общие типы полей](#общие-типы-полей)
    - [Метаданные](#метаданные)
    - [Методы](#методы)
    - [Управление моделью](#управление-моделью)
    - [Определение моделей LocalLibrary](#определение-моделей-locallibrary)
    - [Модель жанра](#модель-жанра)
    - [Модель книги](#модель-книги)
    - [Модель BookInstance](#модель-bookinstance)
    - [Модель автора](#модель-автора)
    - [Повторно выполнить миграцию базы данных](#повторно-выполнить-миграцию-базы-данных)
    - [Языковая модель - вызов](#языковая-модель---вызов)
    - [Итог](#итог)
  - [Django 4: административная панель Django](#django-4-административная-панель-django)
    - [Обзор](#обзор-2)
    - [Регистрация моделей](#регистрация-моделей)
    - [Создание суперпользователя](#создание-суперпользователя)
    - [Вход в админ-панель и её использование](#вход-в-админ-панель-и-её-использование)
    - ["Продвинутая" конфигурация](#продвинутая-конфигурация)
    - [Регистрация класса ModelAdmin](#регистрация-класса-modeladmin)
    - [Настройка отображения списков](#настройка-отображения-списков)
    - [Добавление фильтров списка](#добавление-фильтров-списка)
    - [Формирование макета с подробным представлением](#формирование-макета-с-подробным-представлением)
    - [Управление отображаемыми и вложенными полями](#управление-отображаемыми-и-вложенными-полями)
    - [Разделение на секции/Выделение подробного представления](#разделение-на-секциивыделение-подробного-представления)
    - [Встроенное редактирование связанных записей](#встроенное-редактирование-связанных-записей)
    - [Проверьте себя](#проверьте-себя)
    - [Заключение](#заключение-1)
  - [Django 5: cоздание домашней страницы](#django-5-cоздание-домашней-страницы)
    - [Обзор](#обзор-3)
    - [Определяем URL-адреса страниц](#определяем-url-адреса-страниц)
    - [Создание главной страницы сайта](#создание-главной-страницы-сайта)
    - [URL-преобразование](#url-преобразование)
    - [Отображения (на основе функций)](#отображения-на-основе-функций)
    - [Шаблон](#шаблон)
    - [Расширение шаблонов](#расширение-шаблонов)
    - [Базовый шаблон сайта LocalLibrary](#базовый-шаблон-сайта-locallibrary)
    - [Индексный шаблон (шаблон главной страницы сайта)](#индексный-шаблон-шаблон-главной-страницы-сайта)
    - [Ссылка на статические файлы их шаблонов](#ссылка-на-статические-файлы-их-шаблонов)
    - [Построение URL-адресов](#построение-url-адресов)
    - [Как теперь все это выглядит?](#как-теперь-все-это-выглядит)
    - [Проверьте себя](#проверьте-себя-1)
    - [Итог](#итог-1)
  - [Django 6: отображение списков и детальной информации](#django-6-отображение-списков-и-детальной-информации)
    - [Обзор](#обзор-4)
    - [Страница со списком книг](#страница-со-списком-книг)
    - [Преобразования URL-адресов](#преобразования-url-адресов)
    - [Отображение (на основе базового класса)](#отображение-на-основе-базового-класса)
    - [Переопределение методов в классах отображения](#переопределение-методов-в-классах-отображения)
    - [Создание шаблона Отображения Списка](#создание-шаблона-отображения-списка)
    - [Условные ветвления](#условные-ветвления)
    - [Цикл For](#цикл-for)
    - [Доступ к переменным](#доступ-к-переменным)
    - [Обновление базового шаблона](#обновление-базового-шаблона)
    - [Страница с подробной информацией о книге](#страница-с-подробной-информацией-о-книге)
    - [URL-преобразования](#url-преобразования)
    - [Отдельный пример с регулярными выражениями](#отдельный-пример-с-регулярными-выражениями)
    - [Передача дополнительных настроек в ваши преобразования URL-адресов](#передача-дополнительных-настроек-в-ваши-преобразования-url-адресов)
    - [Отображение (на основе класса)](#отображение-на-основе-класса)
    - [Создание шаблона детальной информации](#создание-шаблона-детальной-информации)
    - [Как это теперь выглядит?](#как-это-теперь-выглядит)
    - [Постраничный вывод (Pagination)](#постраничный-вывод-pagination)
    - [Отображения](#отображения)
    - [Шаблоны](#шаблоны)
    - [Как это выглядит?](#как-это-выглядит)
    - [Проверьте себя](#проверьте-себя-2)
    - [Итоги](#итоги)
  - [Django 7: сессии](#django-7-сессии)
    - [Обзор](#обзор-5)
    - [Что такое сессии?](#что-такое-сессии)
    - [Подключение сессий](#подключение-сессий)
    - [Применение сессий](#применение-сессий)
    - [Хранение данных сессии](#хранение-данных-сессии)
    - [Простой пример — получение числа визитов](#простой-пример--получение-числа-визитов)
  - [Django 8: аутентификация и авторизация пользователя](#django-8-аутентификация-и-авторизация-пользователя)

## Введение

**Django** — это высокоуровневый Python веб-фреймворк, который позволяет быстро создавать безопасные и поддерживаемые веб-сайты. Созданный опытными разработчиками, Django берёт на себя большую часть хлопот веб-разработки, поэтому вы можете сосредоточиться на написании своего веб-приложения без необходимости изобретать велосипед. Он бесплатный и с открытым исходным кодом, имеет растущее и активное сообщество, отличную документацию и множество вариантов как бесплатной, так и платной поддержки.

**Django** помогает писать программное обеспечение, которое будет:

- **Полным** (философия «Всё включено»)
- **Разносторонним** (создание любого типа сайтов, работа с любой клиентской средой, доставка контента в любом формате, может быть расширен сторонними компонентами)
- **Безопасным** (управление учётными записями, хэши паролей, защита от многих уязвимостей - SQL-инъекции, межсайтовый скриптинг, подделка межсайтовых запросов и кликджекинг)
- **Масштабируемым** (**"shared-nothing"** архитектура - чёткое разделение частей означает, что Django может масштабироваться при увеличении трафика, путём добавления оборудования на любом уровне: серверы кеширования, серверы баз данных или серверы приложений )
- **Удобным в сопровождении** (используется принцип **«Don't Repeat Yourself»** - **DRY**, «не повторяйся», группирует связанный код в модули шаблона MVC)
- **Переносным** (мультиплатформа)

**Django** «умеренно гибкий». Он предоставляет набор компонентов для обработки большинства задач веб-разработки и один (или два) предпочтительных способа их использования. Однако такая архитектура Django означает, что вы обычно можете выбирать из нескольких различных опций или при необходимости добавлять поддержку для совершенно новых.

[Назад к Django](#django)

### Как выглядит код Django?

На традиционном информационном веб-сайте веб-приложение ожидает HTTP-запросы от веб-браузера (или другого клиента). Когда запрос получен, приложение разрабатывает то, что необходимо на основе URL-адреса и, возможно, данных в POST или GET запросах. В зависимости от того, что требуется, далее он может читать или записывать информацию из базы данных или выполнять другие задачи, необходимые для удовлетворения запроса. Затем приложение вернёт ответ веб-браузеру, часто динамически создавая HTML-страницу для отображения в браузере, вставляя полученные данные в HTML-шаблон.

Веб-приложения, написанные на Django, обычно группируют код, который обрабатывает каждый из этих шагов, в отдельные файлы:

![Блок-схема работы Django](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Introduction/basic-django.png)

- **URLs:** Хотя можно обрабатывать запросы с каждого URL-адреса с помощью одной функции, гораздо удобнее писать отдельную функцию для обработки каждого ресурса. URL-маршрутизатор используется для перенаправления HTTP-запросов в соответствующее представление на основе URL-адреса запроса. Кроме того, URL-маршрутизатор может извлекать данные из URL-адреса в соответствии с заданным шаблоном и передавать их в соответствующую функцию отображения (view) в виде аргументов.
- **View:** View (англ. «отображение») — это функция обработчика запросов, которая получает HTTP-запросы и возвращает ответы. Функция view имеет доступ к данным, необходимым для удовлетворения запросов, и делегирует ответы в шаблоны через модели.
- **Models:** Модели представляют собой объекты Python, которые определяют структуру данных приложения и предоставляют механизмы для управления (добавления, изменения, удаления) и выполнения запросов в базу данных.
- **Templates:** Template (англ. «шаблон») — это текстовый файл, определяющий структуру или разметку страницы (например HTML-страницы), с полями для подстановки, которые используются для вывода актуального содержимого. View может динамически создавать HTML-страницы, используя HTML-шаблоны и заполняя их данными из модели (model). Шаблон может быть использован для определения структуры файлов любых типов, не обязательно HTML.

> **Примечание:** Django реализует уровневую архитектуру "Model View Template (MVT)". Она имеет много общего с более известной архитектурой Model View Controller.

[Назад к Django](#django)

### Отправка запроса в правильное view (urls.py)

Сопоставитель URL-адресов обычно содержится в файле **urls.py**. В примере ниже сопоставитель (`urlpatterns`) определяет список сопоставлений между *маршрутами* (определёнными URL-*шаблонами*) и соответствующими функциями отображения (view). Если получен HTTP-запрос, который имеет URL-адрес, соответствующий определённому шаблону, то затем будет вызвана связанная функция отображения (view) и передана в запрос.
```py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('book/<int:id>/', views.book_detail, name='book_detail'),
    path('catalog/', include('catalog.urls')),
    re_path(r'^([0-9]+)/$', views.best),
]
```

Объект `urlpatterns` является списком функций `path()` и/или `re_path()` (в Python списки определяются с помощью квадратных скобок, внутри которых элементы разделены запятыми и могут содержать [необязательную завершающую запятую](https://docs.python.org/2/faq/design.html#why-does-python-allow-commas-at-the-end-of-lists-and-tuples). Например: `[item1, item2, item3,]`).

Первый аргумент в обоих методах - маршрут (шаблон), который будет сопоставлен. В методе `path()` угловые скобки используются для определения частей URL-адреса, которые будут захвачены и переданы в функцию отображения (view) в качестве именованных аргументов. Функция `re_path()` использует гибкий подход к сопоставлению с шаблоном, известный как регулярное выражение. Мы поговорим об этом в следующей статье!

Второй аргумент — это ещё одна функция, которая будет вызываться при сопоставлении шаблона. Обозначение `views.book_detail` указывает, что функция называется `book_detail()` и может быть обнаружена в модуле с именем `views` (т.е. внутри файла с именем `views.py`).

[Назад к Django](#django)

### Обработка запроса (views.py)

Отображения (views) — это сердце веб-приложения, принимающего HTTP-запросы от веб-клиентов и возвращающего HTTP-ответы. Между этим они используют другие ресурсы фреймворка для доступа к базам данных, шаблонам визуализации и т. д.

В приведённом ниже примере показана минимальная функция представления `index()`, которая могла быть вызвана нашим сопоставителем URL-адресов в предыдущем разделе. Как и все функции отображения (view), она получает объект `HttpRequest` в качестве параметра (`request`) и возвращает объект `HttpResponse`. В этом случае мы ничего не делаем с запросом, и наш ответ просто возвращает жёстко запрограммированную строку. Мы покажем вам запрос, который делает что-то более интересное в следующем разделе.
```py
## filename: views.py (Django view functions)

from django.http import HttpResponse

def index(request):
    # Получить HttpRequest — параметр запроса
    # Выполнить операции, используя информацию из запроса.
    # Вернуть HttpResponse
    return HttpResponse('Hello from Django!')
```

> **Примечание:** Немного о Python:
> 
>[Модули Python](https://docs.python.org/3/tutorial/modules.html) это библиотеки функций, сохранённые в различных файлах, которые мы можем использовать в нашем коде. Здесь мы импортируем только объект `HttpResponse` из модуля `django.http` чтобы использовать его в нашем отображении (view): `from django.http import HttpResponse`. Также есть другие способы импортирования некоторых или всех объектов модуля.
>
>Функции объявляются с помощью ключевого слова `def`, как показано выше, с именованными параметрами, перечисленными в скобках после имени функции; строка завершается двоеточием. Заметьте, что следующие строки содержат отступы. Отступы важны, так как они определяют, какие строки кода находятся внутри конкретного блока (обязательные отступы — это ключевая особенность Python и одна из причин, почему код на Python так легко читать).

Отображения (view) обычно содержатся в файле **views.py**.

[Назад к Django](#django)

### Определение данных модели (models.py)

Веб-приложения Django обрабатывают и запрашивают данные через объекты Python, называемые моделями. Модели определяют структуру хранимых данных, включая типы полей и, возможно, их максимальный размер, значения по умолчанию, параметры списка выбора, текст справки для документации, текст меток для форм и т. д. Определение модели не зависит от используемой базы данных — ваши модели будут работать в любой из них. После того как вы выбрали базу данных, которую хотите использовать, вам не нужно напрямую обращаться к ней — вы просто пишете свою структуру модели и другой код, а Django выполняет всю «грязную работу» по обращению к базе данных за вас.

В приведённом ниже фрагменте кода показана очень простая модель Django для объекта `Team`. Класс `Team` наследуется от класса `models.Model`. Он определяет имя команды и командный уровень в качестве полей символов и задаёт максимальное количество символов, которые могут быть сохранены для каждой записи. `Team_level` может быть одним из нескольких значений, поэтому мы определяем его как поле выбора и предоставляем сопоставление между отображаемыми вариантами и хранимыми данными вместе со значением по умолчанию.
```py
# filename: models.py

from django.db import models

class Team(models.Model):
    team_name = models.CharField(max_length=40)

    TEAM_LEVELS = (
        ('U09', 'Under 09s'),
        ('U10', 'Under 10s'),
        ('U11', 'Under 11s'),
        ...  #список других командных уровней
    )
    team_level = models.CharField(max_length=3,choices=TEAM_LEVELS,default='U11')
```
> **Примечание:** Немного о Python:
> 
> Python поддерживает «объектно-ориентированное программирование», то есть стиль программирования, в котором мы организуем наш код в объекты, которые включают связанные данные и функции для работы с этими данными. Объекты также могут наследовать / расширять / выводить из других объектов, позволяя использовать одинаковое поведение между связанными объектами. В Python мы используем ключевое слово `class`, чтобы определить «скелет» для объекта. Мы можем создать несколько конкретных экземпляров типа объекта на основе модели в классе.
> 
> Так, например, мы имеем класс `Team`, который происходит от класса `Model`. Это означает, что эта модель будет содержать все методы модели, но мы также можем дать ей специализированные возможности. В нашей модели мы определяем поля нашей базы данных, в которой будем хранить данные, присваивая им конкретные имена. Django использует эти определения, включая имена полей, для создания основной базы данных.

[Назад к Django](#django)

### Запросы данных (views.py)

Модель Django предоставляет простой API запросов для поиска в базе данных. Поиск может осуществляться по нескольким полям одновременно, используя различные критерии (такие как exact («точный»), case-insensitive («без учёта регистра»), greater than («больше чем») и т. д.), и может поддерживать сложные выражения (например, вы можете указать поиск в командах U11, у которых есть имя команды, начинающееся с «Fr» или заканчивается на «al»).

Фрагмент кода показывает функцию view (обработчик ресурсов) для отображения всех команд U09. Выделенная жирным строка показывает, как мы можем использовать модель API-запросов для того, чтобы отфильтровать все записи, где поле `team_level` в точности содержит текст 'U09' (обратите внимание, как эти критерии передаются функции `filter()` в качестве аргумента с именем поля и типом соответствия, разделённым двойным подчёркиванием: **`team_level__exact`**).
```py
## filename: views.py

from django.shortcuts import render
from .models import Team

def index(request):
    list_teams = Team.objects.filter(team_level__exact="U09")
    context = {'youngest_teams': list_teams}
    return render(request, '/best/index.html', context)
```

Данная функция использует функцию `render()` для того, чтобы создать `HttpResponse`, который будет отправлен назад браузеру. Эта функция является *ярлыком*; она создаёт HTML-файл, комбинируя указанный HTML-шаблон и некоторые данные для вставки в шаблон (предоставляется в переменной с именем `«context»`). В следующем разделе мы покажем как данные вставляются в шаблон для создания HTML-кода.

[Назад к Django](#django)

### Вывод данных (HTML-шаблоны)

Системы шаблонов позволяют указать структуру выходного документа, используя заполнители для данных, которые будут вставлены при генерировании страницы. Шаблоны часто используются для создания HTML, но также могут создавать другие типы документов. Django «из коробки» поддерживает как собственную систему шаблонов, так и другую популярную библиотеку Python под названием Jinja2 (она также может быть использована для поддержки других систем, если это необходимо).

Фрагмент кода показывает, как может выглядеть HTML-шаблон, вызванный функцией `render()` из предыдущего раздела. Этот шаблон был написан с предположением, что во время отрисовки он будет иметь доступ к переменной списка, названной `youngest_teams` (содержащейся в контекстной переменной внутри функции `render()` выше). Внутри скелета HTML мы имеем выражение, которое сначала проверяет, существует ли переменная `youngest_teams`, а затем повторяет её в цикле `for`. При каждом повторе шаблон отображает значение `team_name` каждой команды в элементе `<li>`.
```html
## filename: best/templates/best/index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Home page</title>
</head>
<body>
  {% if youngest_teams %}
    <ul>
      {% for team in youngest_teams %}
        <li>{{ team.team_name }}</li>
      {% endfor %}
    </ul>
  {% else %}
    <p>No teams are available.</p>
  {% endif %}
</body>
</html>
```

[Назад к Django](#django)

### Что ещё можно сделать?

В предыдущих разделах показаны основные особенности, которые вы будете использовать почти в каждом веб-приложении: сопоставление URL-адресов, отображение, модели и шаблоны. Также Django предоставляет несколько других вещей:

- **Формы:** HTML-формы используются для сбора пользовательских данных для обработки на сервере. Django упрощает создание, проверку и обработку формы.
- **Аутентификация пользователя и разрешения:** Django включает надёжную систему аутентификации и авторизации пользователей, которая была построена с учётом безопасности.
- **Кеширование:** Создание динамического контента намного более интенсивно (и медленнее), чем обслуживание статического содержимого. Django обеспечивает гибкое кеширование, чтобы вы могли хранить всю или часть отображаемой страницы, для того, чтобы она не вызывалась повторно, за исключением случаев, когда это необходимо.
- **Админ-панель:** Административная панель в Django включена по умолчанию при создании приложения с использованием основного каркаса. Это упрощает управление админкой администраторам сайта для создания, редактирования и просмотра любых данных на вашем сайте.
- **Сериализация данных (преобразование в последовательную форму):** Django упрощает сериализацию и обслуживание ваших данных в таких форматах как XML или JSON. Это может быть полезно при создании веб-сервисов (веб-сайтов, которые исключительно служат для использования данных другими приложениями или сайтами и сами ничего не отображают) или при создании веб-сайта, на котором клиентский код обрабатывает весь рендеринг данных.

### Резюме

Поздравляем, вы завершили первый шаг в своём путешествии по Django! Теперь вы должны понимать основные преимущества Django, и примерно как может выглядеть каждая из основных частей приложения Django. Вы должны также изучить несколько вещей о языке программирования Python, включая синтаксис списков, функций и классов.

Вы уже видели код на Django выше, но в отличие от клиентского кода вам нужно настроить среду разработки для её запуска. Это наш следующий шаг.

[Назад к Django](#django)

## Setting up a Django development environment

Теперь, когда вы знаете, что такое Django, мы покажем вам, как настроить и протестировать среду разработки Django для Windows, Linux (Ubuntu) и Mac OS X - какую бы операционную систему вы не использовали, эта статья должна дать вам все, что необходимо для возможности начать разрабатывать приложения Django.

|Требования | Знание как открыть терминал / командную строку, как устанавливать программные пакеты в операционной системе вашего компьютера.
|-|--------
|Задача | Создать среду разработки для Django (1.10) и запустить её на вашем компьютере.

### Обзор среды разработки Django

В этом разделе объясняется, что входит в состав среды разработки, и даётся обзор некоторых параметров настройки и конфигурации. В оставшейся части статьи объясняется рекомендуемый метод установки среды разработки Django на Ubuntu, Mac OS X и Windows, и как вы можете её протестировать.

**Среда разработки** - это установка Django на вашем локальном компьютере, которую вы можете использовать для разработки и тестирования приложений Django до их развёртывания в производственной среде.

Основными инструментами, которые предоставляет сам Django, является набор скриптов Python для создания и работы с проектами Django, а также простой веб-сервер *разработки*, который можно использовать для тестирования локальных (то есть на вашем компьютере, а не на внешнем веб-сервере) веб-приложений Django на веб-браузере вашего компьютера.

Существуют и другие периферийные инструменты, являющиеся частью среды разработки, которые мы не будем освещать здесь. К ним относятся такие вещи, как текстовый редактор или IDE для редактирования кода, и инструмент управления исходным кодом, например Git, для безопасного управления различными версиями вашего кода. Мы предполагаем, что у вас уже установлен текстовый редактор.

[Назад к Django](#django)

### Разновидности установки Django

Django очень гибок с точки зрения способа и места установки и настройки. Django может быть:

- установлен на различных операционных системах,
- установлен из исходного кода, из Python Package Index (PyPi) и во многих случаях из любого менеджера пакетов,
- настроен на использование различных баз данных, которые должны быть установлены и настроены отдельно,
- запущен в основной системе окружения Python или в отдельном виртуальном окружении Python.
- Каждый из этих вариантов требует немного разной настройки и установки. Следующие подразделы объяснят некоторые аспекты вашего выбора. Далее мы покажем вам, как установить Django на некоторые операционные системы, и эта установка будет предполагаться на всём протяжении данного модуля.

> **Примечание:** Другие возможные способы установки можно найти в официальной документации Django. Мы ссылаемся на соответствующие документы.

- **Какие операционные системы поддерживаются?**

Веб-приложения Django можно запускать почти на любых машинах, которые поддерживают язык программирования Python 3, среди прочих: Windows, Mac OS X, Linux/Unix, Solaris. Почти любой компьютер имеет необходимую производительность для запуска Django во время разработки.

В этой статье мы предоставляем инструкции для Windows, Mac OS X, and Linux/Unix.

- **Какую версию Python стоит использовать?**

Мы рекомендуем использовать самую последнюю доступную версию - на момент написания статьи это Python 3.6.

> **Примечание:** Python 2.7 не может быть использован вместе с Django 2.0 (последние поддерживаемые серии для Python 2.7 - Django 1.11.x).

- **Откуда можно скачать Django?**

Для загрузки Django можно воспользоваться 3 источниками:

- The Python Package Repository (PyPi), при помощи инструмента pip. Это лучший способ получения последней стабильной версии Django.
- Использование версии из менеджера пакетов вашего компьютера. Такие дистрибутивы Django, собранные для конкретных операционных систем, предлагают знакомый механизм установки. Однако обратите внимание на то, что пакетные версии могут быть достаточно старыми и установлены только в системную среду Python (что может отличаться от ваших желаний).
- Установка из исходного кода. Вы можете получить и установить последний выпуск Django из исходного кода. Этот способ не рекомендован для новичков, но необходим в случае, когда вы готовы начать вносить собственный вклад в проект Django.

Данный материал описывает способ установки Django из PyPi с целью получения последней стабильной версии.

- **Какую базу данных выбрать?**

Django поддерживает 4 основных базы данных (PostgreSQL, MySQL, Oracle и SQLite), также есть публичные библиотеки, которые предоставляют разные уровни поддержки других SQL и NoSQL баз данных. Мы рекомендуем вам выбрать одинаковую БД для обеих рабочей и разрабатываемой сред (несмотря на то, что Django нивелирует множество различий баз данных при помощи Object-Relational Mapper (ORM), всё равно возможны потенциальные проблемы, которых лучше избегать.

Для данной статьи (и большей части модуля) мы будем использовать базу данных SQLite, которая сохраняет свои данные в файл. SQLite предназначен для использования в качестве облегчённой базы данных и не может поддерживать высокий уровень параллелизма. Это, однако, отличный выбор для приложений, которые в основном предназначены только для чтения.

> **Примечание:** Django сконфигурирован для использования SQLite по умолчанию, при создании вашего проекта с использованием стандартных инструментов (django-admin). Это отличный выбор для начала работы, потому что он не требует дополнительной настройки.

- **Глобальная установка или установка в виртуальную среду Python?**

Если вы устанавливаете Django в среду по умолчанию (глобальную), то будете способны сфокусироваться на одной версии Django на вашем компьютере. Это может быть проблемой в случае, если вы захотите создать новые веб-сайты (при помощи новой версии Django) во время поддержки веб-сайтов со старой версией.

По этой причине опытные разработчики Python / Django часто предпочитают вместо этого запускать свои приложения Python в независимых виртуальных средах Python. Это позволяет разработчикам иметь несколько разных сред Django на одном компьютере. Команда разработчиков Django сама рекомендует использовать виртуальные среды Python!

Этот модуль предполагает вашу установку Django в виртуальную среду, и мы покажем, как это сделать.

[Назад к Django](#django)

### Установка Python 3

Для использования Django вам необходимо установить Python 3 на свою операционную систему. Вам также понадобится инструмент [Python Package Index](https://pypi.python.org/pypi) — *pip3* — который используется для управления (установка, обновление и удаление) библиотек/пакетов Python, используемых Django и другими вашими приложениями Python.

Этот раздел коротко описывает то, как вы можете проверить имеющиеся версии и при необходимости установить новые для Ubuntu Linux 16.04, Mac OS X, and Windows 10.

> **Примечание:** В зависимости от платформы, вы можете иметь возможность установки Python/pip из собственного менеджера пакетов операционной системы или при помощи других инструментов. Для большинства платформ вы можете скачать необходимые установочные файлы из https://www.python.org/downloads/ и установить их при помощи соответствующего специфичного для платформы метода.

- **Ubuntu 16.04**

Ubuntu Linux включает в себя Python 3 по умолчанию. Вы можете удостовериться в этом, выполнив следующую команду в терминале:
```bash
python3 -V
 Python 3.5.2
```

Однако, инструмент Python Package Index, при помощи которого вам нужно будет установить пакеты для Python 3 (включая Django), по умолчанию не установлен. Вы можете установить pip3 через терминал bash при помощи:
```bash
sudo apt-get install python3-pip
```

- **Mac OS X**

Mac OS X "El Capitan" не включает Python 3. Вы можете удостовериться в этом, выполнив следующую команду в терминале:
```bash
python3 -V
 -bash: python3: command not found
```

Вы можете легко установить Python 3 (вместе с инструментом pip3) с [python.org](https://www.python.org/):

1. Скачайте нужный установочный файл:
   - Перейдите в https://www.python.org/downloads/
   - Нажмите на кнопку **Скачать Python 3.6.4** (точная основная версия может отличаться).
2. Найдите файл при помощи *Finder*, дважды кликните по нему и следуйте подсказкам по установке.

Удостовериться в успешной установке вы можете проверкой на наличие Python 3, как показано ниже:
```bash
python3 -V
 Python 3.5.20
```

Подобным образом вы можете проверить установку pip3, отобразив список доступных пакетов:
```bash
pip3 list
```

- **Windows 10**

Windows не включает Python по умолчанию, но вы можете легко установить его (вместе с инструментом pip) с [python.org](https://www.python.org/):

1. Скачайте нужный установочный файл:
    - Перейдите в https://www.python.org/downloads/
    - Нажмите на кнопку **Скачать Python 3.6.4** (точная основная версия может отличаться).
2. Установите Python, дважды кликнув на скачанный файл и следуя инструкциям по установке.

После этого вы сможете подтвердить успешную установку Python путём выполнения следующего текста в командной строке:
```bash
py -3 -V
 Python 3.5.2
```

Установщик Windows включает в себя pip3 (менеджер пакетов Python) по умолчанию. Вы можете отобразить список установленных пакетов, как показано далее:
```bash
pip list
```

> **Примечание:** Установщик должен сделать все, что необходимо для корректной работы указанной команды. Однако, если вы видите сообщение о том, что Python не может быть найден, вам может потребоваться добавить его в системный путь.

[Назад к Django](#django)

### Использование Django внутри виртуальной среды Python

Для создания виртуальных сред мы будем использовать библиотеки [virtualenvwrapper](https://virtualenvwrapper.readthedocs.io/en/latest/index.html) (Linux и macOS X) и [virtualenvwrapper-win](https://pypi.python.org/pypi/virtualenvwrapper-win) (Windows), которые в свою очередь обе используют инструмент [virtualenv](https://github.com/mdn/archived-content/tree/main/files/en-us/mozilla/virtualenv). Инструмент обёртки предоставляет совместимый интерфейс для управления интерфейсами на всех платформах.

### Установка ПО виртуальной среды

- **Установка виртуальной среды для Ubuntu**

После установки Python и pip вы можете установить *virtualenvwrapper* (который включает в себя *virtualenv*). Вы можете либо воспользоваться официальной инструкций по установке [отсюда](http://virtualenvwrapper.readthedocs.io/en/latest/install.html), либо следовать следующим инструкциям:

Установите инструмент при помощи pip3:
```bash
sudo pip3 install virtualenvwrapper
```

Затем добавьте следующие строки в конец файла загрузки программной оболочки (shell) (это скрытый файл в вашей домашней директории с именем **.bashrc**). Они устанавливают расположение виртуальных сред, расположение каталога разрабатываемого проекта и расположение установленного с этим пакетом скрипта.
```bash
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
export VIRTUALENVWRAPPER_VIRTUALENV_ARGS=' -p /usr/bin/python3 '
export PROJECT_HOME=$HOME/Devel
source /usr/local/bin/virtualenvwrapper.sh
```

Затем перезагрузите файл загрузки, выполнив в терминале следующую команду:
```bash
source ~/.bashrc
```

В этот момент вы должны увидеть запуск группы скриптов, как показано ниже:
```bash
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/premkproject
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/postmkproject
...
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/preactivate
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/postactivate
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/get_env_details
```

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualenv`.

- **Установка виртуальной среды для macOS X**

Установка *virtualenvwrapper* на macOS X почти идентична Ubuntu (и снова вы можете воспользоваться либо [официальными](http://virtualenvwrapper.readthedocs.io/en/latest/install.html), либо следующими инструкциями).

Установите инструмент при помощи *pip3*:
```bash
sudo pip3 install virtualenvwrapper
```

Затем добавьте следующие строки в конец вашего файла загрузки программной оболочки:
```bash
export WORKON_HOME=$HOME/.virtualenvs
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
export PROJECT_HOME=$HOME/Devel
source /usr/local/bin/virtualenvwrapper.sh
```

> **Примечание:** Переменная `VIRTUALENVWRAPPER_PYTHON` указывает на обычное расположение Python3. Если virtualenv не работает во время тестирования, то вам следует проверить, находится ли интерпретатор Python в нужном расположении (и затем поменять его соответствующим образом в значении переменной).

Эти строки такие же, как в случае с Ubuntu, но файл загрузки в вашей домашней директории назван иначе - **.bash_profile**.

> **Примечание:** Если вы не можете найти и изменить .bash_profile при помощи Finder, то можно также открыть его при помощи редактора терминала nano.
>
> Команды в этом случае выглядят примерно так:
> ```bash
> cd ~ # Navigate to my home directory
> ls -la #List the content of the directory. You should see .bash_profile
> nano .bash_profile # Open the file in the nano text editor, within the terminal
> # Scroll to the end of the file, and copy in the lines above
> # Use Ctrl+X to exit nano, Choose Y to save the file.
> ```

После этого перезагрузите файл загрузки путём выполнения следующей команды в терминале:
```bash
source ~/.bash_profile
```

В этот момент вы должны увидеть запуск группы скриптов (те же скрипты, что и в случае установки на Ubuntu).

Теперь вы должны иметь возможность создания новой виртуальной среды при помощи команды `mkvirtualenv`.

- **Установка виртуальной среды для Windows 10**

Установка [virtualenvwrapper-win](https://pypi.python.org/pypi/virtualenvwrapper-win) ещё более проста, чем установка *virtualenvwrapper*, потому что вам не нужно настраивать расположения сохранения информации о виртуальной среде инструментом (эти значения заданы по умолчанию). Все, что вам нужно сделать, это запустить следующую команду в командной строке:
```bash
pip3 install virtualenvwrapper-win
```

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualen`.

[Назад к Django](#django)

### Создание и использование виртуальной среды

После установки *virtualenvwrapper* и *virtualenvwrapper-win* работа с виртуальными средами становится одинаковой для всех платформ.

Теперь вы можете создать новую виртуальную среду при помощи команды `mkvirtualenv`. Во время запуска команды вы увидите установку виртуальной среды (конкретные результаты команды очень зависят от платформы). После выполнения команды активируется новая виртуальная среда — заметить это вы можете по тому, что началом ввода будет название виртуальной среды в круглых скобках (как показано ниже).
```bash
$ mkvirtualenv my_django_environment
Running virtualenv with interpreter /usr/bin/python3 ...
virtualenvwrapper.user_scripts creating /home/ubuntu/.virtualenvs/t_env7/bin/get_env_details
(my_django_environment) ubuntu@ubuntu:~$
```

Теперь вы находитесь внутри виртуальной области и можете установить Django и начать разработку.

> **Примечание:** С этого момента в этой статье (и всем модуле) пожалуйста учитывайте, что любые команды запускаются в виртуальной среде Python, как та, что мы показали выше.

- **Использование виртуальной среды**

Есть ещё несколько полезных команд, которые вам следует знать (в документации по инструменту их гораздо больше, но эти вы будете использовать регулярно):

- `deactivate` — Выход из текущей виртуальной среды Python
- `workon` — Список доступных виртуальных сред
- `workon name_of_environment` — Активация конкретной виртуальной среды Python
- `rmvirtualenv name_of_environment` — Удаление конкретной виртуальной среды.

[Назад к Django](#django)

### Установка Django, проверка установки

После создания виртуальной среды и вызова `workon` для входа в неё вы можете использовать *pip3* для установки Django.
```bash
pip3 install django
```

Вы можете проверить установку Django, выполнив следующую команду (она просто проверяет, что Python может найти модуль Django):
```bash
# Linux/Mac OS X
python3 -m django --version
 1.10.10

# Windows
py -3 -m django --version
 1.10.10
```

> **Примечание:** Для Windows вы запускаете скрипты Python 3 с префиксом команды py -3, в то время как для Linux/Mac OSX префикс - python3.

>> **Предупреждение: Важно:** В оставшейся части материала используется вариант команды Linux для вызова Python 3 (python3) . Если вы работаете в Windows, то просто замените этот префикс на: py -3

- **Проверка вашей установки**

Указанная выше проверка работает, но не представляет особого интереса. Более интересная проверка заключается в создании шаблона проекта и проверки его работы. Для её выполнения перейдите в командной строке/терминале в место, где планируете сохранять приложения Django. Создайте папку для теста и перейдите в неё.
```bash
mkdir django_test
cd django_test
```

Затем вы можете создать шаблон сайта *"mytestsite"* при помощи инструмента **django-admin**. После создания сайта вы можете перейти в папку, где найдёте основной скрипт для управления проектами с именем **manage.py**.

```bash
django-admin startproject mytestsite
cd mytestsite
```

Мы можем запустить веб-сервер разработки из этой папки при помощи **manage.py** и команды `runserver`, как показано ниже.
```bash
$ python3 manage.py runserver
Watching for file changes with StatReloader
Performing system checks…

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
March 01, 2022 - 01:19:16
Django version 4.0.2, using settings 'mytestsite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

> **Примечание:** Указанная команда демонстрирует выполнение для Linux/Mac OS X. В настоящий момент вы можете проигнорировать предупреждения о "13 непримененных миграциях"!

Как только сервер запущен, вы можете посмотреть сайт, перейдя по следующему адресу в вашем браузере: `http://127.0.0.1:8000/`. Вы должны увидеть, что сайт выглядит следующим образом:

![Django site](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/development_environment/django_skeleton_website_homepage.png)

### Заключение
Теперь у вас на компьютере установлена и запущена среда разработки Django.

В разделе проверки вам коротко был показан способ создания нового сайта на Django при помощи `django-admin startproject` и его запуск в вашем браузере при помощи веб-сервера разработки (`python3` `manage.py` `runserver`). В следующей статье мы подробнее рассмотрим этот процесс создания простого, но полноценного веб-приложения.

[Назад к Django](#django)

## Django: сайт местной библиотеки

Первая статья в цикле объясняет и разбирает пример сайта "местная библиотека".

|Необходимо: | Прочитайте [вступление](#введение). Для последующих статей вам так же потребуется настроить [среду разработки](#создание-и-использование-виртуальной-среды).
|---|--- 
|Цель: | Представить читателю пример веб-приложения, которое будет использоваться в нашем руководстве и показать, какие темы будут изучены в этом цикле статей.

### Обзор руководства
Добро пожаловать на руководство MDN "Сайт местной библиотеки" по фреймворку Django, который может использоваться для управления архивом библиотеки.

В цикле статей мы научимся:

- При помощи Django создавать прототип сайта.
- Запускать и останавливать сервер для разработки.
- Создавать модели для представления данных.
- Использовать админ-панель Django для управления сайтом
- Создавать представления для того, чтобы формировать из данных ответы на различные запросы и превращать их в HTML разметку, которая будет отображаться в браузере.
- Создавать маршруты, чтобы определённые URL адреса ассоциировались сервером с определёнными представлениями
- Создавать авторизацию пользователей и сессии, чтобы управлять доступом к сайту.
- Работать с формами.
- Тестировать ваше веб-приложение.
- Эффективно использовать средства безопасности Django.
- Размещать ваш сайт в Сети.

С некоторыми темами вы уже сталкивались, а про некоторые только знаете, что они существуют. По окончанию цикла статей вы должны будете иметь достаточно знаний, чтобы разрабатывать несложные сайты на Django для своих целей.

### Сайт местной библиотеки

Это название сайта, который мы создадим и будем улучшать, в течение этого цикла статей. Как можно догадаться, цель этого сайта в том, чтобы представить небольшой онлайн каталог маленькой местной библиотеки, где пользователи смогут загружать доступные книги и управлять своими профилями.

Этот пример был выбран потому, что его можно масштабировать, чтобы рассказать настолько детально или поверхностно, насколько это требуется, о почти любой особенности Django. Что более важно, этот пример позволяет показать последовательный путь по самым важным функциям фреймворка Django:

- В самом начале, мы создадим библиотеку, в которой пользователи смогут только просматривать доступные книги. Это позволит нам исследовать операции, которые присутствуют почти на каждом сайте: чтение и отображение информации из базы данных.
- По мере продвижения, на сайте станут использоваться более продвинутые возможности Django. Например, мы сможем расширить библиотеку и позволить пользователям резервировать книги, чтобы показать как использовать формы и авторизацию.

Несмотря на то, что это довольно обширный пример, проект называется сайтом местной библиотеки потому, что мы надеемся показать минимум достаточной информации, которая поможет вам быстро научиться разрабатывать на Django. Поэтому мы будем хранить данные о книгах, копиях книг, авторах и другую ключевую информацию. Однако мы не будем хранить другую информацию, которая могла бы быть полезной библиотеке, или создавать обширную инфраструктуру для поддержки нескольких сайтов библиотек или другие особенности "крупных библиотек".

- **Я застрял, где мне взять код?**

По мере усложнения руководства, мы будем предоставлять необходимый код, который можно скопировать и вставить, а так же будет и другой код, который, мы надеемся, вы улучшите самостоятельно.

Если вы застряли, то можете найти полноценную версию сайта на [Github](https://github.com/mdn/django-locallibrary-tutorial).

- **Подводя итоги**

Теперь вы знаете чуть больше о сайте, который мы будем разрабатывать, и теперь самое время создать скелет нашего сайта.

[Назад к Django](#django)

## Django 2: создание скелета

Это вторая статья из нашего [руководства по Django](#django-сайт-местной-библиотеки), которая показывает, как можно создать "скелет" сайта, как фундамент, на котором можно строить всё остальное: настройки, ссылки, модели, контроллеры и представления.

|Необходимо: |[Настройка окружения](#setting-up-a-django-development-environment). Прочитать первую статью [руководства по Django](#django-сайт-местной-библиотеки).
|----|----
|Цель: |Научиться использовать инструменты Django для создания новых веб-сайтов.

### Обзор

Эта статья показывает, как можно создать "скелет"(прототип) сайта, который затем можно расширить при помощи различных настроек, url адресов, моделей, представлений, и шаблонов (эти темы будут объясняться в последующих статьях).

Алгоритм следующий:

1. Использовать `django-admin` для создания папки проекта, шаблонов остальных файлов, и скрипта для управления проектом (**manage.py**).

2. Использовать **manage.py** для *создания одного или нескольких* приложений.

> **Примечание:** Сайт может состоять из одной или нескольких различных частей, например: основная часть, блог, вики, раздел загрузок, и так далее. Философия Django подталкивает разработчиков создавать эти части, как разные **приложения**, которые, если понадобится, могут быть использованы повторно в других проектах.

3. Зарегистрировать в настройках эти приложения, чтобы использовать их в проекте.

4. Настроить маршруты url адресов для каждого из приложений.

Для [Сайта местной библиотеки](#django-сайт-местной-библиотеки) папка сайта и проекта будет называться *locallibrary*, и у нас будет одно приложение с названием *catalog*. Верхняя структура проекта будет следующей:
```bash
locallibrary/         # Папка сайта
    manage.py         # Скрипт для управления проектов (создан manage.py)
    locallibrary/     # Папка сайта/проекта (создана manage.py)
    catalog/          # Папка приложения (также создана manage.py)
```

Следующие разделы статьи разложат по полочкам этапы создания "скелета", и покажут вам, как можно проверить сделанные изменения. В конце статьи мы обсудим некоторые другие настройки сайта, которые можно назначить на этом этапе.

[Назад к Django](#django)

### Создание проекта

Для начала откройте командную строку/терминал, перейдите в ту папку, куда вы хотите поместить проект Django(лучше в папке профиля пользователя `C:\Users\user_name`, при запуске командной строки используется именно эта директория), и создайте папку для вашего нового сайта (в данном случае: *locallibrary*). Затем войдите в эту папку, используя команду cd:
```bash
mkdir locallibrary
cd locallibrary
```

Создайте новую папку, используя команду `django-admin startproject` как в примере ниже, и затем зайдите в созданную папку.
```bash
  django-admin startproject locallibrary .
cd locallibrary
```

Команда `django-admin` создаст файловую структуру, как в примере ниже:
```bash
locallibrary/
    manage.py
    locallibrary/
        settings.py
        urls.py
        wsgi.py
```

Подпапка проекта *locallibrary* это ключевая директория нашего проекта:

- **settings.py** содержит в себе все настройки проекта. Здесь мы регистрируем приложения, задаём размещение статичных файлов, настройки базы данных и так далее.
- **urls.py** задаёт ассоциации url адресов с представлениями. Несмотря на то, что этот файл может содержать все настройки url, обычно его делят на части, по одной на приложение, как будет показано далее.
- **wsgi.py** используется для налаживания связи между вашим Django приложением и веб-сервером. Вы можете воспринимать его, как утилиту.

Скрипт **manage.py** используется для создания приложений, работы с базами данных и для запуска отладочного сервера.

[Назад к Django](#django)

### Создание приложения Каталог

Выполнив предыдущие шаги, запустите следующую команду для создания приложения *catalog*, который будет размещён внутри папки locallibrary (команду необходимо выполнять из папки, в которой находится **manage.py**):
```bash
python3 manage.py startapp catalog
```

> **Примечание:** Приведённая выше команда справедлива для GNU Linux/Mac OS. На Windows команда должна иметь вид: `py -3 manage.py startapp catalog`
>
>Если вы работаете под Windows, заменяйте команду `python3` на `py -3` в этой и следующих статьях.

Эта команда создаст новую папку и наполнит её файлами различных частей приложения (выделенные **полужирным** ниже). Большинство файлов названы, исходя из их назначения (например контроллеры(views) должны находится во **views.py**, модели в **models.py**, тесты в **tests.py**, настройки административной части в **admin.py**, регистрация приложения в **apps.py**) и уже содержат некоторый шаблонный код для работы с вышеназванными объектами.

Обновлённая директория должна выглядеть следующим образом:
```bash
locallibrary/
    manage.py
    locallibrary/
    catalog/
        admin.py
        apps.py
        models.py
        tests.py
        views.py
        __init__.py
        migrations/
```

Кроме перечисленных выше файлов были созданы:

- Папка *migrations* используется, чтобы хранить"миграции" — файлы, которые позволяют вам автоматически обновлять базу данных по мере изменения моделей.
- `__init__.py` — пустой файл для того, чтобы Django и Python распознавали папку как [Python модуль](https://docs.python.org/3/tutorial/modules.html#packages) и позволяет нам использовать его объекты внутри других частей проекта.
> **Примечание:** Заметили, что некоторых файлов не хватает? В то время, как там нашли себе место файлы для контроллеров(views) и моделей(models), файлов для настройки url соотносителя, шаблонов, и статичных файлов создано не было. Далее мы покажем, как их создать (они не обязательны для каждого сайта, но нужны в данном примере).

[Назад к Django](#django)

### Регистрация папки с приложением

После создания приложения, нам нужно зарегистрировать его в проекте, чтобы различные утилиты затрагивали его своим действием (например при добавлении моделей в базу данных). Приложения регистрируются добавлением их названий в список `INSTALLED_APPS` в настройках проекта(который, как мы помним, называется **settings.py**).

Откройте файл **locallibrary/locallibrary/settings.py** и найдите в нём список `INSTALLED_APPS`. Затем добавьте новую строку в конец списка, как показано ниже.
```bash
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'catalog.apps.CatalogConfig',
]
```

Новая строка указывает на файл конфигурации приложения (`CatalogConfig`), который был создан в **/locallibrary/catalog/apps.py**, когда вы создали приложение.

Примечание: Легко заметить, что в `INSTALLED_APPS` уже подключено большое количество приложений (и объектов `MIDDLEWARE`, ниже в файле конфигурации). Они добавляют поддержку [админ-панели Django](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site) и, как следствие, огромное количество функциональности (включая сессии, аутентификацию и прочее).

[Назад к Django](#django)

### Настройка базы данных

На этом шаге обычно указывают базу данных для будущего проекта — имеет смысл использовать для разработки и размещённого в Сети одну и ту же базу данных, по возможности, чтобы исключить различия в поведении. Про различные варианты вы можете прочитать в документации Django в разделе [Базы данных](#базы-данных).

Мы будем использовать базу данных SQLite для этого проекта, потому что не предполагаем большое количество одновременных запросов на неё, а ещё потому, что для её настройки совсем не надо ничего делать! Вы можете видеть, что база данных уже настроена в **settings.py** (подробная информация указана ниже):
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
```

Так как мы используем SQLite, то нам не нужно ничего делать.

[Назад к Django](#django)

### Другие настройки проекта

Файл **settings.py** так же применяется и для некоторых других настроек, но на данном шаге имеет смысл поменять разве что [TIME_ZONE](https://docs.djangoproject.com/en/1.10/ref/settings/#std:setting-TIME_ZONE) — это значение должно быть представлено строкой, указанной в [списке часовых поясов tz](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (колонка TZ в таблице, в строке временной зоны, которая вам нужна). Измените `TIME_ZONE` на одну из строк из таблицы, которая отвечает вашему часовому поясу. Например:
```python
TIME_ZONE = 'Asia/Bishkek'
```

В файле присутствует две настройки, которые не нужно менять сейчас, но о назначении которых следует знать:

- `SECRET_KEY`. Это секретный ключ, который используется Django для поддержки безопасности сайта. Если вы раскроете этот ключ в процессе разработки кому-либо, то необходимо будет его сменить (возможно считать его с какого-либо файла на сервере или переменной окружения) когда будете размещать проект на сервер.
- `DEBUG`. Включает подробные сообщения об ошибках, вместо стандартных HTTP статусов ответов. Должно быть изменено на `False` на сервере, так как эта информация очень много расскажет взломщикам.

[Назад к Django](#django)

### Подключение URL-адреса

При создании сайта, был создан файл сопоставления URL (**urls.py**) в корне проекта. Хотя можно использовать его для обработки всех URL адресов, более целесообразно подключать отдельные файлы сопоставлений для каждого приложения.

Откройте **locallibrary/locallibrary/urls.py** и обратите внимание на закомментированный текст, который объясняет суть происходящего.
```python
"""
locallibrary URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/1.10/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.conf.urls import url, include
    2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
"""
from django.urls import path
from django.contrib import admin

urlpatterns = [
    path('admin/', admin.site.urls),
]
```

URL соотношения хранятся в переменной `urlpatterns`, которая является списком функций `path()`. Каждая `path()` функция или ассоциирует шаблон URL_ *с контроллером(views) или же его с другим таким списком (во втором случае, первый URL становится "базовым" для других, которые определяются в дочернем списке). Список `urlpatterns` инициализирует список функции, которая, например, соотносит _admin/* с модулем `admin.site.urls` , который содержит собственный файл-соотноситель.

Добавьте строчки, приведённые ниже в низ файла **urls.py**, чтобы добавить новый элемент в список `urlpatterns`. Этот элемент содержит `url()` который направляет запросы с URL `catalog/` к модулю `catalog.urls` (файл с относительным путём **/catalog/urls.py**).
```python
# Используйте include() чтобы добавлять URL из каталога приложения
from django.urls import include
from django.urls import path
urlpatterns += [
     path('catalog/', include('catalog.urls')),
]
```

Теперь давайте перенаправим корневой URL нашего сайта (например `127.0.0.1:8000`) на URL `127.0.0.1:8000/catalog/`; это единственное приложение, которое мы собираемся использовать, поэтому это вполне разумно. Чтобы это использовать, нам понадобится специальная функция (`RedirectView`), которая принимает первым параметром новый относительный URL на который следует перенаправлять (`/catalog/`) когда указанный в функции `url()` адрес соотносится с адресом запроса (корневой URL, в данном случае).

Добавьте следующие строчки, тоже в конец файла:
```python
# Добавьте URL соотношения, чтобы перенаправить запросы с корневого URL, на URL приложения
from django.views.generic import RedirectView
urlpatterns += [
    path('', RedirectView.as_view(url='/catalog/', permanent=True)),
]
```

Django не размещает статические файлы(CSS, JavaScript, и изображения) по умолчанию, но это было бы крайне полезно на этапе разработки нашего сайта. В самом конце нашего URL соотносителя, можно включить размещение статических файлов.

Добавьте последнюю часть в конец файла:
```py
# Используйте static() чтобы добавить соотношения для статических файлов
# Только на период разработки
from django.conf import settings
from django.conf.urls.static import static

urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

> **Примечание:** Существуют различные способы дополнения списка `urlpatterns` (в примере мы просто добавляли объект, используя оператор `+=` чтобы чётко разделить изначальный и дописанный код). Вместо этого, мы могли бы добавить соотношения внутрь определения переменной:
>```py
>urlpatterns = [   path('admin/', admin.site.urls),
>path('catalog/', include('catalog.urls')),path('',
>RedirectView.as_view(url='/catalog/', permanent=True)), ] +
>static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
>```
>Кроме того, мы добавили import вниз файла (`from django.urls import include`) ,чтобы видеть, что мы добавили, но обычно все инструкции import добавляются в верхнюю часть файла.

Напоследок, создайте файл **urls.py** внутри папки **catalog**, и добавьте следующий код, чтобы определить (пустой) `urlpatterns`. Сюда мы будем добавлять наши URL соотношения, по мере разработки сайта.
```python
from django.urls import path
from . import views

urlpatterns = [

]
```

[Назад к Django](#django)

### Тестирование работы скелета

На этом, мы создали прототип сайта. Пока сайт ничего не умеет делать, но стоит запустить его, чтобы убедиться, что мы ничего не сломали.

До этого, нам предстоит впервые запустить *миграцию базы данных*. Это обновит нашу базу данных и добавит туда необходимые модели (и уберёт некоторые предупреждения, которые были бы показаны при попытке запуска).

- **Запуск миграций базы данных**

Django использует **Объектный Соотноситель Связей (ORM)** чтобы соотносить определения моделей в Django приложении со структурами данных, которые используются базой данных. Когда мы меняем наши модели, Django отслеживает изменения и может создать файлы миграций (в папке **/locallibrary/catalog/migrations/**) чтобы применить соответствующие структуры данных к базе, чтобы та соответствовала модели.

При создании сайта, Django автоматически добавил несколько моделей, чтобы мы могли их использовать в админ-панели (о которой мы поговорим позже). Выполните следующие команды, чтобы создать нужные таблицы в базе данных, соответствующие этим моделям (убедитесь, что вы находитесь в папке с **manage.py**):
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

> **Предупреждение:** Необходимо выполнять команды выше каждый раз, когда вы меняете модели таким образом, что структура таблицы изменится(включая добавления и удаления как отдельных полей, так и целых моделей).

Команда `makemigrations` *создаёт* (но не применяет) миграции для всех приложений, которые установлены в ваш проект (вы так же можете указать в конце имя конкретного приложения, чтобы создать миграции только для него). Это даёт вам возможность проверить код перед тем, как их применить — когда вы станете хорошо разбираться в Django, то сможете даже менять их!

Команда `migrate` применяет созданные миграции к базе (Django отслеживает, какие миграции были созданы для данной базы).

> **Примечание:** Посмотрите раздел [Миграции](https://docs.djangoproject.com/en/2.2/topics/migrations/) в документации Django чтобы получить информацию о менее распространённых командах для управления миграциями.

[Назад к Django](#django)

### Запуск сайта

Во время разработки, вы можете проверить свой сайт, разместив его на *встроенном отладочном сервере*, и просмотрев его в своём браузере.

> **Примечание:** Отладочный веб-сервер не настолько функционален и производителен, для постоянного размещения , но это самый простой способ запустить свой сайт на Django и проверить его на наличие ошибок. По умолчанию, он разместит сайт на вашем компьютере (`http://127.0.0.1:8000/`), но вы так же можете указать различные компьютеры в вашей сети для этой цели. Для получения большего количества информации загляните в раздел [django-admin и manage.py: отладочный сервер](https://docs.djangoproject.com/en/2.2/ref/django-admin/) документации Django.

Запустите веб-сервер, используя команду `runserver` (в той же папке, что и **manage.py**):
```bash
python3 manage.py runserver

 Performing system checks...

 System check identified no issues (0 silenced).
 September 22, 2016 - 16:11:26
 Django version 1.10, using settings 'locallibrary.settings'
 Starting development server at http://127.0.0.1:8000/
 Quit the server with CTRL-BREAK.
```

Когда сервер запустится, вы сможете посетить сайт по адресу `http://127.0.0.1:8000/` в вашем веб-браузере. Вы должны увидеть страницу с ошибкой, навроде этой:

![/catalog/](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/skeleton_website/django_404_debug_page.png)

Не волнуйтесь! Эта страница должна появиться и сообщить нам, что мы ещё не настроили ни одной страницы в модуле `catalogs.urls` (на который мы были перенаправлены запросили корневой URL сайта).

> **Примечание:** Показанная выше страница открывает нам одно из замечательных свойств Django — автоматические отчёты об ошибках. На экране с ошибкой отображается множество полезной информации, когда страница не найдена, или ошибка была вызвана кодом. В данном случае, мы видим, что запрошенный URL не соответствует ни одному шаблону (из указанных). Подобные отчёты будут выключены при DEBUG=False (когда мы разместим приложение в Сеть), в этом случае будет показана менее информативная, но более дружелюбная к пользователю страница(которую вам надо будет создать - прим. переводчика).

На данном этапе, мы поняли, что Django работает должным образом!

> **Примечание:** Вам следует перезапускать миграцию и заново тестировать сайт, после того как вы делаете важные изменения. Поверьте, это не займёт много времени!

- **Домашнее задание**

Папка **catalog/** содержит файлы контроллеров(views), моделей(models), и других частей приложения. Просмотрите эти файлы.

Как было написано выше, URL соотноситель для админ-панели был подключён в файле **urls.py**. Войдите в административную часть и посмотрите, что произойдёт (вы можете найти URL из соотношения выше).

- **Подводя итоги**

Теперь вы создали полноценный скелет веб-приложения, который теперь вы можете расширить url соотносителями, контроллерами(views) и моделями(models).

Теперь скелет [Сайта местной библиотеки](#django-сайт-местной-библиотеки) сделан и запущен, теперь самое время начать писать код, который научит сайт делать то, что он должен делать.

- **Смотрите также**

- [Пишем своё первое приложение на Django - часть 1](https://docs.djangoproject.com/en/2.2/intro/tutorial01/) (документация Django)
- [Приложения](https://docs.djangoproject.com/en/2.2/ref/applications/) (документация Django). содержит информацию о настройке приложений.

[Назад к Django](#django)

## Django 3: использование моделей

В этой статье показано, как определить модели для [LocalLibrary](#django-сайт-местной-библиотеки) сайта. Она объясняет, что такое модель, как она объявляется, и некоторые из основных типов полей. В ней также кратко показаны некоторые из основных способов доступа к данным модели.

|Предпосылки |[Django Tutorial Part 2: Creating a skeleton website](#django-2-создание-скелета).
|-----|----
|Задача: |Научиться проектировать и создавать свои собственные модели, выбирая подходящие поля.

### Обзор

Веб-приложения Django получают доступ и управляют данными через объекты Python, называемые моделями. Модели определяют структуру хранимых данных, включая типы полей и, возможно, их максимальный размер, значения по умолчанию, параметры списка выбора, текст справки для документации, текст меток для форм и т. д. Определение модели не зависит от основной базы данных - вы можете выбрать один из нескольких компонентов вашей настройки проекта. После того, как вы выбрали какую базу данных хотите использовать, вам не нужно напрямую работать с ней - вы просто пишете свою структуру модели и код, а Django делает всю грязную работу, связанную с базой данных за вас.

В этом учебнике показано, как определить и получить доступ к моделям на примере [LocalLibrary website](#django-сайт-местной-библиотеки).

### Проектирование моделей LocalLibrary

Перед тем, как вы начнёте программировать модели, стоит потратить несколько минут, чтобы подумать о том, какие данные нам нужно хранить, и о взаимоотношениях между разными объектами.

Мы знаем, что нам нужно хранить информацию о книгах (название, резюме, автор, язык, на котором написана книга, категория, ISBN) и что у нас может быть несколько доступных экземпляров (с уникальным глобальным идентификатором, статусом доступности и т. Д.). Нам может потребоваться хранить больше информации об авторе, чем просто их имя, и могут быть несколько авторов с одинаковыми или похожими именами. Мы хотим иметь возможность сортировать информацию на основе названия книги, автора, письменного языка и категории.

При проектировании ваших моделей имеет смысл иметь отдельные модели для каждого «объекта» (группа связанной информации). В этом случае очевидными объектами являются книги, экземпляры книг и авторы.

Вы также можете использовать модели для представления параметров списка выбора (например, как выпадающий список вариантов), вместо жёсткого кодирования выбора на самом веб-сайте - это рекомендуется, когда все варианты неизвестны заранее или могут измениться. Очевидные кандидаты на модели в этом случае включают жанр книги (например, «Научная фантастика», «Французская поэзия» и т. д.) И язык (английский, французский, японский).

Как только мы определились с нашими моделями и полями, нам нужно подумать об отношениях. Django позволяет вам определять отношения, как один к одному (`OneToOneField`), один ко многим (`ForeignKey`) и многие ко многим (`ManyToManyField`).

Диаграмма ассоциации UML, приведённая ниже показывает модели, которые мы определили в этом случае (в виде блоков). Как и выше, мы создали модели для книги (общие сведения о книге), экземпляр книги (статус конкретных физических копий книги, доступных в системе) и автора.Мы также решили создать модель для жанра, чтобы можно было создавать / выбирать значения через интерфейс администратора. Мы решили не иметь модель для BookInstance: status - мы жёстко закодировали значения (LOAN_STATUS), потому что мы не ожидаем их изменения. В каждом из полей вы можете увидеть имя модели, имена и типы полей, а также методы и их типы возврата.

На диаграмме также показаны зависимости между моделями, включая их *множители*. Множители представляют собой числа на диаграмме, показывающие минимум и максимум единиц каждой модели, которые могут присутствовать в этой связи. Например, соединительная линия между ящиками показывает, что книга и жанр связаны между собой. Цифры, близкие к модели жанра, показывают, что у книги может быть один или несколько жанров (сколько угодно), а числа на другом конце строки рядом с моделью книги показывают, что у жанра может быть ноль или более связанных книг.

![diargam](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Models/local_library_model_uml.png)

> **Примечание:** В следующем разделе приведён базовый пример, поясняющий, как модели определяются и используются. Когда вы его прочитаете, подумайте, как мы построим каждую из моделей на диаграмме выше.

[Назад к Django](#django)

### Модель для начинающих

В этом разделе представлен краткий обзор того, как определяется модель, и некоторые из наиболее важных полей и аргументы поля.

### Определение модели

Модели обычно определяются в приложении **models.py**. Они реализуются как подклассы `django.db.models.Model`, и могут включать поля, методы и метаданные. В приведённом ниже фрагменте кода показана «типичная» модель, названная `MyModelName`:
```py
from django.db import models
from django.urls import reverse

class MyModelName(models.Model):
    """Типичный класс модели, производный от класса Model."""

    # Поля
    my_field_name = models.CharField(max_length=20, help_text='Введите описание поля')
    # …

    # Метаданные
    class Meta:
        ordering = ['-my_field_name']

    # Methods
    def get_absolute_url(self):
        """Возвращает URL-адрес для доступа к определенному экземпляру MyModelName."""
        return reverse('model-detail-view', args=[str(self.id)])

    def __str__(self):
        """Строка для представления объекта MyModelName (например, в административной панели и т.д.)."""
        return self.my_field_name
```

В следующих разделах мы подробно рассмотрим каждый элемент внутри модели:

### Поля

Модель может иметь произвольное количество полей любого типа - каждый представляет столбец данных, который мы хотим сохранить в одной из наших таблиц базы данных. Каждая запись (строка) базы данных будет состоять из одного значения каждого поля. Давайте рассмотрим приведённый выше пример:
```py
my_field_name = models.CharField(max_length=20, help_text="Введите описание поля")
```

Наш вышеприведённый пример имеет одно поле, называемое `my_field_name`, типа `models.CharField` — что означает, что это поле будет содержать строки буквенно-цифровых символов. Типы полей назначаются с использованием определённых классов, которые определяют тип записи, которая используется для хранения данных в базе данных, а также критерии проверки, которые должны использоваться, когда значения получены из формы HTML (то есть, что составляет действительное значение). Типы полей также могут принимать аргументы, которые дополнительно определяют, как поле хранится или может использоваться. В этом случае мы даём нашему полю два аргумента:

- `max_length=20` — Указывает, что максимальная длина значения в этом поле составляет 20 символов.
- `help_text="Введите описание поля"` — предоставляет текстовую метку для отображения, чтобы помочь пользователям узнать, какое значение необходимо предоставить, когда это значение должно быть введено пользователем через HTML-форму.

Имя поля используется для обращения к нему в запросах и шаблонах. В полях также есть метка, которая задаётся как аргумент (`verbose_name`), либо выводится путём заглавной буквы первой буквы имени переменной поля и замены любых символов подчёркивания пробелом (например, `my_field_name` будет иметь метку по умолчанию *My field name*).

Порядок, в котором объявляются поля, будет влиять на их порядок по умолчанию, если модель отображается в форме (например, на сайте администратора), хотя это может быть переопределено.

[Назад к Django](#django)

### Общие аргументы поля

Следующие общие аргументы могут использоваться при объявлении многих / разных типов полей:

- [help_text:](https://docs.djangoproject.com/en/2.1/ref/models/fields/#help-text) Предоставляет текстовую метку для HTML-форм (например, на сайте администратора), как описано выше.
- [verbose_name:](https://docs.djangoproject.com/en/2.1/ref/models/fields/#verbose-name) Удобочитаемое имя для поля, используемого в поле метки. Если не указано, Django выведет по умолчанию подробное название от имени поля.
- [default:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#default) Значение по умолчанию для поля. Это может быть значение или вызываемый объект, и в этом случае объект будет вызываться каждый раз, когда создаётся новая запись.
- [null:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#null) Если True, Django будет хранить пустые значения как NULL в базе данных для полей, где это уместно (CharField вместо этого сохранит пустую строку). По умолчанию используется значение False.
- [blank:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#blank) Если True, поле может быть пустым в ваших формах. По умолчанию используется значение False, что означает, что проверка формы Django заставит вас ввести значение. Это часто используется с null = True, потому что если вы хотите разрешить пустые значения, вы также хотите, чтобы база данных могла представлять их соответствующим образом.
- [choices:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#choices) Группа вариантов для этого поля. Если это предусмотрено, по умолчанию соответствующий виджет формы будет полем выбора с этими вариантами вместо стандартного текстового поля.
- [primary_key:](https://docs.djangoproject.com/en/2.2/ref/models/fields/#primary-key) Если True, задаёт текущее поле в качестве первичного ключа для модели (первичный ключ - это специальный столбец базы данных, предназначенный для однозначной идентификации всех разных записей таблицы). Если в качестве первичного ключа не указано поле, Django автоматически добавит для этой цели поле.

Есть много других вариантов - вы можете просмотреть [full list of field options here](https://docs.djangoproject.com/en/2.2/ref/models/fields/).

[Назад к Django](#django)

### Общие типы полей

Следующие общие аргументы могут использоваться при объявлении многих / разных типов полей:

- [CharField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.CharField) Используется для определения строк фиксированной длины от короткой до средней. Вы должны указать max_length для хранения данных.
- [TextField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.TextField) используется для больших строк произвольной длины. Вы можете указать `max_length` для поля, но это используется только тогда, когда поле отображается в формах (оно не применяется на уровне базы данных).
- [IntegerField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.IntegerField) это поле для хранения значений (целого числа) и для проверки введённых значений в виде целых чисел в формах.
- [DateField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.DateField) и [DateTimeField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.DateTimeField) используются для хранения / представления дат и информации о дате / времени (как Python datetime.date и datetime.datetime, соответственно). Эти поля могут дополнительно объявлять (взаимоисключающие) параметры `auto_now=True` (для установки поля на текущую дату каждый раз, когда модель сохраняется), auto_now_add (только для установки даты, когда модель была впервые создана) и по умолчанию (чтобы установить дату по умолчанию, которую пользователь может переустановить).
- [EmailField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.EmailField) используется для хранения и проверки адресов электронной почты.
- [FileField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.FileField) и [ImageField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ImageField) используются для загрузки файлов и изображений соответственно (`ImageField` просто добавляет дополнительную проверку, что загруженный файл является изображением). Они имеют параметры для определения того, как и где хранятся загруженные файлы.
- [AutoField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.AutoField) - это особый тип IntegerField, который автоматически увеличивается. Первичный ключ этого типа автоматически добавляется в вашу модель, если вы явно не укажете его.
- [ForeignKey](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ForeignKey) Используется для указания отношения «один ко многим» к другой модели базы данных (например, автомобиль имеет одного производителя, но производитель может делать много автомобилей). «Одна» сторона отношения - это модель, содержащая ключ.
- [ManyToManyField](https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ManyToManyField) используется для определения отношения «многие ко многим» (например, книга может иметь несколько жанров, и каждый жанр может содержать несколько книг). В нашем приложении для библиотек мы будем использовать их аналогично ForeignKeys, но их можно использовать более сложными способами для описания отношений между группами. Они имеют параметр on_delete, чтобы определить, что происходит, когда связанная запись удаляется (например, значение `models.SET_NULL` просто установило бы значение NULL)

Существует много других типов полей, включая поля для разных типов чисел (большие целые числа, малые целые числа, дробные), логические значения, URL-адреса, slugs, уникальные идентификаторы и другие «связанные с временем» сведения (продолжительность, время и т. д.). Вы можете просмотреть [full list here](https://docs.djangoproject.com/en/1.10/ref/models/fields/#field-types).

[Назад к Django](#django)

### Метаданные

Вы можете объявить метаданные на уровне модели для своей модели, объявив класс Meta, как показано на рисунке.
```py
class Meta:
    ordering = ["-my_field_name"]
    ...
```

Одной из наиболее полезных функций этих метаданных является управление сортировка записей, возвращаемых при запросе типа модели. Вы можете сделать это, указав соответствия названия полей для сортировки, как показано выше. Порядок будет зависеть от типа поля (поля символов отсортированы в алфавитном порядке, а поля даты отсортированы в хронологическом порядке). Как показано выше, вы можете префикс имени поля минус-символом (`-`), чтобы изменить порядок сортировки.

Например, если мы решили сортировать книги по умолчанию:
```py
ordering = ["title", "-pubdate"]
```

Книги будут отсортированы по алфавиту по названию, от A-Z, а затем по дате публикации внутри каждого названия, от самого нового до самого старого.

Другим распространённым атрибутом является verbose_name, подробное имя для класса в единственной и множественной форме:
```py
verbose_name = "BetterName"
```

Другие полезные атрибуты позволяют создавать и применять новые «разрешения доступа» для модели (разрешения по умолчанию применяются автоматически), разрешить упорядочение на основе другого поля или объявить, что класс является «абстрактным» (базовый класс, для которого вы не можете создавать записи, и вместо этого будет создан для создания других моделей). Многие другие параметры метаданных управляют тем, какая база данных должна использоваться для модели и как хранятся данные (это действительно полезно, если вам нужно сопоставить модель с существующей базой данных). Полный список опций метаданных доступен здесь: [Model metadata options](https://docs.djangoproject.com/en/2.2/ref/models/options/#model-meta-options) (Django документация).

### Методы

Модель также может иметь методы. Минимально в каждой модели вы должны определить стандартный метод класса для Python `__str __ ()`, чтобы вернуть удобочитаемую строку для каждого объекта. Эта строка используется для представления отдельных записей на сайте администрирования (и в любом другом месте, где вам нужно обратиться к экземпляру модели). Часто это возвращает поле названия или имени из модели.
```py
Copy to Clipboard
def __str__(self):
    return self.field_name
```

Другим распространённым методом включения в модели Django является `get_absolute_url ()`, который возвращает URL-адрес для отображения отдельных записей модели на веб-сайте (если вы определяете этот метод, тогда Django автоматически добавит кнопку «Просмотр на сайте» на экранах редактирования записей модели на сайте администратора). Типичный шаблон для `get_absolute_url ()` показан ниже.
```py
def get_absolute_url(self):
    """
    Returns the url to access a particular instance of the model.
    """
    return reverse('model-detail-view', args=[str(self.id)])
```

> **Примечание:** Предполагается, что вы будете использовать URL-адреса, например **/myapplication/mymodelname/2**, для отображения отдельных записей для вашей модели (где «2» - это идентификатор для определённой записи), вам нужно будет создать URL-карту, чтобы передать ответ и идентификатор «Образцовое представление модели» (которое будет выполнять работу, необходимую для отображения записи). Вышеуказанная функция `reverse ()` может «перевернуть» ваш URL-адрес (в приведённом выше примере с именем «model-detail-view»), чтобы создать URL-адрес правильного формата.
>
>Конечно, для выполнения этой работы вам всё равно придётся писать сопоставление URL-адрес, просмотр и шаблон!

Вы также можете определить любые другие методы, которые вам нравятся, и вызывать их из вашего кода или шаблонов (при условии, что они не принимают никаких параметров).

[Назад к Django](#django)

### Управление моделью

После того, как вы определили свои классы моделей, вы можете использовать их для создания, обновления или удаления записей и для запуска запросов для получения всех записей или отдельных подмножеств записей. Мы покажем вам, как это сделать в учебнике, когда мы определяем наши представления, с кратким обзором.

- **Создание и изменение записей**

Чтобы создать запись, вы можете определить экземпляр модели, а затем вызвать метод `save()`.

```py
# Create a new record using the model's constructor.
a_record = MyModelName(my_field_name="Instance #1")

# Save the object into the database.
a_record.save()
```

> **Примечание:** Если вы не указали какое-либо поле в качестве primary_key, новая запись будет выдаваться автоматически, с идентификатором имени поля. Вы можете запросить это поле после сохранения указанной выше записи, и оно будет иметь значение 1.

Вы можете получить доступ к полям в этой новой записи с использованием синтаксиса точек и изменить значения. Вы должны вызвать `save()`, чтобы сохранить изменённые значения в базе данных.
```py
Copy to Clipboard
# Access model field values using Python attributes.
print(a_record.id) #should return 1 for the first record.
print(a_record.my_field_name) # should print 'Instance #1'

# Change record by modifying the fields, then calling save().
a_record.my_field_name="New Instance Name"
a_record.save()
```

- **Поиск записей**

Вы можете искать записи, соответствующие определённым критериям, используя атрибут объектов модели (предоставляемый базовым классом).

> **Примечание:** Объяснение того, как искать записи, используя «абстрактную» модель и имена полей, может быть немного запутанным. В приведённом ниже обсуждении мы будем ссылаться на модель книги с полями названия и жанра, где жанр также является моделью с единственным именем в поле.

Мы можем получить все записи для модели как объект **QuerySet**, используя `objects.all()`. **QuerySet** - это итерируемый объект, означающий, что он содержит несколько объектов, которые мы можем перебирать / прокручивать.
```py
all_books = Book.objects.all()
```

Метод `filter()` Django позволяет отфильтровать возвращаемый **QuerySet** для соответствия указанному текстовому или числовому полю по конкретным критериям. Например, чтобы отфильтровать книги, содержащие слово «wild» («дикие») в заголовке, а затем подсчитать их, мы могли бы сделать следующее.
```py
wild_books = Book.objects.filter(title__contains='wild')
number_wild_books = Book.objects.filter(title__contains='wild').count()
```

Соответствующие поля и тип соответствия определяются в имени параметра фильтра, используя формат: `field_name__match_type` (обратите внимание на двойное подчёркивание между заголовком выше). Выше мы фильтруем заголовок с учётом регистра. Есть много других типов совпадений, которые вы можете сделать: `icontains` (без учёта регистра), `iexact` (точное совпадение без учёта регистра), `exact` (точное совпадение с учётом регистра ) и `in`, `gt` (больше), `startswith` и т.д. [Смотреть полный список](https://docs.djangoproject.com/en/2.2/ref/models/querysets/#field-lookups) (Django Docs, [EN]).

В некоторых случаях вам нужно будет фильтровать поле, которое определяет отношение «один ко многим» к другой модели (например, `ForeignKey`). В этом случае вы можете «индексировать» поля в связанной модели с дополнительными двойными подчёркиваниями. Так, например, чтобы фильтровать книги с определённым жанровым рисунком, вам нужно будет указывать имя в поле жанра, как показано ниже:
```py
books_containing_genre = Book.objects.filter(genre__name__icontains='fiction')  # Will match on: Fiction, Science fiction, non-fiction etc.
```

> **Примечание:** Вы можете использовать символы подчёркивания (`__`) для навигации по многим уровням отношений (ForeignKey / ManyToManyField) по своему усмотрению. Например, книга, имеющая разные типы, определяемая с использованием дополнительной связи «обложка», может иметь имя параметра: type__cover__name__exact = 'hard'.

Существует гораздо больше возможностей для запросов, включая обратные поиски от связанных моделей, цепочки фильтров, возврат меньшего набора значений и т. д. Для получения дополнительной информации см. [Making queries](https://docs.djangoproject.com/en/2.2/topics/db/queries/) (Django Docs, [EN]).

[Назад к Django](#django)

### Определение моделей LocalLibrary

В этом разделе мы начнём определять модели для библиотеки. Откройте **models.py** (в / locallibrary / catalog /). Шаблон в верхней части страницы импортирует модуль моделей, который содержит базовый класс модели `models.Model`, от которого наследуются наши модели.
```py
from django.db import models

# Create your models here.
```

### Модель жанра

Скопируйте приведённый ниже код модели `Genre` и вставьте его в нижнюю часть вашего файла **models.py**. Эта модель используется для хранения информации о категории книг - например, будь то художественная или документальная, роман или военно-историческая и т. д. Как уже упоминалось выше, мы создали жанр как модель, а не как свободный текст или список выбора, чтобы возможные значения могли управляться через базу данных, а не были закодированными.
```py
Copy to Clipboard
class Genre(models.Model):
    """
    Model representing a book genre (e.g. Science Fiction, Non Fiction).
    """
    name = models.CharField(max_length=200, help_text="Enter a book genre (e.g. Science Fiction, French Poetry etc.)")

    def __str__(self):
        """
        String for representing the Model object (in Admin site etc.)
        """
        return self.name
```

Модель имеет один `CharField` field (имя), которое используется для описания жанра (оно ограничено 200 символами и имеет некоторый `help_text`. В конце модели мы объявляем метод `__str__()`, который просто возвращает имя жанра, определённого конкретной записью. Verbose name не был определён, поэтому поле будет называться `Name` в формах.

[Назад к Django](#django)

### Модель книги

Скопируйте модель книги ниже и снова вставьте её в нижнюю часть файла. Модель книги представляет всю информацию о доступной книге в общем смысле, но не конкретный физический «экземпляр» или «копию» для временного использования. Модель использует CharField для представления названия книги и isbn (обратите внимание, как isbn указывает свой ярлык как «ISBN», используя первый неименованный параметр, поскольку в противном случае ярлык по умолчанию был бы «Isbn»). Модель использует TextField для summary, потому что этот текст, возможно, должен быть очень длинным.
```py
from django.urls import reverse #Used to generate URLs by reversing the URL patterns

class Book(models.Model):
    """
    Model representing a book (but not a specific copy of a book).
    """
    title = models.CharField(max_length=200)
    author = models.ForeignKey('Author', on_delete=models.SET_NULL, null=True)
    # Foreign Key used because book can only have one author, but authors can have multiple books
    # Author as a string rather than object because it hasn't been declared yet in the file.
    summary = models.TextField(max_length=1000, help_text="Enter a brief description of the book")
    isbn = models.CharField('ISBN',max_length=13, help_text='13 Character <a href="https://www.isbn-international.org/content/what-isbn">ISBN number</a>')
    genre = models.ManyToManyField(Genre, help_text="Select a genre for this book")
    # ManyToManyField used because genre can contain many books. Books can cover many genres.
    # Genre class has already been defined so we can specify the object above.

    def __str__(self):
        """
        String for representing the Model object.
        """
        return self.title


    def get_absolute_url(self):
        """
        Returns the url to access a particular book instance.
        """
        return reverse('book-detail', args=[str(self.id)])
```

Жанр представляет из себя `ManyToManyField`, так что книга может иметь несколько жанров, а жанр может иметь много книг. Автор объявляется через `ForeignKey`, поэтому в каждой книге будет только один автор, но у автора может быть много книг (на практике книга может иметь несколько авторов, но не в такой реализации!)

В обоих типах полей соответствующий класс модели объявляется как первый неименованный параметр, используя либо класс модели, либо строку, содержащую имя соответствующей модели. Вы должны использовать имя модели как строку, если связанный класс ещё не был определён в этом файле до того, как он будет указан! Другими параметрами, представляющими интерес для поля автора, являются `null=True`, которое позволяет базе данных хранить значение `Null` , если автор не выбран, и on_delete = models. `SET_NULL` установит значение автора в Null, если связанная с автором запись будет удалена.

Модель также определяет `__str __()`, используя поле заголовка книги для представления книги. Окончательный метод `get_absolute_url()` возвращает URL-адрес, который можно использовать для доступа к подробной записи для этой модели (для этого нам нужно будет определить сопоставление URL-адресов, в котором содержится подробная информация о книге, и определить связанное представление и шаблон ).

[Назад к Django](#django)

### Модель BookInstance

Затем скопируйте модель BookInstance (показано ниже) под другие модели. BookInstance представляет собой определённую копию книги, которую кто-то может брать взаймы, и включает информацию о том, доступна ли копия или в какой день она ожидается, «отпечаток» или сведения о версии, а также уникальный идентификатор книги в библиотеке. Теперь некоторые из полей и методов будут знакомы. Модель использует

- `ForeignKey` для идентификации связанной книги (в каждой книге может быть много копий, но в копии может быть только одна книга).
- `CharField`, для представления данных (конкретного выпуска) о книге.
```py
import uuid # Required for unique book instances

class BookInstance(models.Model):
    """
    Model representing a specific copy of a book (i.e. that can be borrowed from the library).
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, help_text="Unique ID for this particular book across whole library")
    book = models.ForeignKey('Book', on_delete=models.SET_NULL, null=True)
    imprint = models.CharField(max_length=200)
    due_back = models.DateField(null=True, blank=True)

    LOAN_STATUS = (
        ('m', 'Maintenance'),
        ('o', 'On loan'),
        ('a', 'Available'),
        ('r', 'Reserved'),
    )

    status = models.CharField(max_length=1, choices=LOAN_STATUS, blank=True, default='m', help_text='Book availability')

    class Meta:
        ordering = ["due_back"]


    def __str__(self):
        """
        String for representing the Model object
        """
        return '%s (%s)' % (self.id,self.book.title)
```

Мы дополнительно объявляем несколько новых типов полей:

- `UUIDField` используется для поля **id**, чтобы установить его как **primary_key** для этой модели. Этот тип поля выделяет глобальное уникальное значение для каждого экземпляра (по одному для каждой книги, которую вы можете найти в библиотеке).
- `DateField` используется для данных **due_back** (при которых ожидается, что книга появится после заимствования или обслуживания). Это значение может быть `blank` или `null` (необходимо, когда книга доступна). Метаданные модели (Class Meta) используют это поле для упорядочивания записей, когда они возвращаются в запросе.
- status - это `CharField`, который определяет список **choice/selection**. Как вы можете видеть, мы определяем кортеж, содержащий кортежи пар ключ-значение и передаём его аргументу выбора. Значение в **key/value** паре - это отображаемое значение, которое пользователь может выбрать, а ключи - это значения, которые фактически сохраняются, если выбрана опция. Мы также установили значение по умолчанию **«m»** (техническое обслуживание), поскольку книги изначально будут созданы недоступными до того, как они будут храниться на полках.

Модель `__str__()` представляет объект BookInstance, используя комбинацию его уникального идентификатора и связанного с ним заголовка книги.

> **Примечание:** Немного о Python:
> Значение, возвращаемое `__str__()`, является форматированной строкой. В строке мы используем `%S` для объявления 'placeholders'. После строки укажем `%`, а затем кортеж, содержащий значения, которые будут вставлены в заполнители. Если у вас просто один заполнитель, вы можете опустить кортеж - например, 'Моё значение:% S' % переменная.
>
> Обратите также внимание на то, что, хотя этот подход совершенно применим, но он более не является предпочтительным. Начиная с Python 3, вы должны использовать метод format, например. `'{0} ({1})'.format(self.id, self.book.title)`. Вы можете узнать больше об этом [здесь](https://www.python.org/dev/peps/pep-3101/).

### Модель автора

Скопируйте модель автора (показано ниже) под существующим кодом в **models.py**.

Теперь все поля/методы должны быть знакомы. Модель определяет автора как имя, фамилию, дату рождения и (необязательную) дату смерти. Он указывает, что по умолчанию `__str__()` возвращает имя в фамилии, порядковый номер первого имени. Метод `get_absolute_url()` отменяет сопоставление URL-адреса автора с целью получения URL-адреса для отображения отдельного автора.
```py
class Author(models.Model):
    """
    Model representing an author.
    """
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    date_of_birth = models.DateField(null=True, blank=True)
    date_of_death = models.DateField('Died', null=True, blank=True)

    def get_absolute_url(self):
        """
        Returns the url to access a particular author instance.
        """
        return reverse('author-detail', args=[str(self.id)])


    def __str__(self):
        """
        String for representing the Model object.
        """
        return '%s, %s' % (self.last_name, self.first_name)
```

### Повторно выполнить миграцию базы данных

Теперь все ваши модели созданы. Теперь переустановите миграцию базы данных, чтобы добавить их в свою базу данных.
```bash
python3 manage.py makemigrations
python3 manage.py migrate
```

### Языковая модель - вызов

Представьте себе, что местный благотворитель жертвует ряд новых книг, написанных на другом языке (скажем, фарси). Задача состоит в том, чтобы определить, как они будут лучше всего представлены на нашем веб-сайте библиотеки, а затем добавить их в модели.

Некоторые вещи, которые следует учитывать:

- Должен ли «язык» ассоциироваться с Book, BookInstance или каким-либо другим объектом?
- Должны ли быть представлены разные языки с использованием модели, свободного текстового поля или жёстко запрограммированного списка выбора?
После того, как вы решили, добавьте поле. Вы можете увидеть наше решение на Github [here](https://github.com/mdn/django-locallibrary-tutorial/blob/master/catalog/models.py).

### Итог

В этой статье мы узнали, как определять модели, а затем использовать эту информацию в разработке и внедрении соответствующих моделей для сайта LocalLibrary.

На этом этапе мы отвлечёмся от создания сайта и проверим **Django Administration site**. Этот сайт позволит нам добавить некоторые данные в библиотеку, которые мы можем отобразить с помощью наших (ещё не созданных) представлений и шаблонов.

Смотрите также
[Writing your first Django app, part 2](https://docs.djangoproject.com/en/1.10/intro/tutorial02/) (Django Docs)
[Making queries](https://docs.djangoproject.com/en/1.10/topics/db/queries/) (Django Docs)
[QuerySet API Reference](https://docs.djangoproject.com/en/1.10/ref/models/querysets/) (Django Docs)


[Назад к Django](#django)

## Django 4: административная панель Django

Теперь, когда модели для сайта [местной библиотеки](#django-сайт-местной-библиотеки) созданы, добавим некоторые "настоящие" данные о книгах, используя административную панель Django Admin. Для начала мы покажем, как зарегистрировать в ней модели, потом как войти и создать какие-нибудь данные. В конце статьи мы покажем некоторые способы дальнейшего улучшения вида админ-панели.

|Предусловия: |	Сначала завершите: [Руководство часть 3:](#django-3-использование-моделей) использование моделей.
|----|----
|Цель: | Уяснить преимущества и ограничения админ-панели Django, научиться использовать её для создания записей для наших моделей.

### Обзор

*Приложение* **Django admin** может использовать ваши модели для автоматического создания части сайта, предназначенной для создания, просмотра, обновления и удаления записей. Это может сэкономить вам много времени в процессе разработки, упрощая тестирование ваших моделей на предмет правильности данных. Оно также может быть полезным для управления данными на стадии публикации, в зависимости от типа веб-сайта. Проект Django рекомендует это приложение только для управления внутренними данными (т.е.для использования администраторами, либо людьми внутри вашей организации), так как модельно-ориентированный подход не обязательно является наилучшим интерфейсом для всех пользователей и раскрывает много лишних подробностей о моделях.

Все необходимые настройки, которые необходимо включить в admin приложение вашего веб-сайта, были сделаны автоматически, когда вы [создали каркас проекта](#django-2-создание-скелета) (информацию о необходимых актуальных зависимостях смотрите здесь - [Django docs](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/)) . В результате все, что необходимо сделать для того, чтобы добавить модели в приложение admin, это *зарегистрировать* их. В конце этой статьи мы представим краткую демонстрацию того, каким образом можно дополнительно настроить админ-панель для лучшего отображения данные наших моделей.

После регистрации моделей мы покажем как создать нового суперпользователя , войти на сайт от его имени и создать книги, авторов, экземпляры книг и жанры. Это будет полезным для тестирования представлений и шаблонов, которые мы начнём создавать в следующей части руководства.

### Регистрация моделей

Вначале откройте файл **admin.py** в папке приложения (**/locallibrary/catalog/admin.py**). Пока он выглядит так (заметьте, что он уже содержит импорт `django.contrib.admin`):

```py
from django.contrib import admin

# Register your models here.
```

Зарегистрируйте модели путём вставки следующего текста в нижнюю часть этого файла. Этот код просто импортирует модели и затем вызывает `admin.site.register` для регистрации каждой из них.
```py
from .models import Author, Genre, Book, BookInstance

admin.site.register(Book)
admin.site.register(Author)
admin.site.register(Genre)
admin.site.register(BookInstance)
```

> **Примечание:** В строках выше предполагается, что вы приняли вызов создать модель, отражающую естественный язык книги ([см. обучающую статью о моделях](#django-3-использование-моделей))!

Это самый простой способ регистрации модели или моделей. Админ-панель имеет множество настроек. Мы рассмотрим другие способы регистрации ваших моделей ниже.

[Назад к Django](#django)

### Создание суперпользователя

Для того, чтобы войти в админ-панель, нам необходимо иметь учётную запись пользователя со статусом *Staff (сотрудники)*. Для просмотра и создания записей, пользователю также понадобится разрешение для управления всеми нашими объектами. Вы можете создать учётную запись **"superuser"**, которая даёт полный доступ к сайту и все необходимые разрешения, используя **manage.py**.

Для создания суперпользователя вызовите следующую команду из той же папки, где расположен **manage.py**. Вас попросят ввести имя пользователя, адрес электронной почты и надёжный пароль.
```bash
python3 manage.py createsuperuser
```

После выполнения этой команды новый суперпользователь будет добавлен в базу данных. Теперь перезапустите сервер, чтобы можно было протестировать вход на сайт:
```bash
python3 manage.py runserver
```

### Вход в админ-панель и её использование

Для входа в админ-панель откройте ссылку `/admin` (например `http://127.0.0.1:8000/admin`) и введите логин и пароль вашего нового суперпользователя (вас перенаправят на login-страницу и потом обратно на /admin после ввода всех деталей).

В этой части сайта отображаются все наши модели, сгруппированные по установленному приложению. Вы можете кликнуть на названии модели, чтобы получить список всех связанных записей, далее можете кликнуть на этих записях, для их редактирования . Также можно непосредственно кликнуть на ссылку **Add**, расположенную рядом с каждой моделью, чтобы начать создание записи этого типа.

![admin panel](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_home.png)

Кликните на ссылке **Add** справа от *Books*, чтобы создать новую книгу (появится диалоговое окно как на картинке внизу). Заметьте, что заголовок каждого поля - это тип используемого виджета, и `help_text` (если есть) совпадает со значением, которое вы указали в модели.

Введите значение для полей. Вы можете создавать новых авторов или жанры, нажимая на значок "`+`", расположенный рядом с соответствующим полем (или выберите существующее значение из списков, если вы уже создали их). Когда вы закончили, нажмите на **SAVE, Save and add another**, или **Save and continue editing**, чтобы сохранить записи.

![add book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_add.png)

> **Примечание:** А сейчас, хотелось бы, чтобы вы добавили несколько книг, авторов и жанров (например, Фэнтези) в ваше приложение. Удостоверьтесь, что каждый автор и жанр включает пару различных книг (позже, когда мы реализуем представления "list" и "detail", это сделает их более интересными).

После того, когда книги добавлены, для перехода на главную страницу админ-панели кликните на ссылке **Home** в верхней части страницы. Потом кликните на ссылке **Books** для отображения текущего списка книг (или на одной из других ссылок, чтобы увидеть список соответствующей модели). После добавления нескольких книг список может выглядеть наподобие скриншота ниже. Отображается название каждой из книг. Его возвращает метод `__str__()` в модели Book, созданной в предыдущей статье.

![add books](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_list.png)

Для удаления книги из этого списка выберите чекбокс рядом с ней и действие *delete*... из выпадающего списка *Action*, а затем нажмите кнопку **Go**. Также можно добавить новую книгу, нажав на кнопку **ADD BOOK**.

Вы можете редактировать книгу, кликнув по ссылке с её названием. Страница редактирования книги, приведённая ниже, практически идентична странице добавления новой книги. Основные отличия - это заголовок страницы (*Change book*) и наличие кнопок **Delete**, **HISTORY** и **VIEW ON SITE**. Последняя присутствует, так как мы определили метод `get_absolute_url()` в нашей модели.

![edit book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_book_modify.png)

Теперь перейдите назад на страницу **Home** (используя ссылку *Home* в навигационной цепочке вверху страницы) и просмотрите списки **Author** и **Genre**. В них уже должно быть несколько элементов, созданных при добавлении новых книг. Если хотите, добавьте ещё.

Однако у вас не будет ни одного экземпляра книги, потому что они не создаются из модели `Book` (хотя можно создать книгу из модели `BookInstance` — такова природа поля `ForeignKey`). Для отображения страницы *Add book instance* (см. рисунок ниже) вернитесь на страницу *Home* и нажмите кнопку **Add**. Обратите внимание на длинный уникальный **Id** для идентификации конкретного экземпляра книги в библиотеке.

![book instance](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_bookinstance_add.png)

Создайте несколько экземпляров для каждой из ваших книг. Установите статус *Available (доступен*) для некоторых экземпляров и *On loan (выдан)* для остальных. Если статус экземпляра **not** *Available (недоступен)*, то также установите дату возврата (*Due back*).

Вот и все! Вы изучили как запустить и использовать админ-панель. Также были созданы записи для `Book`, `BookInstance`, `Genre` и `Author`, которые можно будет использовать после создания наших собственных представлений и шаблонов.

[Назад к Django](#django)

### "Продвинутая" конфигурация

Django выполняет неплохую работу по созданию базовой админ-панели используя информацию из зарегистрированных моделей:

- Каждая модель имеет список записей, каждая из которых идентифицируется строкой, создаваемой методом `__str__()` модели, и связана с представлением для её редактирования. По умолчанию, в верхней части этого представления находится меню действий, которое может быть использовано для удаления нескольких записей за раз
- Формы для редактирования и добавления записей содержат все поля модели, которые расположены вертикально в порядке их объявления в модели.

Можно настроить интерфейс пользователя для упрощения его использования. Некоторые доступные настройки:

- List views:
  - добавление дополнительных отображаемых полей или информации для каждой записи.
  - добавление фильтров для отбора записей по разным критериям (например, статус выдачи книги).
  - добавление дополнительных вариантов выбора в меню действий и места расположения этого меню на форме.

- Detail views
  - выбор отображаемых полей, их порядка, группирования и т.д.
  - добавление связанных полей к записи (например, возможности добавления и редактирования записей книг при создании записи автора).

В этом разделе рассмотрим некоторые изменения для совершенствования интерфейса пользователя нашей местной библиотеки, а именно: добавление дополнительной информации в списки моделей `Book` и `Author` , а также улучшение расположения элементов соответствующих представлений редактирования. Пользовательский интерфейс моделей `Language` and `Genre` изменять не будем, так как это не даст заметного улучшения, поскольку он содержит только по одному полю!

Полное руководство по всем возможным вариантам настройки админ-панели можно найти в The [Django Admin site](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/) (документация Django).

### Регистрация класса ModelAdmin

Для изменения отображения модели в пользовательском интерфейсе админ-панели, необходимо определить класс [ModelAdmin](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#modeladmin-objects) (он описывает расположение элементов интерфейса, где Model - наименование модели) и зарегистрировать его для использования с этой моделью.

Давайте начнём с модели Author. Откройте файл **admin.py** в каталоге приложения (**/locallibrary/catalog/admin.py**). Закомментируйте исходную регистрацию (используя префикс #) этой модели:
```js
# admin.site.register(Author)
```

Теперь добавьте новый класс `AuthorAdmin` и зарегистрируйте его как показано ниже:
```py
# Define the admin class
class AuthorAdmin(admin.ModelAdmin):
    pass

# Register the admin class with the associated model
admin.site.register(Author, AuthorAdmin)
```

Сейчас мы добавим классы `ModelAdmin` для моделей `Book`, и `BookInstance`. Нам снова нужно закомментировать исходную регистрацию:
```js
# admin.site.register(Book)
# admin.site.register(BookInstance)
```

В этот раз для создания и регистрации новых моделей используем декоратор `@register` (он делает то же самое, что и метод `admin.site.register()`):
```py
# Register the Admin classes for Book using the decorator

@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    pass

# Register the Admin classes for BookInstance using the decorator

@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    pass
```

Пока что все наши admin-классы пустые (см. "`pass`"), поэтому ничего не изменится! Добавим код для задания особенностей интерфейса моделей.

[Назад к Django](#django)

### Настройка отображения списков

Сейчас приложение *LocalLibrary* отображает всех авторов, используя имя объекта, возвращаемое методом `__str__()` модели. Это приемлемо, когда есть только несколько авторов, но, если их количество значительно, возможны дубликаты. Чтобы различить их или просто отобразить более интересную информацию о каждом авторе, можно использовать [list_display](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display) (для добавления дополнительных полей).

Замените класс `AuthorAdmin` кодом, приведённым ниже. Названия полей, которые будут отображаться в списке, перечислены в кортеже **list_display** в требуемом порядке (это те же имена, что и в исходной модели).
```py
Copy to Clipboard
class AuthorAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'date_of_birth', 'date_of_death')
```

Перезапустите сайт и перейдите к списку авторов. Указанные поля должны отображаться следующим образом:

![autors list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_author_list.png)

Для нашей модели `Book` добавим отображение полей `author` и `genre`. Поле `author` - это внешний ключ (`ForeignKey` ) связи один к одному, поэтому оно будет представлено значением `__str()__` для связанной записи. Замените класс `BookAdmin` на версию, приведённую ниже.
```py
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'display_genre')
```

К сожалению, мы не можем напрямую поместить поле genre в `list_display`, так как оно является `ManyToManyField` (Django не позволяет это из-за большой "стоимости" доступа к базе данных). Вместо этого мы определим функцию `display_genre` для получения строкового представления информации (вызов этой функции есть в `list_display`, её определение см. ниже).

> **Примечание:** Получение здесь значения поля `genre` возможно не самая хорошая идея вследствие "стоимости" операции базы данных. Мы показываем это, потому что вызов функций в ваших моделях может быть очень полезен по другим причинам, например, для добавления ссылки *Delete* рядом с каждым пунктом списка.

Добавьте следующий код в вашу модель `Book` (**models.py**). В нем создаётся строка из первых трёх значений поля `genre` (если они существуют) и `short_description`, которое может быть использовано в админ-панели.
```py
    def display_genre(self):
        """
        Creates a string for the Genre. This is required to display genre in Admin.
        """
        return ', '.join([ genre.name for genre in self.genre.all()[:3] ])
    display_genre.short_description = 'Genre'
```

После сохранения модели и обновления админ-панели, перезапустите её и перейдите на страницу списка *Books*. Вы должны увидеть список книг, наподобие приведённого ниже:

![books](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_book_list.png)

Модель `Genre` (и модель `Language`, если вы её определили) имеет единственное поле. Поэтому нет необходимости создания для них дополнительных моделей с целью отображения дополнительных полей.

> **Примечание:** Целесообразно, чтобы в списке модели `BookInstance` отображались хотя бы статус и ожидаемая дата возврата. Мы добавили это в качестве "испытания" в конце этой статьи!

[Назад к Django](#django)

### Добавление фильтров списка

Если в вашем списке есть множество элементов, может быть полезной возможность фильтрации отображаемых пунктов. Это выполняется путём перечисления их в атрибуте `list_filter`. Замените класс `BookInstanceAdmin` на следующий:
```py
class BookInstanceAdmin(admin.ModelAdmin):
    list_filter = ('status', 'due_back')
```

Представление списка теперь будет содержать панель фильтрации справа. Обратите внимание, как выбирать даты и статус для фильтрации:

![filter panel](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_bookinstance_list_filters.png)

### Формирование макета с подробным представлением

По умолчанию в представлениях деталей отображаются все поля по вертикали в порядке их объявления в модели. Вы можете изменить порядок декларации, какие поля отображаются (или исключены), используются ли разделы для организации информации, отображаются ли поля горизонтально или вертикально, и даже какие виджеты редактирования используются в админ-формах.

> **Примечание:** Модели LocalLibrary относительно просты, поэтому нам не нужно менять макет, но мы всё равно внесём некоторые изменения, просто чтобы показать вам, как это сделать.

### Управление отображаемыми и вложенными полями

Обновите ваш AuthorAdmin класс, чтобы добавить строку полей, как показано ниже:
```py
class AuthorAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'date_of_birth', 'date_of_death')
    fields = ['first_name', 'last_name', ('date_of_birth', 'date_of_death')]
```

Атрибут полей перечисляет только те поля, которые должны отображаться в форме, по порядку. Поля отображаются по вертикали по умолчанию, но будут отображаться горизонтально, если вы дополнительно группируете их в кортеже (как показано в полях «date» выше).

Перезагрузите приложение и перейдите к подробному представлению автора - он должен теперь отображаться, как показано ниже:

![change autor](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_author_detail.png)

> **Примечание:** Так же, вы можете использовать `exclude` атрибут для объявления списка атрибутов, которые будут исключены из формы (все остальные атрибуты в модели, будут отображаться).

[Назад к Django](#django)

### Разделение на секции/Выделение подробного представления

Вы можете добавлять "разделы" (sections) для группировки связанной информации в модели в форме детализации, используя атрибут [fieldsets](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.fieldsets) .

В модели `BookInstance` мы имеем информацию соответствия конкретной книги (т.е. `name`, `imprint`, and `id`) и датой когда она вновь станет доступной (`status`, `due_back`). Мы можем добавить их в разные секции, добавив текст жирным шрифтом в наш `BookInstanceAdmin` класс.
```py
@admin.register(BookInstance)
class BookInstanceAdmin(admin.ModelAdmin):
    list_filter = ('status', 'due_back')

    fieldsets = (
        (None, {
            'fields': ('book','imprint', 'id')
        }),
        ('Availability', {
            'fields': ('status', 'due_back')
        }),
    )
```

Каждая секция имеет свой заголовок (или `None`, если заголовок не нужен) и ассоциированный кортеж полей в словаре - формат сложный для описания, но относительно простой для понимания, если вы посмотрите на фрагмент кода, представленный выше.

Перезапустите сайт и перейдите к списку экземпляров; форма должна отображаться следующим образом:

![instace list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_bookinstance_detail_sections.png)

### Встроенное редактирование связанных записей

Иногда бывает полезно иметь возможность добавлять связанные записи одновременно. Например, имеет смысл иметь как информацию о книге, так и информацию о конкретных копиях, которые вы получили на той же странице подробностей. К примеру, вполне логично получить и информацию о книге, и информацию о конкретных копиях, зайдя на страницу детализации.

Вы можете это сделать, объявив [inlines](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.inlines), и указав тип [TabularInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.TabularInline) (горизонтальное расположение) или [StackedInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.StackedInline) (вертикальное расположение, так же как и в модели по умолчанию). Вы можете добавить `BookInstance` информацию в подробное описание `Book` , добавив строки, представленные ниже и располагающиеся рядом с `BookAdmin`:
```py
class BooksInstanceInline(admin.TabularInline):
    model = BookInstance

@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'display_genre')
    inlines = [BooksInstanceInline]
```

Попробуйте перезапустить приложение, а затем взгляните на представление книги — внизу вы должны увидеть экземпляры книги, относящиеся к этой книге:

![book instance](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Admin_site/admin_improved_book_detail_inlines.png)

В этом случае, всё, что мы сделали - объявили наш встроенный класс tablular, который просто добавляет все поля из встроенной модели. Вы можете указать все виды дополнительной информации для макета, включая отображаемые поля, их порядок, независимо от того, являются ли они только для чтения или нет, и т. д. (См. [TabularInline](https://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.TabularInline) для получения дополнительной информации).

> **Примечание:** В этой функции есть некоторые неприятные ограничения! На скриншоте выше у нас есть три существующих экземпляра книги, за которыми следуют три поля для новых экземпляров книги (которые очень похожи!). Было бы лучше НЕ иметь лишних экземпляров книг по умолчанию и просто добавить их с помощью ссылки **Add another Book instance** или иметь возможность просто перечислять `BookInstances` как нечитаемые здесь ссылки. Первый вариант можно сделать, установив `extra` атрибут в 0 в модели `BookInstanceInline`, попробуйте сами.

[Назад к Django](#django)

### Проверьте себя

Мы многое изучили в этом разделе и теперь настало время вам самостоятельно попробовать несколько вещей:

1. Для представления списка `BookInstance` , добавьте код для отображения книги, статуса, даты возврата, и id (вместо значения по умолчанию возвращаемого `__str__()`).
2. Добавьте встроенный список перечня `Book` в представление списка `Author` , используя тот же самый подход, который мы применили для `Book`/`BookInstance`.

### Заключение

Вот и всё! Теперь вы узнали, как настроить сайт администрирования как в самой простой, так и в улучшенной форме, о создании суперпользователя и о том, как перемещаться по сайту администратора, просматривать, удалять и обновлять записи. По пути вы создали множество книг, экземпляров, жанров и авторов, которые мы сможем перечислить и отобразить, как только мы создадим собственный вид и шаблоны.

Дополнительные материалы

- [Writing your first Django app, part 2: Introducing the Django Admin](https://docs.djangoproject.com/en/1.10/intro/tutorial02/#introducing-the-django-admin) (Django docs)
- [The Django Admin site](https://docs.djangoproject.com/en/1.10/ref/contrib/admin/) (Django Docs)

[Назад к Django](#django)

## Django 5: cоздание домашней страницы

Теперь мы готовы создать код нашей первой страницы — домашняя страница сайта [LocalLibrary](#django-сайт-местной-библиотеки) будет показывать количество записей в каждой модели, кроме того, она будет выводить боковую навигационную панель с ссылками на другие страницы сайта. В результате мы приобретём практический навык написания простых URL-преобразований и отображений, получения записей из базы данных и применения шаблонов.

|Требования: | Прочитать [Введение в Django](#введение). Завершить изучение предыдущих частей руководства (включая [Руководство часть 4: Django административный раздел сайта](#django-4-административная-панель-django)).
|---|---
|Цель: |Понимать как создавать простые url-преобразования (которые не содержат никаких данных) и отображения, как получать данные из моделей и создавать шаблоны.

### Обзор

Теперь, когда мы определили наши модели и создали несколько записей в них, пришло время написать код, который будет показывать данную информацию пользователям. И первое, что нам необходимо сделать это определиться какую информацию мы бы хотели показывать на наших страницах, а затем определить соответствующие URL-адреса для получения соответствующих ресурсов. Затем нам надо создать url-преобразования, отображения (функции, или классы), а затем шаблоны страницы.

Диаграмма, представленная ниже, демонстрирует главный поток данных и элементов, которые нужно реализовать для управления HTTP запросами и ответами. Поскольку мы уже создали модель, то нам остаётся создать следующее:

- URL-преобразования для перехода по соответствующему URL-адресу (с учётом информации, передаваемой в данном адресе) к соответствующей функции отображения.
- Функции отображения для запроса соответствующих данных из моделей, создание страниц HTML для показа этих данных и их отправку в клиент пользователя (в браузер).
- Шаблоны, которые используются отображениями для рендеринга (отрисовки) данных.

![blok-scheme](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Home_page/basic-django.png)

Как вы увидите в следующем разделе, у нас будет 5 страниц, которые мы немного опишем в данной статье. Данная статья, большей частью, будет сконцентрирована на реализации всего-лишь одной, домашней страницы нашего сайта (к другим страницам мы перейдём в других частях руководства). Это должно дать вам хорошее базовое представление о работе с URL-преобразованиями (связывании), отображениями и моделями.

[Назад к Django](#django)

### Определяем URL-адреса страниц

По сути, так как для конечных пользователей, данная версия сайта LocalLibrary является read-only (только для чтения), то нам надо создать домашнюю страницу и страницы, которые будут показывать списки авторов и книг, а также детальную информацию о них, соответственно.

Перечислим URL-адреса, которые понадобятся для наших страниц:

- `catalog/` — Домашняя/индексная страница.
- `catalog/books/` — Список всех книг.
- `catalog/authors/` — Список всех авторов.
- `catalog/book/<id>` — Детальная информация для определённой книги со значением первичного ключа равного `<id>`. Например, `/catalog/book/3`, для `id = 3`.
- `catalog/author/<id>` — Детальная информация для определённого автора со значением первичного ключа равного `<id>`. Например, `/catalog/author/11`, для автора с `id = 11`.

Первые три URL-адреса используются для показа домашней страницы, а также списков книг и авторов. Они не кодируют никакой дополнительной информации и результат показа данных страниц будет полностью зависеть от того, что находится в базе данных и, по сути, будет все время одним и тем же (при неизменной базе данных, конечно).

Последние два URL-адреса применяются для показа детальной информации об определённой книге, или авторе — в себе они содержат соответствующее значение идентификатора (показан как `<id>`, выше). URL-преобразование получает данную информацию и передаёт её в отображение, которое применяет её для запроса к базе данных. Для кодирования и применения данной информации в вашем URL-адресе нам понадобится только одно url-преобразование, соответствующее отображение и шаблон страницы для показа любой книги (или автора).

> **Примечание:** Django позволяет вам конструировать ваши URL-адреса любым, удобным для вас, способом — вы можете закодировать информацию в теле URL-адреса, как показано выше, или использовать URL-адрес типа `GET` (например, `/book/?id=6`). Независимо от ваших предпочтений, URL-адреса должны быть понятными, логичными и читабельными ([посмотрите совет W3C здесь](https://www.w3.org/Provider/Style/URI)).
>
>Документация Django рекомендует кодировать информацию в теле URL-адреса, на практике это приводит к лучшей структуре сайта.

Как было отмечено ранее, оставшаяся часть данной статьи описывает как сделать главную страницу сайта.

[Назад к Django](#django)

### Создание главной страницы сайта

Первой страницей, которую мы создадим, будет главная страница сайта (`catalog/`). Она будет небольшой статической HTML-страницей, которая будет показывать вычисленные "количества" различных записей из базы данных. Для того, чтобы проделать данную работу мы вначале создадим URL-преобразование, затем отображение и шаблон.

> **Примечание:** Лучше уделить больше внимания на данный раздел, поскольку информация, представленная здесь, применяется для создания всех страниц сайта.

### URL-преобразование

Когда мы создавали [скелет сайта](#django-2-создание-скелета) мы обновили **locallibrary/urls.py** так что всякий раз, когда начинается URL-адрес наш `catalog/` получен и `URLConf` `catalog.urls` подключён для обработки оставшейся части строки.
```py
urlpatterns += [
    path('catalog/', include('catalog.urls')),
]
```

> **Примечание:** всякий раз, когда Django сталкивается c [django.urls.include()](https://docs.djangoproject.com/en/2.0/ref/urls/#django.urls.include) он отбрасывает часть совпавшего URL , и отправляет оставшуюся строку в включённый URLconf для дальнейшей обработки.

Внутри нашего каталога приложения откройте **urls.py** и поместите в него текст, отмеченный жирным, ниже.
```py
urlpatterns = [
    path('', views.index, name='index'),
]
```

Эта функция `path()` определяет URL-паттерн (в данном случае это пустая строка: '` `' - мы поговорим чуть более подробно о них далее в данном руководстве) и функцию отображения, которая будет вызвана, если введённый адрес будет соответствует данному паттерну (`views.index` — это функция с именем `index()` в **views.py**).

Данная функция `path()`, кроме того, определяет параметр `name`, который уникально определяет это частное URL-преобразование. Вы можете использовать данное имя для "обратного" ("reverse") преобразования — то есть, для динамического создания URL-адреса, указывающего на ресурс, на которое указывает данное преобразование. Например, теперь, когда у нас имеется данное символическое имя, мы можем ссылаться на нашу домашнюю страницу при помощи создания следующей ссылки внутри какого-либо шаблона:
```html
<a href="{% url 'index' %}">Home</a>.
```

> **Примечание:** Мы могли бы, конечно, жёстко указать прямую ссылку (то есть, `<a href="/catalog/">Home</a>`), но тогда, если мы изменим адрес нашей домашней страницы (например на `/catalog/index`), то данные ссылки перестанут корректно работать. Применение "обратного" url-преобразования более гибкий и эффективный подход!

[Назад к Django](#django)

### Отображения (на основе функций)

Отображение является функцией, которая обрабатывает HTTP-запрос, получает данные из базы данных (при необходимости), которые применяются для генерации страницы HTML. Затем функция отображения возвращает сгенерированную страницу пользователю в виде HTTP-ответа. В нашем случае, индексная функция демонстрирует этот процесс — она получает информацию о количестве записей `Book`, `BookInstance`, доступности `BookInstance`, а также записи `Author` из базы данных, затем передаёт эти записи в шаблон страницы, генерирует страницу и передаёт её пользователю (клиенту пользователя, например браузеру).

Откройте **catalog/views.py** и отметьте для себя, что данный файл уже импортирует функцию [render()](https://docs.djangoproject.com/en/1.10/topics/http/shortcuts/#django.shortcuts.render) - функцию, которая генерирует HTML-файлы при помощи шаблонов страниц и соответствующих данных.
```py
from django.shortcuts import render

# Создайте ваше отображение здесь
```

Скопируйте следующий код в нижнюю часть файла. Первая строка импортирует классы модели, которые мы будем использовать для доступа к данным во всех наших функциях (позже и классах) отображения.
```py
from .models import Book, Author, BookInstance, Genre

def index(request):
    """
    Функция отображения для домашней страницы сайта.
    """
    # Генерация "количеств" некоторых главных объектов
    num_books=Book.objects.all().count()
    num_instances=BookInstance.objects.all().count()
    # Доступные книги (статус = 'a')
    num_instances_available=BookInstance.objects.filter(status__exact='a').count()
    num_authors=Author.objects.count()  # Метод 'all()' применён по умолчанию.

    # Отрисовка HTML-шаблона index.html с данными внутри
    # переменной контекста context
    return render(
        request,
        'index.html',
        context={'num_books':num_books,'num_instances':num_instances,'num_instances_available':num_instances_available,'num_authors':num_authors},
    )
```

Первая часть функции отображения получает количество записей при помощи вызова функции `objects.all()` у атрибута `objects`, доступного для всех классов моделей. Похожим образом мы получаем список объектов `BookInstance`, которые имеют статус 'a' (Доступно). Вы можете найти дополнительную информацию о работе с моделями в предыдущей части руководства ([Руководство часть 3: Применение моделей > Поиск записей](#django-3-использование-моделей)).

В конце функции `index` вызывается функция `render()`, которая, в качестве ответа, создаёт и возвращает страницу HTML (эта функция "оборачивает" вызовы нескольких функций, тем самым существенно упрощая процесс разработки). В качестве параметров ей передаются объект `request` (типа `HttpRequest`), шаблон HTML-страницы с метками (`placeholders`), которые будут замещены данными, а также переменной `context` (словарь Python, который содержит данные, которые и будут замещать метки в шаблоне).

В следующем разделе мы более подробно поговорим о шаблонах и переменной контекста. Давайте создадим наш шаблон, чтобы показать уже что-нибудь пользователю!

[Назад к Django](#django)

### Шаблон

Шаблон это текстовый файл, который определяет структуру и расположение данных в файле, кроме того, в нем размещают специальные метки (placeholders), которые используются для показа реального содержимого, то есть данных. По умолчанию Django ищет файлы шаблонов в директории с именем **'templates'** внутри вашего приложения. Например, внутри индексной функции отображения, которую мы только что создали, вызов `render()` будет пытаться найти файл **/locallibrary/catalog/templates/*index.html*** и в случае неудачи сгенерирует ошибку о том, что файл не найден. Вы можете увидеть данную ошибку, если вы сохраните предыдущие изменения, затем перейдёте в браузер и наберёте в адресной строке `127.0.0.1:8000`. В результате, в окно браузера будет выведено сообщение об ошибке "TemplateDoesNotExist at /catalog/" и некоторая другая информация.

> **Примечание:** На самом деле, в зависимости от настроек проекта, Django просматривает несколько мест в поисках шаблона (поиск в директории приложения осуществляется по умолчанию!). Вы можете найти больше информации о шаблонах и форматах, которые они поддерживают, перейдя по ссылке [Шаблоны](https://docs.djangoproject.com/en/1.10/topics/templates/) (Django docs).

### Расширение шаблонов

Шаблон главной страницы нашего сайта должен соответствовать стандарту разметки HTML для разделов `head` и `body`, кроме того иметь разделы для навигации (на другие страницы, которые мы создадим позже) и показа некоторого вводного текста. Большая часть данной структуры будет одинаковой для всех страниц нашего сайта. Таким образом, чтобы избежать копирования одной и той же информации, язык создания шаблонов Django позволяет вам объявить базовый шаблон, а затем расширить его, замещая только те части, которые являются специфическими для каждой страницы.

Например, базовый шаблон **base_generic.html** может выглядеть как показано ниже. Как вы видите, этот файл содержит некоторую "общую" структуру HTML, разделы для заголовка, панель навигации и содержимое, отмеченное тэгами шаблона `block` и `endblock` (показано жирным). Данные блоки могут быть пустыми, или иметь содержимое, которое будет использоваться "по умолчанию" всеми страницами-наследниками.

> **Примечание:** *Тэги* шаблона подобны функциям, которые могут применяться для создания циклов по спискам, выполнять условные операции и так далее. Кроме тэгов, язык шаблона позволяет использовать переменные (которые передаются в шаблон из отображения), а также *шаблонные фильтры*, которые переформатируют переменные (например, переводят строку в нижний регистр).
```django
<!doctype html>
<html lang="en">
<head>
  {% block title %}<title>Local Library</title>{% endblock %}
</head>

<body>
  {% block sidebar %}<!-- insert default navigation text for every page -->{% endblock %}
  {% block content %}<!-- default content text (typically empty) -->{% endblock %}
</body>
</html>
```

Когда мы определяем шаблон для конкретного отображения, то в первую очередь мы объявляем базовый шаблон (при помощи тэга `extends` — смотрите код в следующем фрагменте). Если имеются блоки в базовом шаблоне, которые мы хотим заместить, тогда в нашем текущем шаблоне мы объявляем `block`/`endblock` и указываем соответствующее имя блока.

Например фрагмент кода, показанный ниже, демонстрирует применение тэга `extends` и переопределяет блок с именем `content`. Окончательный код HTML будет содержать все структуры базового файла шаблона (включая содержимое по умолчанию, которое мы указали в блоке `title`) и код блока `content`, который мы разместили в текущем файле шаблона.
```django
{% extends "base_generic.html" %}

{% block content %}
  <h1>Local Library Home</h1>
  <p>
    Welcome to <em>LocalLibrary</em>, a very basic Django website developed as a
    tutorial example on the Mozilla Developer Network.
  </p>
{% endblock %}
```

[Назад к Django](#django)

### Базовый шаблон сайта LocalLibrary

Базовый шаблон, который мы планируем использовать для сайта *LocalLibrary*, представлен ниже. Как вы видите, данный фрагмент содержит HTML код и объявляет следующие блоки `title`, `sidebar` и `content`. Мы добавили заголовок по умолчанию (который, возможно, мы захотим изменить), а также боковую панель навигации, содержащей ссылки на списки всех книг и авторов (панель навигации, мы, вероятно, не будем менять/замещать, но, тем не менее, добавив этот блок, мы оставим для себя такую возможность).

> **Примечание:** Во фрагменте мы используем два дополнительных шаблонных тега: `url` и `load static`. Они будут описаны в следующих разделах.

Создайте новый файл — **/locallibrary/catalog/templates/base_generic.html** — и добавьте в него следующее содержимое:
```django
<!doctype html>
<html lang="en">
  <head>
    {% block title %}<title>Local Library</title>{% endblock %}
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

    <!-- Добавление дополнительного статического CSS файла -->
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/styles.css' %}" />
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <div class="col-sm-2">
          {% block sidebar %}
            <ul class="sidebar-nav">
              <li><a href="{% url 'index' %}">Home</a></li>
              <li><a href="">All books</a></li>
              <li><a href="">All authors</a></li>
            </ul>
          {% endblock %}
        </div>
        <div class="col-sm-10 ">{% block content %}{% endblock %}</div>
      </div>
    </div>
  </body>
</html>
```

Шаблон использует (и включает в себя) JavaScript и CSS от [Bootstrap](http://getbootstrap.com/) для лучшего размещения элементов и формирования внешнего вида HTML страницы. Применение Bootstrap, или любого другого фреймворка для клиентской части сайта, является довольно продуктивным способом повышения привлекательности страницы, в том числе, это учитывает возможность запроса и показа сайта с устройств, с различными разрешениями экрана, а кроме того, это позволяет нам повысить уровень взаимодействия с пользователем — мы направим большую часть своих усилий на серверную часть нашего сайта!

Базовый шаблон ссылается на локальный файл css (**styles.css**), который предоставляет дополнительные стили. Создайте **/locallibrary/catalog/static/css/styles.css** и добавьте в него следующее содержимое:
```css
.sidebar-nav {
  margin-top: 20px;
  padding: 0;
  list-style: none;
}
```

[Назад к Django](#django)

### Индексный шаблон (шаблон главной страницы сайта)

Создайте файл HTML **/locallibrary/catalog/templates/index.html** и скопируйте в него код, указанный ниже. Как вы наверное заметили, в первой строке мы расширяем наш базовый шаблон, а затем замещаем содержимое блока `content`, базового шаблона, новым содержимым текущего шаблона.
```django
{% extends "base_generic.html" %}

{% block content %}
<h1>Local Library Home</h1>

  <p>Welcome to <em>LocalLibrary</em>, a very basic Django website developed as a tutorial example on the Mozilla Developer Network.</p>

<h2>Dynamic content</h2>

  <p>The library has the following record counts:</p>
  <ul>
    <li><strong>Books:</strong> {{ num_books }}</li>
    <li><strong>Copies:</strong> {{ num_instances }}</li>
    <li><strong>Copies available:</strong> {{ num_instances_available }}</li>
    <li><strong>Authors:</strong> {{ num_authors }}</li>
  </ul>

{% endblock %}
```

В данном фрагменте, в разделе *Динамическое содержимое*, мы объявили метки (*шаблонные переменные*) для информации, которую мы получаем из соответствующего отображения. Данные переменные объявляются при помощи "двойных фигурных скобок" (в предыдущем фрагменте выделено жирным).

> **Примечание:** Переменные шаблона заключаются в двойные фигурные скобки (`{{ num_books }}`) , а тэги шаблона (функции шаблона), помещаются в одинарные фигурные скобки со знаками процента (`{% extends "base_generic.html" %}`).

Важно отметить, что данные переменные имеют имена, соответствующие именам передаваемых ключей из словаря переменной `context`, которая, в свою очередь, передаётся из отображения, во время вызова функции `render()` (смотри ниже). При отрисовке шаблона, вместо этих ключей будут подставлены, соответствующие им, значения.
```py
return render(
    request,
    'index.html',
     context={'num_books':num_books,'num_instances':num_instances,'num_instances_available':num_instances_available,'num_authors':num_authors},
)
```

[Назад к Django](#django)

### Ссылка на статические файлы их шаблонов

Любой ваш проект с большой вероятностью будет использовать статические ресурсы, включая JavaScript, CSS и изображения. В связи с тем, что расположение этих файлов может быть неизвестно (или может измениться), Django позволяет вам в шаблоне указать относительное расположение данных файлов при помощи глобального значения `STATIC_URL` (по умолчанию, значение параметра `STATIC_URL` установлено в '`/static/`', но вы можете выбрать любое другое значение, указав, например, сетевой ресурс, или что-то ещё).

Внутри шаблона вы вызываете функцию (тэг) `load`, которая загружает статическую библиотеку "static" (как показано ниже). После того как статическая библиотека загружена, вы можете использовать тэг шаблона `static`, который указывает относительный путь URL к интересующему вас файлу.
```django
<!-- Добавляем дополнительный статический CSS-файл -->
{% load static %}
<link rel="stylesheet" href="{% static 'css/styles.css' %}" />
```

Тем же способом вы можете загрузить нужное изображение. Например:
```django
{% load static %}
<img
  src="{% static 'catalog/images/local_library_model_uml.png' %}"
  alt="My image"
  style="width:555px;height:540px;" />
```

> **Примечание:** Фрагменты выше указывают пути расположения файлов, но Django не использует их по умолчанию. В процессе разработки сервер использует значения, указанные в глобальном файле URL-преобразований (**/locallibrary/locallibrary/urls.py**), который мы создали в части [создание скелета сайта](#django-2-создание-скелета). В дальнейшем, в продакшене, вам нужно будет уточнить параметры расположения статических файлов. Мы вернёмся к этому позже.

Для получения более подробной информации о работе со статическими файлами обратитесь к документации по ссылке [Управление статическими файлами](https://docs.djangoproject.com/en/1.10/howto/static-files/) (Django docs).

### Построение URL-адресов

Базовый шаблон, указанный выше, вводит тэг `url`.
```py
<li><a href="{% url 'index' %}">Home</a></li>
```

Данный тэг с именем `url()`, ищет в файле **urls.py** связанное значение переменной, указанной в качестве её параметра `'index'`, а затем возвращает URL, который вы можете использовать для ссылки на соответствующие ресурсы.

### Как теперь все это выглядит?

На данный момент мы должны были сделать всё что необходимо, для того, чтобы показать главную страницу нашего сайта. Запустите сервер (`python3 manage.py runserver`) и введите в ваш браузер адрес `http://127.0.0.1:8000/`. Если все настроено как надо, то ваш сайт должен выглядеть как показано на следующей картинке.

![catalog](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Home_page/index_page_ok.png)

> **Примечание:** На данном этапе вы не сможете воспользоваться ссылками на страницы **All books** и **All authors**, потому что url-адреса, отображения и шаблоны для данных страниц не созданы (мы просто объявили метки для соответствующих ссылок в базовом шаблоне `base_generic.html`).

[Назад к Django](#django)

### Проверьте себя

А теперь парочка заданий, чтобы проверить, насколько вы усвоили работу с запросами к моделям базы данных, взаимодействия с отображениями и шаблонами.

1. В главном файле шаблона (**base_generic.html**) есть блок `title`. Переопределите этот блок в индексном шаблоне (**index.html**) и задайте новый заголовок для этой страницы.
2. Модифицируйте функцию отображения таким образом, чтобы получать из базы данных количество жанров и количество книг, которые содержат в своих заголовках какое-либо слово (без учёта регистра), а затем передайте эти значения в шаблон.

### Итог

Мы создали домашнюю страницу для нашего сайта — HTML страница, которая показывает количество некоторых записей из базы данных и содержит ссылки на другие "все-ещё-будут-созданы" страницы. Кроме того, мы изучили большое количество базовой информации об url-преобразованиях, отображениях, запросах к базе данных, используя наши модели, передачу информации из отображений в шаблоны, кроме того, создание и расширение шаблонов.

В следующей части, при помощи наших новых знаний, мы создадим ещё четыре страницы.

- **Смотрите также:**
- [Написание вашего первого приложения Django, часть 3: Отображения и Шаблоны](https://docs.djangoproject.com/en/1.10/intro/tutorial03/) (Django docs)
- [URL-диспетчер](https://docs.djangoproject.com/en/1.10/topics/http/urls/) (Django docs)
- [Функции отображения](https://docs.djangoproject.com/en/1.10/topics/http/views/) (DJango docs)
- [Шаблоны](https://docs.djangoproject.com/en/1.10/topics/templates/) (Django docs)
- [Управление статическими файлами](https://docs.djangoproject.com/en/1.10/howto/static-files/) (Django docs)
- [Удобные (встроенные) функции Django](https://docs.djangoproject.com/en/1.10/topics/http/shortcuts/#django.shortcuts.render) (Django docs)

[Назад к Django](#django)

## Django 6: отображение списков и детальной информации

Данная часть расширяет наш сайт [LocalLibrary](#django-сайт-местной-библиотеки), добавляя в него списки и страницы, путём предоставления подробной информации о книгах и авторах. В текущей части мы подробно изучим обобщённые базовые классы отображения и покажем как они могут существенно сократить количество кода, который вы должны были бы написать в обычной ситуации. Кроме того, мы более подробно рассмотрим управление и настройки URL-адресов, показывая как выполнить простое сопоставление какой-либо строки паттерну регулярного выражения.

|Требования: |Завершить все предыдущие части руководства, включая [Руководство Django Часть 5: Создание домашней страницы](#django-5-cоздание-домашней-страницы).
|----|---
|Цель: |Понимать где и как применять обобщённые базовые классы отображения, и как применять паттерны URL-адресов для передачи информации в отображения.

### Обзор

В данном руководстве мы завершим первую версию сайта [LocalLibrary](#django-сайт-местной-библиотеки), с помощью добавления страницы перечисления и подробной информации о книгах и авторах (или, если быть более точными, мы покажем как вам реализовать соответствующие страницы для книг, а для авторов вы сможете сделать их самостоятельно!)

Данный процесс похож на создание главной страницы сайта, который мы показывали в предыдущей части руководства. Нам все также надо создать URL-преобразования, отображения и шаблоны страниц. Основным отличием будет то, что для страниц подробной информации перед нами встанет дополнительная задача получения информации из паттерна URL-адреса и передачи её отображению. Для этих страниц мы собираемся продемонстрировать совершенно другой тип отображения, основанный на применении обобщённых классов отображения списка и детальной информации о записи. Это может существенно сократить количество кода, необходимого для отображения и сделает его (код) более простым для написания и поддержки.

Завершающая часть данного руководства будет посвящена демонстрации постраничного показа ваших данных (pagination) при применении обобщённого класса отображения списка.

### Страница со списком книг

Страница со списком книг показывает все книги в наличии и будет доступна по адресу: `catalog/books/`. Эта страница для каждой записи выводит заголовок и автора, при этом каждый заголовок является гиперссылкой на соответствующую страницу подробной информации о книге. Данная страница будет иметь ту же структуру и навигацию как и все остальные страницы сайта, таким образом мы сможем расширить базовый шаблон сайта (**base_generic.html**), который мы создали в предыдущей части руководства.

### Преобразования URL-адресов

Откройте файл **/catalog/urls.py** и скопируйте в него путь до `'books/'`, как в примере ниже. Практически так же, как и для главной страницы сайта, функция `path()` определяет регулярное выражение, по которому проверяется адрес (**'books/'**), функцию отображения, которая вызовется при совпадении адресов (`views.BookListView.as_view()`), и название для этого конкретного преобразования.
```py
urlpatterns = [
    path('', views.index, name='index'),
    path('books/', views.BookListView.as_view(), name='books'),
]
```

Как было отмечено в предыдущей части руководства, URL-адрес уже должен содержать `/catalog`, и таким образом полный адрес, на самом деле, имеет вид `/catalog/books/`.

Функция отображения имеет другой формат, чем прежде — это связано с тем, что данное отображение реализуется через класс. Мы будем наследоваться от существующей общей функции из **view**, которая уже делает большую часть того, что мы хотим, вместо того, чтобы писать свою собственную функцию во **view** с нуля.

При использовании обобщённых классов отображения в Django мы получаем доступ к соответствующей функции отображения при помощи вызова метода `as_view()`. Таким образом выполняется вся работа по созданию экземпляра класса и гарантируется вызов правильных методов для входящих HTTP-запросов.

[Назад к Django](#django)

### Отображение (на основе базового класса)

Мы могли бы достаточно просто реализовать отображение списка книг при помощи обычной функции (также, как мы сделали это для главной страницы сайта), которая должны была бы выполнить запрос получения всех книг из базы данных, затем вызвать функцию `render()`, в которую передать данный список, в соответствующий шаблон страницы. Тем не менее, вместо это мы будем использовать обобщённый класс отображения списка — класс, который наследуется от существующего отображения (ListView). Поскольку обобщённый класс уже реализует большую часть того, что нам нужно, и следуя лучшим практикам Django, мы сможем создать более эффективный список при помощи меньшего количества кода, меньшего количества повторений и гораздо лучшей поддержкой.

Откройте **catalog/views.py** и скопируйте следующий код, в нижнюю часть данного файла:
```py
from django.views import generic

class BookListView(generic.ListView):
    model = Book
```

Это всё! Обобщённое отображение выполнит запрос к базе данных, получит все записи заданной модели (`Book`), затем отрендерит (отрисует) соответствующий шаблон, расположенный в **/locallibrary/catalog/templates/catalog/book_list.html** (который мы создадим позже). Внутри данного шаблона вы можете получить доступ к списку книг при помощи переменной шаблона `object_list` ИЛИ `book_list` (если обобщить, то "`the_model_name_list`").

> **Примечание:** Этот, выглядящий странно, путь к файлу шаблона не является опечаткой — обобщённое отображение ищет файл шаблона `/application_name/the_model_name_list.html` (`catalog/book_list.html`, в данном случае) внутри директории приложения `/application_name/templates/` (у нас - `/catalog/templates/`).

Вы можете использовать атрибуты для того, чтобы изменить поведение по умолчанию. Например, вы могли бы указать другой файл шаблона, например, если в вашем распоряжении имеется несколько отображений, которые используют одну и ту же модель, или вам позарез захотелось бы использовать другое имя переменной шаблона, если `book_list` не является интуитивно понятным. Возможно, наиболее полезным вариантом является изменение/отфильтрованные результата запроса к базе данных — таким образом, вместо перечисления всех книг вы могли бы показывать 5 наиболее популярных.
```py
class BookListView(generic.ListView):
    model = Book
    context_object_name = 'my_book_list'   # ваше собственное имя переменной контекста в шаблоне
    queryset = Book.objects.filter(title__icontains='war')[:5] # Получение 5 книг, содержащих слово 'war' в заголовке
    template_name = 'books/my_arbitrary_template_name_list.html'  # Определение имени вашего шаблона и его расположения
```

### Переопределение методов в классах отображения

Пока что вам не приходилось этого делать, но у вас имеется возможность переопределять некоторые методы класса отображения.

Например, мы можем переопределить метод получения списка всех записей `get_queryset()`. Данный подход является более гибким, чем использование атрибута `queryset`, как мы сделали в предыдущем фрагменте кода (хотя, в данном случае и нет никакой разницы):
```py
class BookListView(generic.ListView):
    model = Book

    def get_queryset(self):
        return Book.objects.filter(title__icontains='war')[:5] # Получить 5 книг, содержащих 'war' в заголовке
```

Мы также могли бы переопределить метод `get_context_data()` для того, чтобы в контексте (в переменной контекста) передавать шаблону дополнительные переменные (например, список книг передаётся по умолчанию). Фрагмент, представленный ниже, показывает как добавить переменную с именем "some_data" в контекст (затем она будет доступна как переменная шаблона).
```py
class BookListView(generic.ListView):
    model = Book

    def get_context_data(self, **kwargs):
        # В первую очередь получаем базовую реализацию контекста
        context = super(BookListView, self).get_context_data(**kwargs)
        # Добавляем новую переменную к контексту и инициализируем её некоторым значением
        context['some_data'] = 'This is just some data'
        return context
```

В процессе выполнения всего этого важно придерживаться определённой последовательности действий:

- В первую очередь - получить существующий контекст из нашего суперкласса.
- Затем добавить в контекст новую информацию.
- Затем вернуть новый (обновлённый) контекст.

> **Примечание:** Посмотрите [Встроенные обобщённые классы отображения](https://docs.djangoproject.com/en/1.10/topics/class-based-views/generic-display/) (Django docs) для ознакомления с большим количеством примеров того, что вы могли бы сделать.

[Назад к Django](#django)

### Создание шаблона Отображения Списка

Создайте HTML-файл **/locallibrary/catalog/templates/catalog/book_list.html** и скопируйте в него текст, указанный ниже. Как было отмечено ранее, это файл шаблона по умолчанию, который будет "искать" обобщённый класс отображения списка (для модели с именем `Book` в приложении с именем `catalog`).

Шаблоны для обобщённых отображений такие же как все остальные шаблоны (хотя, естественно, передаваемые в них контекст, или информация могут отличаться). Так же как и с нашим шаблоном для главной страницы, в первой строке мы расширяем наш базовый шаблон, а затем определяем и замещаем блок с именем `content`.
```django
{% extends "base_generic.html" %}

{% block content %}
    <h1>Book List</h1>

    {% if book_list %}
    <ul>

      {% for book in book_list %}
      <li>
        <a href="{{ book.get_absolute_url }}">{{ book.title }}</a> ({{book.author}})
      </li>
      {% endfor %}

    </ul>
    {% else %}
      <p>There are no books in the library.</p>
    {% endif %}
{% endblock %}
```

По умолчанию отображение передаёт контекст (список книг) как `object_list` и `book_list` (синонимы; оба варианта будут работать).

### Условные ветвления

Мы применяем теги шаблона [`if`](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#if), `else` и `endif` для того, чтобы проверить определена ли переменная book_list и содержит ли она данные. Если список НЕ пуст, тогда мы выполняем итерации по списку книг. Если список пуст (`else`-случай) тогда мы показываем текст, поясняющий, что в наличии нет книг.
```dj
{% if book_list %}
  <!-- здесь наш код "бежит" по списку книг -->
{% else %}
  <p>В библиотеке книг нет.</p>
{% endif %}
```

В данном фрагменте проверяется только одно условие, но вы можете протестировать другие варианты при помощи тэга шаблона `elif` (например, `{% elif var2 %}` ). Для дополнительной информации по данной теме смотрите: [if](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#if), ifequal/[ifnotequal](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#ifequal-and-ifnotequal) и [ifchanged](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#ifchanged) в главе [Встроенные тэги и фильтры шаблона](https://docs.djangoproject.com/en/1.10/ref/templates/builtins) (Django Docs).

[Назад к Django](#django)

### Цикл For

Шаблон использует тэги [for](https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#for) и `endfor` для того, чтобы "пробежаться" по списку книг, как показано ниже. На каждой итерации (каждом цикле) в переменную шаблона `book` передаётся информация текущего элемента списка.
```django
{% for book in book_list %}
  <li><!-- здесь код, который использует информацию из каждого элемента book списка--></li>
{% endfor %}
```

Мы не применяем здесь, но внутри каждого цикла Django создаёт переменные, которые вы можете использовать при итерации. Например, вы можете проверять переменную `forloop.last` (указывает на последнюю итерацию в цикле) для выполнения каких-либо завершающих действий для данного цикла.

### Доступ к переменным

Код внутри цикла создаёт экземпляр для каждой книги из списка, при помощи которой показывается заголовок (как ссылка на "скоро-будет-сделано" подробное отображение) и автора книги.
```html
<a href="{{ book.get_absolute_url }}">{{ book.title }}</a> ({{book.author}})
```

Мы получаем доступ к полям соответствующей записи о книге при помощи "дот-нотации", то есть через точку (например, `book.title` и `book.author`), где текст, который идёт после `book`, является именем поля (так, как определено в модели).

Кроме того, внутри нашего шаблона, мы можем вызывать *функции* модели — в данном случае, мы вызываем `Book.get_absolute_url()` для получения URL-адреса, который мы используем для показа детальной информации о книге. Данный вызов работает только для функции у которой нет аргументов (в шаблоне не существует возможности передать аргументы в функцию!)

> **Примечание:** Мы должны быть достаточно осмотрительными для того, чтобы избегать "сторонних эффектов" когда мы вызываем функции из шаблона. В данном случае мы просто получаем URL-адрес, но функции могут делать всё что угодно — мы не хотели бы "убить" наша базу данных (например) просто отрендеривая наш шаблон!

### Обновление базового шаблона

Откройте файл базового шаблона (`/locallibrary/catalog/templates/base_generic.html`) и вставьте `{% url 'books' %}` в URL-ссылку для пункта **All books**, как показано ниже. Тем самым, мы создали "переход" на страницу с книгами (теперь мы можем смело это сделать, поскольку у нас имеется соответствующее "книжное" url-преобразование).
```py
<li><a href="{% url 'index' %}">Home</a></li>
<li><a href="{% url 'books' %}">All books</a></li>
<li><a href="">All authors</a></li>
```

- Как же теперь все это выглядит?

Пока что у вас нет возможности создать список книг, потому что мы не учли ещё необходимые зависимости — преобразование URL-адреса для страниц с подробной информации о книге, которое необходимо для ссылок на отдельные книги. Мы покажем страницы со списком и подробной информацией о книге после следующего раздела.

[Назад к Django](#django)

### Страница с подробной информацией о книге

Доступ к странице с подробной информацией о книге осуществляется при помощи URL-адреса `catalog/book/<id>` (где `<id>` является первичным ключом для данной книги). В дополнение к полям модели `Book` (автор, краткое содержание, ISBN, язык и жанр), также мы перечислим детали доступных экземпляров книги (`BookInstances`) включая их статус, ожидаемую дату возврата, штамп (imprint) и id. Это должно позволить нашим читателям не просто узнать о книге, но также убедиться, имеется ли она в наличии и/или когда будет доступна.

### URL-преобразования

Откройте **/catalog/urls.py** и добавьте '**book-detail**' URL-преобразование, отмеченное жирным в следующем фрагменте. Эта функция `url()` определяет паттерн, связанный с обобщённым классом отображения детальной информации, а также имя для данной связи.
```py
from django.urls import path
from . import views
from django.conf.urls import url

urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^books/$', views.BookListView.as_view(), name='books'),
    url(r'^book/(?P<pk>\d+)$', views.BookDetailView.as_view(), name='book-detail'),
]
```

В отличие от предыдущих преобразований, в данном случае мы применяем наше регулярное выражение (РВ) для сопоставления "настоящего паттерна", а не просто строки. Данное РВ сопоставляет любой URL-адрес, который начинается с `book/`, за которым до конца строки (до маркера конца строки - $) следуют одна, или более *цифр*. В процессе выполнения данного преобразования, оно "захватывает" цифры и передаёт их в функцию отображения как параметр с именем `pk`.

> **Примечание:** Как было отмечено ранее, наш преобразуемый URL-адрес в реальности выглядит вот так `catalog/book/<digits>` (потому что мы находимся в приложении **catalog**, то подразумевается каталог `/catalog/`).

> **Предупреждение: Важно:** Обобщённый класс отображения подробной информации ожидает получить параметр с именем `pk`. Если вы пишете свою собственную функцию отображения, то тогда вы можете использовать параметр с любым именем, который пожелаете, или вообще передавать информацию в безымянном аргументе.

[Назад к Django](#django)

### Отдельный пример с регулярными выражениями

Паттерны [регулярного выражения](https://docs.python.org/3/library/re.html) является невероятно мощным инструментом преобразования. Пока что, мы не очень много говорили о них, поскольку мы сопоставляли URL-адреса с простыми строками (а не паттернами), и потому что они не интуитивны и пугающий для начинающих.

> **Примечание:** Без паники! Мы будем рассматривать и использовать достаточно простые паттерны и при этом хорошо задокументированные!

В первую очередь вы должны знать что обычно регулярные выражения объявляются при помощи строкового литерала (то есть, они заключены в кавычки: **r'<ваше регулярное выражение>'**).

Главными элементами синтаксиса объявления паттерна, который вы должны знать, являются:

| Символ | Значение
|---|--
| ^ | Соответствует началу строки
| $ | Соответствует концу строки
| \d | Соответствует цифре (0, 1, 2, ... 9)
| \w | Соответствует любому символу из алфавита в верхнем- или нижнем- регистре, цифре, или символу подчёркивания (`_`)
| + | Соответствует **одному, или более** предыдущему символу. Например, для соответствия **одной, или более** цифре вы должны использовать `\d+`. Для **одного и более** символа "a", вы можете использовать `a+`
| * | Соответствует отсутствию вообще, или присутствию **одного, или более** предыдущему символу. Например, для соответствия "ничему", или слову (то есть, любому символу) вы можете использовать `\w*`
| () | Захват части паттерна внутри скобок. Любое захваченное значение будет передано отображению как безымянный параметр (если захватывается множество паттернов, то соответствующие параметры будут поставляться в порядке их объявления).
| (? P\<name>) | Захват части паттерна (обозначенного через ...) как именованной переменной (в данном случае \<name>). Захваченные значения передаются в отображение с определённым именем. Таким образом, ваше отображение должно объявить аргумент с тем же самым именем!
| [] | Соответствует одному символу из множества. Например, `[abc]` будет соответствовать либо `'a'`, или `'b'`, или `'c'`. `[-\w]` будет соответствовать либо символу `'-'` , или любому другому словарному символу.

Большинство других символов могут быть заданы буквально!

Давайте рассмотрим несколько реальных примеров паттернов:

| Паттерн | Описание
|-----|---
| **r'^book/(?P<pk>\d+)$'** | Это РВ применяется в нашем url-преобразовании. Оно соответствует строке, которая начинается с `book/` (**^book/**), затем имеет одну, или более цифр (`\d+`), а затем завершается (цифрой и только цифрой).Оно также захватывает все цифры **(?P<pk>\d+)** и передаёт их в отображение, в параметре с именем `'pk'`. **Захваченные значения всегда передаются как строка!** Например, данному паттерну должна соответствовать следующая строка `book/1234` , которая отправляет переменную `pk='1234'` в отображение.
| **r'^book/(\d+)$'** | Этот паттерн соответствует тем же самым URL-адресам как и в предыдущем случае. Захваченная информация будет отправлена в отображение как безымянный параметр.
| **r'^book/(?P<stub>[-\w]+)$'** | Данный паттерн соответствует строке, которая начинается с `book/` (**^book/**), затем идут один, или более символов либо `'-'`, или словарные символы (**[-\w]+**), а затем завершается. Он также захватывает данное множество символов и передаёт их в отображение в параметре с именем `'stub'`. Это довольно типичный паттерн для **"стаба"**. Стабы являются дружественными URL-адресами - первичными ключами для данных. Вы могли бы применить стаб, если вы захотели бы, чтобы URL-адрес вашей книги был более информативным. Например, `/catalog/book/the-secret-garden`, выглядит немного лучше чем `/catalog/book/33`.

Вы можете захватить (указать) несколько паттернов в одном преобразовании и, тем самым, закодировать много различной информации в URL-адресе.

> **Примечание:** В качестве дополнительного задания, рассмотрите возможность того, как вы могли бы закодировать url на список всех книг, вышедших в определённый год, месяц, день и какое РВ (паттерн) должно соответствовать этому.

### Передача дополнительных настроек в ваши преобразования URL-адресов

Одной возможностью, которую мы не применяли здесь, но которая могла бы быть вам полезной, является то, что вы можете объявлять и передавать [дополнительные настройки](https://docs.djangoproject.com/en/1.10/topics/http/urls/#views-extra-options) в отображения. Данные настройки объявляются как словарь, который вы передаёте как третий безымянный аргумент функции `url()`. Этот способ может быть полезен, если вы хотите воспользоваться тем же самым отображением для нескольких ресурсов и передавать данные для изменения его поведения в каждом отдельном случае (ниже, мы передаём разные имена шаблонов).
```py
url(r'^/url/$', views.my_reused_view, {'my_template_name': 'some_path'}, name='aurl'),
url(r'^/anotherurl/$', views.my_reused_view, {'my_template_name': 'another_path'}, name='anotherurl'),
```

> **Примечание:** И дополнительные настройки, и именованные захваченные паттерны передаются в отображение как именованные параметры. Если вы используете одинаковое имя и для захваченного паттерна и для дополнительной настройки, то последняя будет отброшена, а в отображение будет передано значение захваченного паттерна.

[Назад к Django](#django)

### Отображение (на основе класса)

Откройте **catalog/views.py**, и скопируйте следующий код в нижнюю часть файла:
```py
class BookDetailView(generic.DetailView):
    model = Book
```

Это всё! Все что вам надо теперь сделать это создать шаблон с именем /**locallibrary/catalog/templates/catalog/book_detail.html**, а отображение передаст ему информацию из базы данных для определённой записи `Book`, выделенной при помощи URL-преобразования. Внутри шаблона вы можете получить доступ к списку книг при помощи переменной с именем object или book (обобщённо "`the_model_name`").

Если у вас имеется необходимость, то вы можете изменить текущий шаблон и/или имя объекта контекста, используемого для ссылки на книгу в шаблоне. Кроме того, вы можете переопределить методы, например, для добавления дополнительной информации к контексту.

- **Что произойдёт, если записи не существует?**

Если запрашиваемой записи не существует, тогда обобщённый класс отображения подробной информации автоматически "выкинет" исключение `Http404` — в продакшене это приведёт к автоматическому отображению страницы с текстом "resource not found" ("ресурс не найден"), которую, конечно же, вы можете настроить по своему усмотрению.

Просто для иллюстрации идеи как это могло бы работать, мы приведём фрагмент кода, демонстрирующего возможную реализацию отображения в виде функции, если по каким-либо причинам вы не используете отображение на основе обобщённого класса.
```py
def book_detail_view(request,pk):
    try:
        book_id=Book.objects.get(pk=pk)
    except Book.DoesNotExist:
        raise Http404("Book does not exist")

    #book_id=get_object_or_404(Book, pk=pk)

    return render(
        request,
        'catalog/book_detail.html',
        context={'book':book_id,}
    )
```

В первую очередь отображение пытается получить определённую запись о книге из модели. Если ей это не удаётся, то "выбрасывается" исключение `Http404`, которое сигнализирует, что данная книга не найдена "not found". Последним шагом является, как обычно, вызов функции `render()` с именем соответствующего шаблона и данных о книге, передаваемых в параметре с именем context (в виде словаря).

> **Примечание:** Функция `get_object_or_404()` (показана закомментированной) является удобным "ярлыком" для генерации исключения `Http404` если запись не найдена.

[Назад к Django](#django)

### Создание шаблона детальной информации

Создайте HTML файл **/locallibrary/catalog/templates/catalog/book_detail.html** и скопируйте в него содержимое, представленное ниже. Как было указано ранее, это шаблон "по умолчанию" (имя шаблона), который "ожидается"обобщённым классом отображения детальной информации (для модели с именем `Book` в приложении с именем `catalog`).
```django
{% extends "base_generic.html" %}

{% block content %}
  <h1>Title: {{ book.title }}</h1>

  <p><strong>Author:</strong> <a href="">{{ book.author }}</a></p> <!-- author detail link not yet defined -->
  <p><strong>Summary:</strong> {{ book.summary }}</p>
  <p><strong>ISBN:</strong> {{ book.isbn }}</p>
  <p><strong>Language:</strong> {{ book.language }}</p>
  <p><strong>Genre:</strong> {% for genre in book.genre.all %} {{ genre }}{% if not forloop.last %}, {% endif %}{% endfor %}</p>

  <div style="margin-left:20px;margin-top:20px">
    <h4>Copies</h4>

    {% for copy in book.bookinstance_set.all %}
    <hr>
    <p class="{% if copy.status == 'a' %}text-success{% elif copy.status == 'd' %}text-danger{% else %}text-warning{% endif %}">{{ copy.get_status_display }}</p>
    {% if copy.status != 'a' %}<p><strong>Due to be returned:</strong> {{copy.due_back}}</p>{% endif %}
    <p><strong>Imprint:</strong> {{copy.imprint}}</p>
    <p class="text-muted"><strong>Id:</strong> {{copy.id}}</p>
    {% endfor %}
  </div>
{% endblock %}
```

> **Примечание:** Ссылка на автора в шаблоне содержит пустой URL-адрес, потому что мы ещё не создали страницу детальной информации об авторе. Когда это произойдёт, вы должны будете обновить данный URL-адрес как указано ниже:
> ```django
> <a href="{% url 'author-detail' book.author.pk %}">{{ book.author }}</a>
> ```

Хотя и несколько больше, но почти все в данном шаблоне нам уже встречалось ранее:

- Мы расширяем наш базовый шаблон и переопределяем блок `content`.
- Мы используем условие `if` для показа того, или иного содержимого.
- Мы используем циклы `for` того, чтобы пробежаться по элементам (объектам) в соответствующих списках.
- Мы получаем доступ к полям контекста при помощи "дот-нотации" (поскольку мы использовали обобщённый класс отображения детальной информации, то контекст имеет имя `book`; также можем использовать имя `object`)

Одной интересной вещью, которую мы не видели ранее, является функция `book.bookinstance_set.all()`. Данный метод является "автомагически"-сконструированным Django для того, чтобы вернуть множество записей `BookInstance`, связанных с данной книгой `Book`.
```django
{% for copy in book.bookinstance_set.all %}
<!-- итерации по каждой копии/экземпляру книги -->
{% endfor %}
```

Этот метод создан, потому что вы, на стороне "многим" данной связи, объявили поле `ForeignKey` (один-ко многим). Поскольку вы ничего не объявили на другой стороне ("один") данной модели (то есть, модель `Book` "ничего не знает" про модель `BookInstance`), то она не имеет никакой возможности (по умолчанию) для получения множества соответствующих записей. Для того, чтобы обойти эту проблему, Django конструирует соответствующую функцию "обратного просмотра" ("reverse lookup"), которой вы можете воспользоваться. Имя данной функции создаётся в нижнем регистре и состоит из имени модели, в которой был объявлен `ForeignKey` (то есть, `bookinstance`), за которым следует `_set` (то есть функция, созданная для `Book` будет иметь вид `bookinstance_set()`).

> **Примечание:** Здесь мы используем `all()` для получения всех записей (по умолчанию). Вы, наверное, могли бы использовать метод `filter()` для получения подмножества записей в коде, но, к сожалению, вы НЕ можете применить данный вызов в шаблоне, потому что вы не можете передать в нем (в шаблоне) аргументы в функцию.
>
> Обратите внимание, что если вы не определяете порядок выдачи данных (в вашем отображении, или в модели), то сервер разработки "выкинет" сообщения об ошибках, похожие на следующие:
>
> ```[29/May/2017 18:37:53] "GET /catalog/books/?page=1 HTTP/1.1" 200 1637
> /foo/local_library/venv/lib/python3.5/site-packages/django/views/generic/list.py:99: UnorderedObjectListWarning: Pagination may yield inconsistent results with an unordered object_list: <QuerySet [<Author: Ortiz, David>, <Author: H. McRaven, William>, <Author: Leigh, Melinda>]>
>   allow_empty_first_page=allow_empty_first_page, **kwargs)
> ```
> Это случилось потому что, [paginator object](https://docs.djangoproject.com/en/1.10/topics/pagination/#paginator-objects) (далее объект постраничного вывода) ожидает видеть некую упорядоченность ORDER BY при запросе к базе данных. Без этого, он не сможет гарантировать правильный вывод полученных данных!
>
> Данное руководство пока не дошло до описания **Pagination** (пока, но скоро будет), и поскольку вы не можете использовать функцию `sort_by()` и передавать параметр (по той же причине, что и `filter()`) вы должны выбрать один из трёх вариантов дальнейших действий:
>
> 1. Добавить атрибут `ordering` внутри `Meta-класса` объявленного в вашей модели.
> 2. Добавить атрибут `queryset` в вашей реализации класса отображения, определяющего `order_by()`.
> 3. Добавить метод `get_queryset` в вашу реализацию класса отображения и также определить метод `order_by()`.
>
> Если вы выбрали пункт номер один с Meta-классом для модели Author (вероятно, не такой гибкий как вариант с настройкой класса отображения, но тем не менее, достаточно простой), вы должны прийти к чему-то похожему на следующее:
>
> ```py
> class Author(models.Model):
>     first_name = models.CharField(max_length=100)
>     last_name = models.CharField(max_length=100)
>     date_of_birth = models.DateField(null=True, blank=True)
>     date_of_death = models.DateField('Died', null=True, blank=True)
> 
>     def get_absolute_url(self):
>         return reverse('author-detail', args=[str(self.id)])
> 
>     def __str__(self):
>         return '%s, %s' % (self.last_name, self.first_name)
> 
>     class Meta:
>         ordering = ['last_name']
> ```
>
> Конечно же, поле не обязательно должно иметь имя `last_name`: оно может быть любым.
>
> И последнее, но не окончательное, вы должны сортировать по атрибуту/колонке, которая была проиндексирована (уникально, или нет) в вашей базе данных для того, чтобы избежать проблем с быстродействием. Конечно, это не является необходимым в данном примере (и мы, вероятно, забегаем далеко вперёд), если у нас такое небольшое количество книг (и пользователей!), но это необходимо помнить для будущих проектов.

[Назад к Django](#django)

### Как это теперь выглядит?

На данный момент мы должны были создать все необходимое для показа страниц со списком книг и детальной информацией. Запустите сервер (`python3 manage.py runserver`) и откройте ваш браузер `http://127.0.0.1:8000/`.

> **Предупреждение:** Не кликайте на каком-либо авторе, - ссылки пока не заданы — это будет вашим дополнительным заданием!

Кликните ссылку **All books** для перехода на страницу со списком книг.

![Book list](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/book_list_page_no_pagination.png)

Затем кликните на ссылку одной из ваших книг. Если все настроено как надо, то вы должны увидеть то, что указано на картинке.

![about book](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/book_detail_page_no_pagination.png)

[Назад к Django](#django)

### Постраничный вывод (Pagination)

Если у вас всего лишь несколько записей в базе данных, то наша страница вывода списка книг будет выглядеть отлично. Тем не менее, когда у вас появятся десятки, или сотни записей ваша страница станет значительно дольше загружаться (и станет слишком длинной для комфортного просмотра). Решением данной проблемы является добавление постраничного вывода (Pagination) к вашему отображению списка, который будет выводить ограниченное количество элементов на каждой странице.

Django имеет отличный встроенный механизм для постраничного вывода. Даже более того, он встроен в обобщённый класс отображения списков, следовательно вам не нужно проделывать большой объем работы, чтобы воспользоваться возможностями постраничного вывода!

### Отображения

Откройте **catalog/views.py** и добавьте поле `paginate_by` как показано в следующем фрагменте.
```py
class BookListView(generic.ListView):
    model = Book
    paginate_by = 10
```

Как только у вас появится более 10 записей в базе данных отображение начнёт формировать постраничный вывод данных, которые он передаёт шаблону. К различным страницам данного вывода можно получить доступ при помощи параметров GET-запроса — к странице 2 вы можете получить доступ, используя URL-адрес: `/catalog/books/?page=2`.

### Шаблоны

Теперь, когда данные выводятся постранично, нам надо добавить функциональность переключения между страницами в шаблона страницы. Поскольку мы хотели бы использовать данный механизм для всех списков на сайте, то мы пропишем его в базовом шаблоне сайта.

Откройте **/locallibrary/catalog/templates/base_generic.html** и, ниже блока `content`, вставьте блок (во фрагменте не выделен жирным), отвечающий за постраничный вывод. Данный код, в первую очередь, проверяет "включён" ли механизм постраничного вывода для данной страницы и если это так, то он добавляет ссылки `next` и `previous`, соответственно (а также, номер текущей страницы).
```django
{% block content %}{% endblock %}

{% block pagination %}
  {% if is_paginated %}
    <div class="pagination">
      <span class="page-links">
        {% if page_obj.has_previous %}
          <a href="{{ request.path }}?page={{ page_obj.previous_page_number }}">previous</a>
        {% endif %}
        <span class="page-current">
          Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}.
        </span>
        {% if page_obj.has_next %}
          <a href="{{ request.path }}?page={{ page_obj.next_page_number }}">next</a>
        {% endif %}
      </span>
    </div>
  {% endif %}
{% endblock %}
```

Параметр `page_obj` является объектом типа [Paginator](https://docs.djangoproject.com/en/1.10/topics/pagination/#paginator-objects), который будет создаваться каждый раз, когда будет применяться постраничный вывод данных для текущей страницы. Он позволяет получить всю информацию о текущей странице, о предыдущих страницах, сколько всего страниц и так далее.

Мы используем `{{ request.path }}` для получения URL-адреса текущей страницы, для того, чтобы создать ссылки на соответствующие страницы, обратите внимание, что данный вызов не зависит от объекта `page_obj` и, таким образом, может использоваться отдельно.

На этом все!

[Назад к Django](#django)

### Как это выглядит?

Картинка ниже показывает как выглядит постраничный вывод — если вы не добавили более 10 записей в вашу базу данных, тогда вы можете проверить как это работает, просто уменьшив значение в `paginate_by`, в файле **catalog/views.py**. Для получения результата, соответствующего картинке ниже, мы изменили `paginate_by = 2`.

Ссылки на страницы показаны в нижней части страницы. Показаны ссылки следующая/предыдущая в зависимости от того на какой странице вы в данный момент находитесь.

![List Page paginated](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/book_list_paginated.png)

### Проверьте себя

Дополнительным задание в данной статье и для завершения данного этапа проекта будет создание отображений детальной информации об авторе и их списка. Эти отображения должны находиться по следующим адресам:

- `catalog/authors/` — Список авторов.
- `catalog/author/<id>` — Детальная информация об авторе со значением первичного ключа равным `<id>`

Соответствующий код для URL-преобразований и отображений должен быть идентичным коду для списка книг и детальной информации о книге `Book`, который мы создали ранее. Шаблоны будут отличаться, но будут иметь похожее поведение.

> **Примечание:**
>
> - Когда вы создадите URL-преобразование для страницы списка авторов вам понадобится обновить ссылку All authors в базовом шаблоне. Следуйте тем же путём, который мы проделали когда обновляли ссылку All books.
> - Когда вы создадите URL-преобразование для страницы с детальной информацией об авторе, вы должны будете обновить шаблон детальной информации о книге (/locallibrary/catalog/templates/catalog/book_detail.html), таким образом, чтобы ссылка автора указывала на страницу с детальной информации о нем (а не быть пустой). Данная ссылка будет иметь вид как указано жирным во фрагменте ниже.
>
> ```django
> <p>
>   <strong>Author:</strong>
>   <a href="{% url 'author-detail' book.author.pk %}">{{ book.author }}</a>
> </p>
> ```

Когда вы закончите, ваши страницы должны будут выглядеть как на картинке.

![pic1](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/author_list_page_no_pagination.png)

![pic2](https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Generic_views/author_detail_page_no_pagination.png)

[Назад к Django](#django)

### Итоги

Поздравляем! Наша базовая функциональность библиотеки готова!

В данной статье мы изучили как применять обобщённые классы отображения списка и детальной информации, и использовать их для создания страниц отображения наших книг и авторов. Кроме того, мы многое узнали о паттернах преобразования, построенных на основе регулярных выражений, а также то, как вы можете передавать данные из URL-адреса в ваше отображение. Мы изучили несколько приёмов применения шаблонов. В самом конце мы показали как осуществлять постраничный вывод списков, так, что наши списки управляются даже тогда, когда они содержат много записей.

В нашей следующей статье мы расширим нашу библиотеку, путём поддержки пользовательских аккаунтов, и так образом продемонстрируем аутентификацию, разграничение уровней доступа, сессии и формы.

- **Дополнительная информация**
- [Встроенные обобщённые классы отображения](https://docs.djangoproject.com/en/1.10/topics/class-based-views/generic-display/) (Django docs)
- [Обобщённый вид отображения](https://docs.djangoproject.com/en/1.10/ref/class-based-views/generic-display/) (Django docs)
- [Введение в отображения на основе классов](https://docs.djangoproject.com/en/1.10/topics/class-based-views/intro/) (Django docs)
- [Встроенные теги шаблона и фильтры](https://docs.djangoproject.com/en/1.10/ref/templates/builtins) (Django docs).
- [Постраничный вывод (Pagination)](https://docs.djangoproject.com/en/1.10/topics/pagination/) (Django docs)

[Назад к Django](#django)

## Django 7: сессии

Эта часть расширяет наш сайт LocalLibrary, добавляя счётчик посещений домашней страницы, реализованного при помощи сессий. Это относительно простой пример, но он демонстрирует то, как при помощи сессий реализовать анализ поведения анонимных пользователей на сайте.

| Требования: | Завершить изучение всех предыдущих разделов, включая Django [Руководство Часть 6: Обобщённые отображения списков и детальной информации](#django-6-отображение-списков-и-детальной-информации)
|----|----
| Цель: | Понимать как применять сессии.

### Обзор

В предыдущих частях мы создали сайт [LocalLibrary](#django-сайт-местной-библиотеки), который позволяет пользователям получать из каталога списки книг и авторов. На данный момент каждый посетитель сайта получает доступ к одним и тем же страницам и типам информации динамически сформированными из базы данных.

В "настоящей" библиотеке вам хотелось бы предоставить пользователю индивидуальные услуги, которые зависят от его предпочтений и предыдущего опыта использования сайта, его настроек и тому подобное. Например, при очередном посещении сайта вы можете скрыть сообщения об ошибках для тех пользователей, которые их уже получали, или сохранить и учитывать пользовательские настройки (например, количество выводимых данных на странице как результат какого-либо поиска).

Сессии позволяют вам реализовать такой род функциональности, который позволит вам хранить и получать произвольные данные, полученные на основе индивидуального поведения пользователя на сайте.

### Что такое сессии?

Все взаимодействия между браузерами и серверами осуществляются при помощи протокола HTTP, который не сохраняет своё состояние (stateless). Данный факт означает, что сообщения между клиентом и сервером являются полностью независимыми один от другого — то есть не существует какого-либо представления "последовательности", или поведения в зависимости от предыдущих сообщений. В результате, если вы хотите создать сайт, который будет отслеживать взаимодействие с клиентом (браузером), вам нужно реализовать это самостоятельно.

Сессии являются механизмом, который использует Django (да и весь остальной "Интернет") для отслеживания "состояния" между сайтом и каким-либо браузером. Сессии позволяют вам хранить произвольные данные браузера и получать их в тот момент, когда между данным браузером и сайтом устанавливается соединение. Данные получаются и сохраняются в сессии при помощи соответствующего "ключа".

Django использует куки (cookie), которые содержат специальный идентификатор сессии, который выделяет среди остальных, каждый браузер и соответствующую сессию. Реальные данные сессии, по умолчанию, хранятся в базе данных сайта (это более безопасно, чем сохранять данные в куки, где они могут быть уязвимы для злоумышленников). Однако, у вас есть возможность настроить Django так, чтобы сохранять данные сессий в других местах (кеше, файлах, "безопасных" куки). Но всё же хранение по умолчанию является хорошей и безопасной возможностью.

[Назад к Django](#django)

### Подключение сессий

Сессии стали доступны автоматически в тот момент, когда мы [создали скелет сайта](#django-2-создание-скелета) (во второй части руководства).

Необходимые конфигурации выполняются в разделах INSTALLED_APPS и MIDDLEWARE файла проекта (**locallibrary/locallibrary/settings.py**), как показано ниже:
```py
INSTALLED_APPS = [
    ...
    'django.contrib.sessions',
    ....

MIDDLEWARE = [
    ...
    'django.contrib.sessions.middleware.SessionMiddleware',
    ....
```

### Применение сессий

Вы можете получить доступ к переменной `session`, в соответствующем отображении, через параметр `request` (`HttpRequest` передаётся как первый аргумент в каждое отображение). Переменная сессии является связью с определённым пользователем (или, если быть более точным, связью с определённым браузером, который определяется при помощи идентификатора (`id`) сессии, получаемого из куки браузера).

Переменная (или поле) `session` является объектом-словарём, который служит для чтения и записи неограниченное число раз. С ним вы можете выполнять любые стандартные операции, включая очистку всех данных, проверку наличия ключа, циклы по данным и так далее. Большую часть времени вы будете тратить на обычные "словарные" операции - получения и установки значений.

Ниже представлены фрагменты кода, которые показывают вам как получать, задавать и удалять некоторые данные при помощи ключа "`my_car`", связанного с текущей сессией (браузером).

> **Примечание:** Одной из самых грандиозных вещей в Django является то, что вам не надо думать о механизме, который связывает сессию с текущим запросом в отображении. Во фрагменте ниже, всё что вам надо знать, это то, что `my_car` связана с тем браузером, который отправил текущий запрос.

```py
# Получение значения сессии при помощи ключа(то есть, 'my_car').
# Если такого ключа нет, то возникнет ошибка KeyError
my_car = request.session['my_car']

# Получение значения сессии. Если значения не существует,
# то вернётся значение по умолчанию ('mini')
my_car = request.session.get('my_car', 'mini')

# Передача значения в сессию
request.session['my_car'] = 'mini'

# Удаление значения из сессии
del request.session['my_car']
```

Данное API имеет другие методы, которые большей частью используются для управления куки, связанных с сессией. Например, существуют методы проверки того, что куки поддерживаются клиентским браузером, другие методы служат для установки и проверки предельных дат жизни куки, а также для очистки просроченных сессий из хранилища. Подробное описание API вы можете найти в разделе [Как использовать сессии](https://docs.djangoproject.com/en/1.10/topics/http/sessions/) (Django docs).

[Назад к Django](#django)

### Хранение данных сессии

По умолчанию Django сохраняет данные сессии в базу данных и отправляет соответствующие куки клиенту только тогда, когда сессия была *изменена*, или *удалена*. Если вы обновляете какие-либо данные при помощи ключа сессии, как показано в предыдущем фрагменте, тогда вам не надо беспокоиться о процессе сохранения! Например:
```py
# Данное присваивание распознается как обновление сессии
# и данные будут сохранены
request.session['my_car'] = 'mini'
```

Если вы обновите информацию внутри данных сессии, тогда Django не распознает эти изменения и не выполнит сохранение данных (например, если вы изменили "`wheels`" внутри переменной "`my_car`", как показано ниже). В таких случаях вам надо явно указывать, что сессия была изменена.
```py
# Объект сессии модифицируется неявно.
# Изменения НЕ БУДУТ сохранены!
request.session['my_car']['wheels'] = 'alloy'

# Явное указание, что данные изменены.
# Сессия будет сохранена, куки обновлены (если необходимо).
request.session.modified = True
```

> **Примечание:** Вы можете изменить поведение сессий таким образом, чтобы они записывали любое своё изменение в базу данных и отправляли куки, при каждом запросе, путём установки `SESSION_SAVE_EVERY_REQUEST = True`, в файле настроек проекта (**locallibrary/locallibrary/settings.py**).

[Назад к Django](#django)

### Простой пример — получение числа визитов

В качестве примера из реального мира мы обновим нашу библиотеку так, чтобы сообщать пользователю количество совершенных им визитов главной страницы сайта [LocalLibrary](#django-сайт-местной-библиотеки).

Откройте **/locallibrary/catalog/views.py** и добавьте изменения, выделенных жирным, ниже.
```py
def index(request):
    ...

    num_authors=Author.objects.count()  # The 'all()' is implied by default.

    # Number of visits to this view, as counted in the session variable.
    num_visits=request.session.get('num_visits', 0)
    request.session['num_visits'] = num_visits+1

    # Render the HTML template index.html with the data in the context variable.
    return render(
        request,
        'index.html',
        context={'num_books':num_books,'num_instances':num_instances,'num_instances_available':num_instances_available,'num_authors':num_authors,
            'num_visits':num_visits}, # num_visits appended
    )
```

В первую очередь мы получаем значение '`num_visits`' из сессии, возвращая 0, если оно не было установлено ранее. Каждый раз при получении запроса, мы увеличиваем данное значение на единицу и сохраняем его обратно в сессии (до следующего посещения данной страницы пользователем). Затем переменная `num_visits` передаётся в шаблон через переменную контекста `context`.

> **Примечание:** Можно проверить наличие поддержки куки в браузере (для примера, смотрите [Как использовать сессии](https://docs.djangoproject.com/en/1.10/topics/http/sessions/)), или разработать наш UI таким образом, чтобы это не имело значения.

Для показа значения переменной, из следующего фрагмента добавьте нижнюю строчку кода в ваш шаблон главной страницы сайта (**/locallibrary/catalog/templates/index.html**), в его нижний раздел "Dynamic content":
```django
<h2>Dynamic content</h2>

<p>The library has the following record counts:</p>
<ul>
  <li><strong>Books:</strong> {{ num_books }}</li>
  <li><strong>Copies:</strong> {{ num_instances }}</li>
  <li><strong>Copies available:</strong> {{ num_instances_available }}</li>
  <li><strong>Authors:</strong> {{ num_authors }}</li>
</ul>

<p>
  You have visited this page {{ num_visits }}{% if num_visits == 1 %} time{%
  else %} times{% endif %}.
</p>
```

Сохраните ваши изменения и перезапустите сервер. Данное значение должно изменяться всякий раз, когда вы обновляете страницу.

- **Итоги**

Вы узнали как применять сессии для улучшения взаимодействие с анонимными пользователями.

В наших следующих статьях мы рассмотрим фреймворк аутентификации и авторизации (разрешение доступа, permission), и покажем вам как поддерживать пользовательские аккаунты.

- **Смотрите также**
- [Как использовать сессии](https://docs.djangoproject.com/en/1.10/topics/http/sessions/) (Django docs)

[Назад к Django](#django)

## Django 8: аутентификация и авторизация пользователя

В данном руководстве мы продемонстрируем вам систему входа пользователя на ваш сайт используя его собственный аккаунт. Кроме того, мы покажем как реализовать контроль того, что может видеть и делать пользователь, в зависимости от того, залогинен он, или нет, а также имеет ли он соответствующий уровень прав доступа (*permissions*). Для того чтобы продемонстрировать все это, мы расширим [LocalLibrary](#django-сайт-местной-библиотеки), добавив страницы для входа/выхода, а также страницы просмотра/редактирования книг, специфические для пользователя и персонала.

| Требования: | Завершить изучение предыдущих тем руководства, включая [Руководство Django Часть 7: Работа с сессиями](#django-7-сессии).
|----|----
| Цель: | Понимать как настроить и использовать механизм аутентификации пользователя и разграничений прав доступа.


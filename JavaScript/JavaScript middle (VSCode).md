# JavaScript – Средний уровень

Вы уже знакомы с основами JavaScript и хотели бы пополнить свои знания? Тогда вы в правильном месте. На этом курсе вы научитесь создавать более сложные и гибкие программы, а также ещё более интерактивные сайты. Этот курс является продолжением нашего курса Введение в Javascript. Мы рекомендуем вам ознакомиться содержанием курса "Введение в Javascript", прежде чем начать этот курс.

<a id="back"></a>
### Оглавление:
### [Объекты](#obj)
#### [Введение в объекты](#intro_obj)
#### [Создание cобственных Объектов](#oun_obj)
#### [Приземлились! (практика)](#pract_1)
##### [Решение от GPT-4o](#pract_1_gpt)
#### [Инициализация объекта](#init_obj)
#### [Добавление методов](#add_methods)
#### [Расчет скидки (практика)](#pract_2)
##### [Решение от GPT-4o](#pract_2_gpt)
#### [Продолжение главы "добавление методов"](#add_methods_1)
##### [Коментарий GPT-4o](#gpt_comment_1)
#### [Квиз Модуля 1](#qviz_1)
#### [Менеджер контактов (практика)](#qviz_1_pract)
### [Core Objects](#core_obj)
#### [Массивы](#arrays)
#### [Пушистые блинчики (практика)](#pract_3)
#### [Другие способы создания массивов](#another_make_array)
#### [Свойства и методы массива](#props_methods_array)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)





<a id="obj"></a>
# Объекты

### [Назад к оглавлению](#back)


<a id="intro_obj"></a>
## Введение в объекты

### Объекты JavaScript
Переменные JavaScript являются контейнерами для значений данных. 

**Объекты** также являются переменными, но они могут содержать много значений.

Считайте объект списком значений, которые записаны как пары `имя:значение`, где имена и значения разделены двоеточиями.

Пример:
```js
var person = {
 name: "John", age: 31, 
 favColor: "green", height: 183
};
```
Эти значения называются **properties**.

![properties](https://lecontent.sololearn.com/material-images/2386c565169d4902b10c39ecc16368fe-2765.png)

Относительно объекта, `color`, `height`, `weight` и `name` являются примерами **свойства**.

### Свойства объекта
Вы можете получить доступ к свойствам объекта двумя способами.
```js
objectName.propertyName
//or
objectName['propertyName']
```
Этот пример демонстрирует, как получить доступ к `age` нашего объекта person.
```js
var age = person.age /* проверить позже */
```

Встроенное свойство `length` в JavaScript используется для подсчета количества символов в свойстве или строке.
```js
var course = {name: "JS", lessons: 41};
document.write(course.name.length);
```

Объекты являются одной из основных концепций в JavaScript.

### Методы объекта
**Метод объекта** - это свойство, содержащее **определение функции**.

Используйте следующий синтаксис для доступа к методу объекта.
```js
objectName.methodName()
```
Как вы уже знаете, `console.log()` регистрирует текст в консоли. Функция `log()` на самом деле является методом объекта `console`.
```js
console.log("This is some text");
```
**Методы** - это функции, которые хранятся в качестве свойств объекта.

### Объем кубоида (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

#### Введение в объекты
Данный класс представляет собой параллелепипед (например, прямоугольный), который содержит свойства длины, ширины и высоты.

Дополните программу, чтобы рассчитать и вывести в консоль объем данного параллелепипеда.

>> Подсказка: чтобы вычислить объем параллелепипеда, используйте формулу `length*width*height`.
```js
var cuboid = {
    length: 25,
    width: 50,
    height: 200
};

//your code goes here

console.log(cuboid.length * cuboid.width * cuboid.height)
```

Доступ к свойству `color` объекта `hair` используя синтаксис с точкой:
```js
hair.color
```

### [Назад к оглавлению](#back)


<a id="oun_obj"></a>
## Создание cобственных Объектов

### Конструктор объекта
В предыдущем уроке мы создали объект, используя **синтаксис литерала** (или инициализатора) объекта (объектный литерал).
```js
var person = {
  name: "John", age: 42, favColor: "green"
};
```
>> **Литерал** — это фиксированное значение, которое напрямую указывается в коде программы. Это может быть число, строка, логическое значение или объект, которое не требует вычисления или вызова функций.
>>
>> - Числовой литерал: 42
>> - Строковый литерал: "Hello, World!" или 'Hello, World!'
>> - Булевый литерал: true или false
>> - Объектный литерал: { name: "John", age: 42 }

Это позволяет вам создать только один объект.

Иногда нам нужно установить **"тип объекта"**, который может быть использован для создания нескольких объектов одного типа.

Стандартный способ создания "типа объекта" - использовать функцию **конструктора объекта**.
```js
function person(name, age, color) {
  this.name = name;
  this.age = age;
  this.favColor = color;
}
```
Вышеуказанная функция (`person`) является конструктором объекта, который принимает параметры и присваивает их свойствам объекта.

> Подсказка: ключевое слово **this** относится к **текущему объекту**.
>
> Обратите внимание, что this не является переменной. Это ключевое слово, и его значение не может быть изменено.

Пример создания функции конструктора:
```js
function movie(title, director) {
  this.title = title;
  this.director = director;
}
```

### Создание объектов
Как только у вас есть конструктор объектов, вы можете использовать ключевое слово **new** для создания новых объектов того же типа.
```js
function person(name, age, color) {
    this.name = name;
    this.age = age;
    this.favColor = color;
}

var p1 = new person("John", 42, "green");
var p2 = new person("Amy", 21, "red");

document.write(p1.age); 
```
> `p1` и `p2` теперь являются объектами типа `person`. Их свойства присваиваются соответствующим значениям.

Для создания экземпляра объекта используется ключевое слово - **new**.

### Создание объектов
Рассмотрим следующий пример.
```js
function person (name, age) {
    this.name = name;
    this.age = age;
}
var John = new person("John", 25);
var James = new person("James", 21);

document.write(John.age);
```
Доступ к свойствам объекта осуществляется с использованием **синтаксиса с точкой**, как вы делали это ранее.
![prop](https://lecontent.sololearn.com/material-images/b04e074ca656477cb0e961e056a5bed1-2766.png)

> Понимание создания объектов является важным.

### [Назад к оглавлению](#back)


<a id="pract_1"></a>
### Приземлились! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Создание собственных объектов
Боба наняли информационным офицером аэропорта, и ему нужно генерировать статусные сообщения для каждого рейса. Давайте поможем ему!

Дополните данную программу, исправив конструктор, создав объект рейса и присвоив его данной переменной, чтобы правильно выполнить соответствующее сообщение.

ID рейса и статус рейса (приземлился, вовремя, задержка и т.д.) принимаются в качестве входных данных.

```js
Пример ввода:
NGT 929
приземлился

Пример вывода:
Flight NGT 929 has landed
```
> Используйте ключевое слово `new` для создания нового объекта с использованием конструктора.

Оригинальный код:
```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    var flight1;
    //assign a flight object to flight1 variable
    
    //output
    console.log('The flight ' + flight1.number + ' is ' + flight1.status)
    
}

function Flight(flightNumber, status) {
    //fix the constructor
    number = flightNumber;
    status = status;
};
```

<a id="pract_1_gpt"></a>
### Решение от GPT-4o

Окей, давай разберем твою задачу шаг за шагом и объясню, что нужно сделать.

### 1. **Ошибка в конструкторе**
В конструкторе функции `Flight` у тебя объявлены переменные `number` и `status`, но они не привязаны к объекту, который создается с помощью этого конструктора. В JavaScript, чтобы создать свойства объекта внутри конструктора, нужно использовать ключевое слово `this`.

### 2. **Исправляем конструктор**
Когда создается объект с помощью `new Flight(...)`, нам нужно привязать свойства `number` и `status` к самому объекту, используя `this`. Это позволит обращаться к этим свойствам у объекта.

Вот как нужно исправить:

```js
function Flight(flightNumber, status) {
    this.number = flightNumber; // Привязываем параметр к объекту через this
    this.status = status;       // То же самое со статусом
}
```

Теперь свойства `number` и `status` станут частью объекта, который мы создадим через `new Flight()`.

### 3. **Создание объекта**
Теперь, когда конструктор исправлен, можно создать объект рейса и присвоить его переменной `flight1`.

```js
var flight1 = new Flight(flightNumber, flightStatus);
```

Это создаст новый объект `flight1`, где:
- `flight1.number` будет равно значению `flightNumber`
- `flight1.status` будет равно значению `flightStatus`

### 4. **Окончательный код**
Теперь соберем всё вместе:

```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    // Создаем объект рейса, используя конструктор
    var flight1 = new Flight(flightNumber, flightStatus);
    
    // Выводим сообщение с использованием свойств объекта
    console.log('The flight ' + flight1.number + ' is ' + flight1.status);
}

function Flight(flightNumber, status) {
    // Привязываем свойства к объекту через this
    this.number = flightNumber;
    this.status = status;
}
```

### 5. **Объяснение для чайника**

- **Конструктор `Flight`** — это как шаблон для создания объекта рейса. Когда ты создаёшь объект (например, `flight1`), конструктор берет параметры (номер рейса и статус) и сохраняет их в свойствах объекта с помощью `this`.
  
  `this.number = flightNumber` означает: «В объекте, который сейчас создаётся, создай свойство `number` и присвой ему значение переменной `flightNumber`».

- **Создание объекта `flight1`** через `new Flight(...)` означает: «Создай новый объект рейса, используя указанный номер рейса и статус».

- **`flight1.number`** и **`flight1.status`** — это свойства объекта `flight1`, к которым мы можем обращаться и выводить их значения.

Теперь программа будет выводить корректное сообщение о статусе рейса!
</spoiler>

### Продолжение урока. Создание объектов
Рассмотрим следующий пример.
```js
function person (name, age) {
    this.name = name;
    this.age = age;
}
var John = new person("John", 25);
var James = new person("James", 21);

document.write(John.age);
```
Доступ к свойствам объекта осуществляется с использованием синтаксиса с точкой, как вы делали это ранее.

![table](https://lecontent.sololearn.com/material-images/b04e074ca656477cb0e961e056a5bed1-2766.png)

> Понимание создания объектов является важным.

В качестве примера - два компонента необходимых для использования информации, содержащейся в объекте:
- имя объекта
- имя свойства

### [Назад к оглавлению](#back)


<a id="init_obj"></a>
## Инициализация объекта

Используйте синтаксис **объектного литерала** или **инициализатора** для создания отдельных объектов.
```js
var John = {name: "John", age: 25};
var James = {name: "James", age: 21};
```

Объекты состоят из свойств, которые используются для описания объекта. Значения свойств объекта могут содержать как примитивные типы данных, так и другие объекты.
```js
simba = {
    category: "lion", 
    gender: "male"
}
```

### Использование инициализаторов объектов

Пробелы и переносы строк не важны. Определение объекта может занимать несколько строк.

 Независимо от того, как создан объект, синтаксис для доступа к свойствам и методам не меняется.
```js
var John = {
    name: "John",
    age: 25
};
var James = {
    name: "James",
    age: 21
};

document.write(John.age);
//альтернатива: document.write(John['age']);
```

Код выше отобразит 25. Не заывайте об альтернативном способе доступа к свойству объекта: `document.write(John['age']);`.

Например следующее выражение отобразит свойство `category` объекта `simba` на экране:
```js
document.write(simba.category);
```

### [Назад к оглавлению](#back)


<a id="add_methods"></a>
## Добавление методов

### Методы - это функции, которые хранятся в свойствах объекта. 

Используйте следующий синтаксис для создания метода объекта:
```js
methodName = function() { code lines }
```

Доступ к методу объекта осуществляется с использованием следующего синтаксиса:
```js
objectName.methodName()
```

**Метод** - это функция, принадлежащая объекту. Она может быть вызвана с использованием ключевого слова **this**. 

Ключевое слово **this** используется как **ссылка на текущий объект**, что означает, что вы можете получить доступ к свойствам и методам объекта, используя его.

Определение методов производится внутри функции-конструктора.
```sql
function person(name, age) {
    this.name = name;  
    this.age = age;
    this.changeName = function (name) {
        this.name = name;
    }
}

var p = new person("David", 21);
p.changeName("John");

document.write(p.name);
```

В приведенном выше примере мы определили метод с именем `changeName` для нашего `person`, который является функцией, принимающей параметр `name` и присваивающей его свойству `name` объекта.

`this.name` относится к свойству `name` объекта.

>> Метод `changeName` изменяет свойство `name` объекта на его аргумент.


### [Назад к оглавлению](#back)


<a id="pract_2"></a>
## Расчет скидки (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Добавление методов
  

Менеджеру магазина нужна программа для установки скидок на товары.  Программа должна принимать ID продукта, цену и скидку в качестве ввода и выводить цену со скидкой. Однако метод `changePrice`, который должен рассчитывать скидку, неполный. Исправьте это!
```js
Пример ввода
LD1493
1700
15

Пример вывода
LD1493 цена: 1700
LD1493 новая цена: 1445
```
> Подсказка: первый ввод - это ID продукта, второй - цена до скидки, а третий - процент скидки.
>
>Так что после применения скидки новая цена будет 1700-(0.15*1700) = 1445.
```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(),10);
    var discount = parseInt(readLine(),10);
    
    var prod1= new Product(prodID, price);
    console.log(prod1.prodID + " цена: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " новая цена: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        //your code goes here
        
    }
}
```

<a id="pract_2_gpt"></a>
### Решение от GPT-4o
Давай разберем этот пример шаг за шагом, чтобы всё стало максимально понятно. В этой задаче мы должны создать класс продукта, и добавить в него метод для расчета новой цены с учётом скидки.

### Разбор задачи:

1. **Входные данные**:
    - **ID продукта** (`prodID`): Например, "LD1493".
    - **Цена продукта** (`price`): Например, 1700.
    - **Скидка** (`discount`): Например, 15 (процентов).

2. **Вывод**:
    - Сначала нужно вывести цену до скидки.
    - Затем нужно рассчитать цену после применения скидки и вывести новую цену.

### Код:

1. Функция `main`:
    - **`prodID = readLine();`** — получаем ID продукта.
    - **`price = parseInt(readLine(), 10);`** — получаем цену продукта и преобразуем её в целое число с помощью `parseInt()`.
    - **`discount = parseInt(readLine(), 10);`** — получаем размер скидки (в процентах) и тоже преобразуем его в число.

2. **Создание объекта**:
    - **`var prod1 = new Product(prodID, price);`** — создаём объект класса `Product` с параметрами `prodID` и `price`.

3. **Вывод первоначальной цены**:
    - **`console.log(prod1.prodID + " price: " + prod1.price);`** — выводим ID продукта и его первоначальную цену.

4. **Применение скидки**:
    - **`prod1.changePrice(discount);`** — вызываем метод `changePrice`, который должен изменить цену продукта с учётом скидки.
    - **`console.log(prod1.prodID + " new price: " + prod1.price);`** — выводим ID продукта и новую цену после применения скидки.

### Конструктор `Product`:

```js
function Product(prodID, price) {
    this.prodID = prodID; // Идентификатор продукта
    this.price = price;   // Цена продукта
}
```

Этот конструктор принимает два параметра (ID продукта и цену) и присваивает их свойствам создаваемого объекта (`this.prodID` и `this.price`).

### Метод `changePrice`:

Здесь мы добавляем логику для расчета новой цены:

```js
this.changePrice = function(discount) {
    // Рассчитываем новую цену с учётом скидки
    this.price = this.price - (this.price * discount / 100);
}
```

#### Как работает:
- Мы берём текущую цену продукта: `this.price`.
- Вычисляем скидку: `this.price * discount / 100`. Это процент скидки от цены.
- Вычитаем эту скидку из цены: `this.price = this.price - скидка`.

Например, если:
- Цена товара = 1700.
- Скидка = 15%.

То:
- Скидка = 1700 * 15 / 100 = 255.
- Новая цена = 1700 - 255 = 1445.

### Окончательный код:

```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(), 10);
    var discount = parseInt(readLine(), 10);
    
    var prod1 = new Product(prodID, price);
    console.log(prod1.prodID + " price: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " new price: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        this.price = this.price - (this.price * discount / 100);
    }
}
```

### Пояснение:
1. Мы создали объект `Product` с ID продукта и начальной ценой.
2. Метод `changePrice` применяет скидку, рассчитывая новую цену.
3. Мы выводим старую и новую цену продукта после изменения.

Этот код делает именно то, что требуется: получает ID, цену, скидку, выводит цену до и после применения скидки. Надеюсь, это помогло тебе лучше понять, как всё работает!

### [Назад к оглавлению](#back)


<a id="add_methods_1"></a>
## Продолжение главы "добавление методов"

### Методы

Еще раз повторим:

Ключевое слово **this** в методе означает - **текущий объект**

Вы также можете определить функцию вне конструктора функции и связать ее с объектом.
```js
function person(name, age) {
  this.name= name;  
  this.age = age;
  this.yearOfBirth = bornYear;
}
function bornYear() {
  return 2024 - this.age;
}
```

Как вы можете видеть, мы назначили свойству объекта `yearOfBirth` функцию `bornYear`.

Ключевое слово `this` используется для доступа к свойству `age` объекта, который будет вызывать метод. 

Обратите внимание, что не обязательно писать скобки функции при ее присваивании объекту.

Следующий код связывает функцию конструктора `testData` с методом под названием `mymethod`:
```js
function testData (first, second) {
  this.first = first;
  this.second = second;
  this.checkData = mymethod;
}
```

Обычный вызов метода (код отобразит 1982):
```js
function person(name, age) {
    this.name= name;
    this.age = age;
    this.yearOfBirth = bornYear;
}
function bornYear() {
    return 2024 - this.age;
}

var p = new person("A", 42);

document.write(p.yearOfBirth());
```

Чтобы использовать свойства объекта в функции, используйте ключевое слово **"this"**.

<a id="gpt_comment_1"></a>
### Коментарий GPT-4o

В этом примере происходит путаница между тем, как назначаются методы объектам в JavaScript. Давай разберём по шагам, что тут происходит и как это исправить.

### Разбор кода:

1. **Конструктор `person`**:
    ```js
    function person(name, age) {
        this.name = name; // Присваиваем свойству `name` значение параметра `name`
        this.age = age;   // Присваиваем свойству `age` значение параметра `age`
        this.yearOfBirth = bornYear; // Присваиваем свойству `yearOfBirth` ссылку на функцию bornYear
    }
    ```

   Здесь создаётся конструктор для объекта `person`, где:
   - `this.name` — это имя объекта.
   - `this.age` — возраст объекта.
   - **Важный момент**: `this.yearOfBirth = bornYear;` — здесь мы присваиваем свойству объекта ссылку на функцию `bornYear`.

2. **Функция `bornYear`**:
    ```js
    function bornYear() {
        return 2016 - this.age;
    }
    ```

   Это обычная функция, которая вычисляет год рождения, основываясь на возрасте. Однако есть проблема: в этой функции используется `this.age`, но если вызвать её без привязки к объекту, `this` не будет ссылаться на текущий объект.

3. **Создание объекта**:
    ```js
    var p = new person("A", 22);
    ```

    Мы создаём новый объект `p`, где:
    - `p.name = "A"`.
    - `p.age = 22`.
    - `p.yearOfBirth` теперь ссылается на функцию `bornYear`.

4. **Вызов метода**:
    ```js
    document.write(p.yearOfBirth());
    ```

   Здесь мы пытаемся вызвать метод `yearOfBirth` через объект `p`. В теории, он должен вернуть год рождения, но будет ошибка, потому что в функции `bornYear` `this` указывает не на объект `p`, а на глобальный объект, где свойства `age` нет.

### Что значит **вызовите метод по свойству, а не по имени функции**?

Это значит, что вместо вызова функции напрямую (например, `bornYear()`), нужно использовать свойство объекта. В данном случае, ты правильно вызываешь метод через свойство объекта: `p.yearOfBirth()`.

Но, чтобы это заработало, нужно правильно привязать `this` к текущему объекту. Для этого нужно либо переписать функцию как метод объекта, либо воспользоваться стрелочной функцией.

### Исправление:

Чтобы всё заработало правильно, нужно убедиться, что `this` в функции `bornYear` ссылается на объект. Есть несколько способов это сделать.

#### Способ 1: Определить функцию `bornYear` как метод объекта

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = function() {
        return 2016 - this.age; // Здесь `this` указывает на объект `p`
    };
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Теперь метод `yearOfBirth` является частью объекта, и `this` будет ссылаться на объект `p`, поэтому всё сработает корректно.

#### Способ 2: Использовать стрелочную функцию

Стрелочные функции автоматически привязывают контекст `this` к текущему объекту.

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = () => 2016 - this.age; // Стрелочная функция
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Стрелочная функция захватывает контекст `this` объекта `p`, поэтому всё работает правильно.

### Вывод:

- **Вызов по свойству** означает, что ты должен использовать `p.yearOfBirth()` вместо прямого вызова `bornYear()`, чтобы метод работал как часть объекта.
- Чтобы код работал корректно, `this` в методе должен ссылаться на текущий объект. Это можно сделать, объявив метод внутри конструктора или используя стрелочную функцию.

Теперь код будет работать как надо!

### [Назад к оглавлению](#back)


<a id="qviz_1"></a>
## Квиз Модуля 1
1. Свойства объекта похожи на переменные; методы похожи на:

- [ ] операторы
- [x] функции
- [ ] свойства
- [ ] условные операторы

2. Каков результат следующего выражения?
```js
var myString = "abcdef";
document.write(myString.length);
```
Ответ: 6

3. Завершите выражение для создания конструктора объекта, учитывая, что **height** и **weight** являются свойствами, а **calculate** является методом для данного объекта:
```js
function mathCalc (height, weight) {
  this.height = [height];
  this.weight = [weight];
  this.sampleCalc = [calculate];
}
// *в квадратных скобках [] указаны места, куда нужно было вставить недостающие части выражения. Скобки не учитываются.
```

### [Назад к оглавлению](#back)


<a id="qviz_1_pract"></a>
## Менеджер контактов
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ 

Вы работаете над приложением Менеджер контактов.

Вы создали конструктор объекта `contact`, который имеет два аргумента, `name` и `number`.

Вам нужно добавить метод `print()` к объекту, который будет выводить данные контакта в консоль в следующем формате: `name: number`

Данный код объявляет два объекта и вызывает их методы `print()`. Завершите код, определив метод `print()` для объектов.

> Обратите внимание на пробел после двоеточия при выводе контактных данных.
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);
a.print();
b.print();
```

Решение способом **определения функции как метод объекта** (пример решения способом стрелочной функции [был описан выше](#gpt_comment_1)):
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
    // Определить функцию print как метод объекта
    this.print = function() {
        return name + ": " + number;
    }
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);

// Вывести метод print объекта contact в консоль
console.log(a.print());
console.log(b.print());
```

### [Назад к оглавлению](#back)


<a id="core_obj"></a>
# Core Objects

<a id="arrays"></a>
## Массивы

### Массивы в JavaScript
Массивы хранят несколько значений в одной переменной. 

Чтобы сохранить названия трех курсов, вам потребуются три переменные.
```js
var course1 ="HTML";
var course2 ="CSS";
var course3 ="JS";
```

Но что, если у вас было 500 курсов? Решение - **array (массив)**.
```js
var courses = new Array("HTML", "CSS", "JS");
```

Этот синтаксис объявляет массив с именем **courses**, который хранит три значения или элемента.

Два ключевых слова для создания массива:
- **new**
- **Array**

### Обращение к элементам массива
Вы обращаетесь к элементу массива, указывая **номер индекса** в **квадратных скобках**. 

Следующе утверждение обращается к значению первого элемента в `courses` и изменяет значение второго элемента.
```js
var courses = new Array("HTML", "CSS", "JS");
var course = courses[0]; // Обращение к HTML
courses[1] = "C++"; // Изменение второго элемента
```

- **[0]** - первый элемент в массиве. 
- **[1]** - второй элемент. 

> Индексы массива начинаются с ноля - `0`.

Результатом выполнения следующего кода - станет `6`:
```sql
var arr = new Array(3, 6, 8);
document.write(arr[1]);
```

### Доступ к массиву
Попытка доступа к индексу за пределами массива возвращает значение `undefined`, что буквально означает - неопределено. Таким выводом будет итог работы следующего кода:
```js
var courses = new Array("HTML", "CSS", "JS"); 
document.write(courses[10]);
```

Наш массив `courses` имеет всего три элемента, поэтому десятый индекс, который является 11-м элементом, не существует (не определен).

### [Назад к оглавлению](#back)


<a id="pract_3"></a>
## Пушистые блинчики (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Массивы 
Представленный вам массив представляет собой меню завтраков, доступных в отеле.

Шеф-повар решил заменить один из вариантов на "Fluffy Pancakes" (Пушистые блинчики).

Напишите программу, чтобы взять индекс как ввод, заменить элемент с этим индексом на "Fluffy Pancakes" и вывести новое меню в консоль в виде массива.
```js
Пример ввода:
2

Пример вывода:
[
  'Cinnamon Doughnuts',
  'Waffles',
  'Fluffy Pancakes',
  'Chorizo Burrito',
  'French Toast'
]
```
Элемент с индексом `2` был заменен в выходном массиве.

Помните, что первый элемент массива имеет индекс `0`.
```js
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    // замените соответствующий элемент на 'Fluffy Pancakes'.
    
    // вывести menu в консоль
    
}
```

Решение:
```sql
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    //замените соответствующий элемент на "Fluffy Pancakes".
    breakfasts[index] = "Fluffy Pancakes";
    //вывести меню на консоль
    console.log(breakfasts);
}
```

### [Назад к оглавлению](#back)


<a id="another_make_array"></a>
## Другие способы создания массивов
### Создание массивов
Вы также можете объявить массив, указать количество элементов, которые он будет хранить, и добавить элементы позже.

Следующий код выведет `"JS"`:
```js
var courses = new Array(3);
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";

document.write(courses[2]);
```

Массив - это особый тип объекта.
- **Массив** использует **числа** для доступа к своим элементам, а 
- **Объект** использует **имена** для доступа к своим членам.

### Создание массивов
Массивы в JavaScript динамические, поэтому вы можете объявить массив и не передавать никаких аргументов с конструктором `Array()`. Затем вы можете динамически добавлять элементы:
```js
var courses = new Array();
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";
courses[3] = "C++";

document.write(courses[2]);
```

Вы можете добавить столько элементов, сколько вам нужно.

### Литерал массива
Для большей простоты, удобочитаемости и скорости выполнения, вы также можете объявлять массивы, используя синтаксис **литерала массива**.
```js
var courses = ["HTML", "CSS", "JS"]; 

document.write(courses[2]);
```
Такой синтаксис приводит к созданию такого же массива, как и тот, который создается с использованием нового синтаксиса `Array()`. Код выдаст результат - "JS".

Вы можете получить доступ и изменить элементы массива, используя номер индекса, как вы делали раньше.

Синтаксис **литерала массива** является **рекомендуемым** способом объявления массивов.

Вводя `var example = new Array();`, мы создаем пустой массив, который можно заполнить **в любое время позже**.

### [Назад к оглавлению](#back)


<a id="props_methods_array"></a>
## Свойства и методы массива

### Свойство length
У массивов JavaScript есть полезные встроенные свойства и методы.

Свойство `length` массива возвращает количество его элементов. Следующий код вернет число 9:
```js
var courses = ["HTML", "CSS", "JS"];
document.write(courses.length);
```

Свойство `length` всегда на одну единицу больше, чем самый высокий индекс массива.

Если массив пуст, свойство `length` возвращает ноль - `0`.

Массив имеет свойство `length` - потому что является объектом.

### Объединение массивов
Метод `concat()` в JavaScript позволяет вам объединять массивы и создавать совершенно новый массив. 
```js
var c1 = ["HTML", "CSS"];
var c2 = ["JS", "C++"];
var courses = c1.concat(c2);

document.write(courses[2]);
```

Массив `courses`, который получается в результате, содержит 4 элемента (HTML, CSS, JS, C++). На выходе получаем неизменый JS. 

Операция `concat` не влияет на массивы `c1` и `c2` - она возвращает результат конкатенации в виде **нового массива**.

## Повысь уровень! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Свойства и методы массивов
Игрок получает очки после прохождения каждого уровня игры.

Данная программа принимает число пройденных уровней в качестве входных данных, за которыми следуют набранные за каждый уровень очки, и создает соответствующий массив очков.

Дополните программу, чтобы рассчитать и вывести на консоль сумму всех набранных очков.
```js
Пример ввода
3
1
4
8

Пример вывода
13
```

Объяснение

Первый ввод представляет собой число пройденных уровней, -- в этом случае, 3 (размер создаваемого массива). Следующие 3 ввода -- это очки, начисленные игроку за прохождение каждого уровня. Игрок набрал 1+4+8 очков за 3 пройденных уровня, что затем выводится.

Обратите внимание, что первое введенное число может быть использовано в качестве длины массива.
```js
function main() {
    // Получение числа пройденных уровней
    var levels = parseInt(readLine(),10);
    var points = new Array();
    
    var count = 0;
    while(count<levels){
        var elem = parseInt(readLine(),10);
        points[count] = elem;
        count++;
    }
    
    var sum = 0;
    //вычислить сумму баллов
     
    
    //output
    console.log(sum);
}
```


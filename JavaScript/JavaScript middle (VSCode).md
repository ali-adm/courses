# JavaScript – Средний уровень

Вы уже знакомы с основами JavaScript и хотели бы пополнить свои знания? Тогда вы в правильном месте. На этом курсе вы научитесь создавать более сложные и гибкие программы, а также ещё более интерактивные сайты. Этот курс является продолжением нашего курса Введение в Javascript. Мы рекомендуем вам ознакомиться содержанием курса "Введение в Javascript", прежде чем начать этот курс.

<a id="back"></a>
### Оглавление:
### [Объекты](#obj)
#### [Введение в объекты](#intro_obj)
#### [Создание cобственных Объектов](#oun_obj)
##### [Приземлились! (практика)](#pract_1)
##### [Решение от GPT-4o](#pract_1_gpt)
#### [Инициализация объекта](#init_obj)
#### [Добавление методов](#add_methods)
##### [Расчет скидки (практика)](#pract_2)
##### [Решение от GPT-4o](#pract_2_gpt)
#### [Продолжение главы "добавление методов"](#add_methods_1)
##### [Коментарий GPT-4o](#gpt_comment_1)
#### [Квиз Модуля 1](#qviz_1)
##### [Менеджер контактов (практика)](#qviz_1_pract)
### [Core Objects](#core_obj)
#### [Массивы](#arrays)
##### [Пушистые блинчики (практика)](#pract_3)
#### [Другие способы создания массивов](#another_make_array)
#### [Свойства и методы массива](#props_methods_array)
##### [Повысь уровень! (практика)](#pract_4)
##### [Решение от GPT-4o](#pract_4_gpt)
#### [Ассоциативные массивы](#asoc_arriv)
#### [Математический объект](#math_obj)
##### [Какой век? (Практика)](#pract_5)
#### [Объект Date](#date_obj)
##### [Понедельник до Воскресенья (практика)](#pract_6)
##### [Решение от GPT-4o](#pract_6_gpt)
#### [Викторина модуля 2](#exam_2)
##### [Менеджер магазина (практическое упражнение)](#pract_7)
##### [Решение от GPT-4o](#pract_7_gpt)
### [DOM & События](#dom_events)
#### [Что такое DOM?](#what_is_dom)
#### [Выбор элементов](#elements_select)
#### [Изменение элементов](#change_elements)
#### [Добавление и удаление элементов](#add_del_elements)
#### [Создание анимаций](#criate_animation)
#### [Обработка событий](#event_handling)
#### [Распространение событий](#event_spreading)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)





<a id="obj"></a>
# Объекты

### [Назад к оглавлению](#back)


<a id="intro_obj"></a>
## Введение в объекты

### Объекты JavaScript
Переменные JavaScript являются контейнерами для значений данных. 

**Объекты** также являются переменными, но они могут содержать много значений.

Считайте объект списком значений, которые записаны как пары `имя:значение`, где имена и значения разделены двоеточиями.

Пример:
```js
var person = {
 name: "John", age: 31, 
 favColor: "green", height: 183
};
```
Эти значения называются **properties**.

|Property |Property Value |
|--|--|
|**name** |John |
|**age** |31 |
|**favColor** |green |
|**height** |183 |

Относительно объекта, `color`, `height`, `weight` и `name` являются примерами **свойства**.

### Свойства объекта
Вы можете получить доступ к свойствам объекта двумя способами.
```js
objectName.propertyName
//or
objectName['propertyName']
```
Этот пример демонстрирует, как получить доступ к `age` нашего объекта person.
```js
var age = person.age /* проверить позже */
```

Встроенное свойство `length` в JavaScript используется для подсчета количества символов в свойстве или строке.
```js
var course = {name: "JS", lessons: 41};
document.write(course.name.length);
```

Объекты являются одной из основных концепций в JavaScript.

### Методы объекта
**Метод объекта** - это свойство, содержащее **определение функции**.

Используйте следующий синтаксис для доступа к методу объекта.
```js
objectName.methodName()
```
Как вы уже знаете, `console.log()` регистрирует текст в консоли. Функция `log()` на самом деле является методом объекта `console`.
```js
console.log("This is some text");
```
**Методы** - это функции, которые хранятся в качестве свойств объекта.

### Объем кубоида (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

#### Введение в объекты
Данный класс представляет собой параллелепипед (например, прямоугольный), который содержит свойства длины, ширины и высоты.

Дополните программу, чтобы рассчитать и вывести в консоль объем данного параллелепипеда.

>> Подсказка: чтобы вычислить объем параллелепипеда, используйте формулу `length*width*height`.
```js
var cuboid = {
    length: 25,
    width: 50,
    height: 200
};

//your code goes here

console.log(cuboid.length * cuboid.width * cuboid.height)
```

Доступ к свойству `color` объекта `hair` используя синтаксис с точкой:
```js
hair.color
```

### [Назад к оглавлению](#back)


<a id="oun_obj"></a>
## Создание cобственных Объектов

### Конструктор объекта
В предыдущем уроке мы создали объект, используя **синтаксис литерала** (или инициализатора) объекта (объектный литерал).
```js
var person = {
  name: "John", age: 42, favColor: "green"
};
```
>> **Литерал** — это фиксированное значение, которое напрямую указывается в коде программы. Это может быть число, строка, логическое значение или объект, которое не требует вычисления или вызова функций.
>>
>> - Числовой литерал: 42
>> - Строковый литерал: "Hello, World!" или 'Hello, World!'
>> - Булевый литерал: true или false
>> - Объектный литерал: { name: "John", age: 42 }

Это позволяет вам создать только один объект.

Иногда нам нужно установить **"тип объекта"**, который может быть использован для создания нескольких объектов одного типа.

Стандартный способ создания "типа объекта" - использовать функцию **конструктора объекта**.
```js
function person(name, age, color) {
  this.name = name;
  this.age = age;
  this.favColor = color;
}
```
Вышеуказанная функция (`person`) является конструктором объекта, который принимает параметры и присваивает их свойствам объекта.

> Подсказка: ключевое слово **this** относится к **текущему объекту**.
>
> Обратите внимание, что this не является переменной. Это ключевое слово, и его значение не может быть изменено.

Пример создания функции конструктора:
```js
function movie(title, director) {
  this.title = title;
  this.director = director;
}
```

### Создание объектов
Как только у вас есть конструктор объектов, вы можете использовать ключевое слово **new** для создания новых объектов того же типа.
```js
function person(name, age, color) {
    this.name = name;
    this.age = age;
    this.favColor = color;
}

var p1 = new person("John", 42, "green");
var p2 = new person("Amy", 21, "red");

document.write(p1.age); 
```
> `p1` и `p2` теперь являются объектами типа `person`. Их свойства присваиваются соответствующим значениям.

Для создания экземпляра объекта используется ключевое слово - **new**.

### Создание объектов
Рассмотрим следующий пример.
```js
function person (name, age) {
    this.name = name;
    this.age = age;
}
var John = new person("John", 25);
var James = new person("James", 21);

document.write(John.age);
```
Доступ к свойствам объекта осуществляется с использованием **синтаксиса с точкой**, как вы делали это ранее.

|Object's |Property's name |
|--|--|
|**John.** |name |
|**John.** |age |
|**James.** |name |
|**James.** |age |

> Понимание создания объектов является важным.

В качестве примера - два компонента необходимых для использования информации, содержащейся в объекте:
- имя объекта
- имя свойства

### [Назад к оглавлению](#back)


<a id="pract_1"></a>
### Приземлились! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Создание собственных объектов
Боба наняли информационным офицером аэропорта, и ему нужно генерировать статусные сообщения для каждого рейса. Давайте поможем ему!

Дополните данную программу, исправив конструктор, создав объект рейса и присвоив его данной переменной, чтобы правильно выполнить соответствующее сообщение.

ID рейса и статус рейса (приземлился, вовремя, задержка и т.д.) принимаются в качестве входных данных.

```js
Пример ввода:
NGT 929
приземлился

Пример вывода:
Flight NGT 929 has landed
```
> Используйте ключевое слово `new` для создания нового объекта с использованием конструктора.

Оригинальный код:
```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    var flight1;
    //assign a flight object to flight1 variable
    
    //output
    console.log('The flight ' + flight1.number + ' is ' + flight1.status)
    
}

function Flight(flightNumber, status) {
    //fix the constructor
    number = flightNumber;
    status = status;
};
```

<a id="pract_1_gpt"></a>
### Решение от GPT-4o

Окей, давай разберем твою задачу шаг за шагом и объясню, что нужно сделать.

### 1. **Ошибка в конструкторе**
В конструкторе функции `Flight` у тебя объявлены переменные `number` и `status`, но они не привязаны к объекту, который создается с помощью этого конструктора. В JavaScript, чтобы создать свойства объекта внутри конструктора, нужно использовать ключевое слово `this`.

### 2. **Исправляем конструктор**
Когда создается объект с помощью `new Flight(...)`, нам нужно привязать свойства `number` и `status` к самому объекту, используя `this`. Это позволит обращаться к этим свойствам у объекта.

Вот как нужно исправить:

```js
function Flight(flightNumber, status) {
    this.number = flightNumber; // Привязываем параметр к объекту через this
    this.status = status;       // То же самое со статусом
}
```

Теперь свойства `number` и `status` станут частью объекта, который мы создадим через `new Flight()`.

### 3. **Создание объекта**
Теперь, когда конструктор исправлен, можно создать объект рейса и присвоить его переменной `flight1`.

```js
var flight1 = new Flight(flightNumber, flightStatus);
```

Это создаст новый объект `flight1`, где:
- `flight1.number` будет равно значению `flightNumber`
- `flight1.status` будет равно значению `flightStatus`

### 4. **Окончательный код**
Теперь соберем всё вместе:

```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    // Создаем объект рейса, используя конструктор
    var flight1 = new Flight(flightNumber, flightStatus);
    
    // Выводим сообщение с использованием свойств объекта
    console.log('The flight ' + flight1.number + ' is ' + flight1.status);
}

function Flight(flightNumber, status) {
    // Привязываем свойства к объекту через this
    this.number = flightNumber;
    this.status = status;
}
```

### 5. **Объяснение для чайника**

- **Конструктор `Flight`** — это как шаблон для создания объекта рейса. Когда ты создаёшь объект (например, `flight1`), конструктор берет параметры (номер рейса и статус) и сохраняет их в свойствах объекта с помощью `this`.
  
  `this.number = flightNumber` означает: «В объекте, который сейчас создаётся, создай свойство `number` и присвой ему значение переменной `flightNumber`».

- **Создание объекта `flight1`** через `new Flight(...)` означает: «Создай новый объект рейса, используя указанный номер рейса и статус».

- **`flight1.number`** и **`flight1.status`** — это свойства объекта `flight1`, к которым мы можем обращаться и выводить их значения.

Теперь программа будет выводить корректное сообщение о статусе рейса!
</spoiler>


### [Назад к оглавлению](#back)


<a id="init_obj"></a>
## Инициализация объекта

Используйте синтаксис **объектного литерала** или **инициализатора** для создания отдельных объектов.
```js
var John = {name: "John", age: 25};
var James = {name: "James", age: 21};
```

Объекты состоят из свойств, которые используются для описания объекта. Значения свойств объекта могут содержать как примитивные типы данных, так и другие объекты.
```js
simba = {
    category: "lion", 
    gender: "male"
}
```

### Использование инициализаторов объектов

Пробелы и переносы строк не важны. Определение объекта может занимать несколько строк.

 Независимо от того, как создан объект, синтаксис для доступа к свойствам и методам не меняется.
```js
var John = {
    name: "John",
    age: 25
};
var James = {
    name: "James",
    age: 21
};

document.write(John.age);
//альтернатива: document.write(John['age']);
```

Код выше отобразит 25. Не заывайте об альтернативном способе доступа к свойству объекта: `document.write(John['age']);`.

Например следующее выражение отобразит свойство `category` объекта `simba` на экране:
```js
document.write(simba.category);
```

### [Назад к оглавлению](#back)


<a id="add_methods"></a>
## Добавление методов

### Методы - это функции, которые хранятся в свойствах объекта. 

Используйте следующий синтаксис для создания метода объекта:
```js
methodName = function() { code lines }
```

Доступ к методу объекта осуществляется с использованием следующего синтаксиса:
```js
objectName.methodName()
```

**Метод** - это функция, принадлежащая объекту. Она может быть вызвана с использованием ключевого слова **this**. 

Ключевое слово **this** используется как **ссылка на текущий объект**, что означает, что вы можете получить доступ к свойствам и методам объекта, используя его.

Определение методов производится внутри функции-конструктора.
```sql
function person(name, age) {
    this.name = name;  
    this.age = age;
    this.changeName = function (name) {
        this.name = name;
    }
}

var p = new person("David", 21);
p.changeName("John");

document.write(p.name);
```

В приведенном выше примере мы определили метод с именем `changeName` для нашего `person`, который является функцией, принимающей параметр `name` и присваивающей его свойству `name` объекта.

`this.name` относится к свойству `name` объекта.

>> Метод `changeName` изменяет свойство `name` объекта на его аргумент.


### [Назад к оглавлению](#back)


<a id="pract_2"></a>
## Расчет скидки (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Добавление методов
  

Менеджеру магазина нужна программа для установки скидок на товары.  Программа должна принимать ID продукта, цену и скидку в качестве ввода и выводить цену со скидкой. Однако метод `changePrice`, который должен рассчитывать скидку, неполный. Исправьте это!
```js
Пример ввода
LD1493
1700
15

Пример вывода
LD1493 цена: 1700
LD1493 новая цена: 1445
```
> Подсказка: первый ввод - это ID продукта, второй - цена до скидки, а третий - процент скидки.
>
>Так что после применения скидки новая цена будет 1700-(0.15*1700) = 1445.
```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(),10);
    var discount = parseInt(readLine(),10);
    
    var prod1= new Product(prodID, price);
    console.log(prod1.prodID + " цена: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " новая цена: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        //your code goes here
        
    }
}
```

<a id="pract_2_gpt"></a>
### Решение от GPT-4o
Давай разберем этот пример шаг за шагом, чтобы всё стало максимально понятно. В этой задаче мы должны создать класс продукта, и добавить в него метод для расчета новой цены с учётом скидки.

### Разбор задачи:

1. **Входные данные**:
    - **ID продукта** (`prodID`): Например, "LD1493".
    - **Цена продукта** (`price`): Например, 1700.
    - **Скидка** (`discount`): Например, 15 (процентов).

2. **Вывод**:
    - Сначала нужно вывести цену до скидки.
    - Затем нужно рассчитать цену после применения скидки и вывести новую цену.

### Код:

1. Функция `main`:
    - **`prodID = readLine();`** — получаем ID продукта.
    - **`price = parseInt(readLine(), 10);`** — получаем цену продукта и преобразуем её в целое число с помощью `parseInt()`.
    - **`discount = parseInt(readLine(), 10);`** — получаем размер скидки (в процентах) и тоже преобразуем его в число.

2. **Создание объекта**:
    - **`var prod1 = new Product(prodID, price);`** — создаём объект класса `Product` с параметрами `prodID` и `price`.

3. **Вывод первоначальной цены**:
    - **`console.log(prod1.prodID + " price: " + prod1.price);`** — выводим ID продукта и его первоначальную цену.

4. **Применение скидки**:
    - **`prod1.changePrice(discount);`** — вызываем метод `changePrice`, который должен изменить цену продукта с учётом скидки.
    - **`console.log(prod1.prodID + " new price: " + prod1.price);`** — выводим ID продукта и новую цену после применения скидки.

### Конструктор `Product`:

```js
function Product(prodID, price) {
    this.prodID = prodID; // Идентификатор продукта
    this.price = price;   // Цена продукта
}
```

Этот конструктор принимает два параметра (ID продукта и цену) и присваивает их свойствам создаваемого объекта (`this.prodID` и `this.price`).

### Метод `changePrice`:

Здесь мы добавляем логику для расчета новой цены:

```js
this.changePrice = function(discount) {
    // Рассчитываем новую цену с учётом скидки
    this.price = this.price - (this.price * discount / 100);
}
```

#### Как работает:
- Мы берём текущую цену продукта: `this.price`.
- Вычисляем скидку: `this.price * discount / 100`. Это процент скидки от цены.
- Вычитаем эту скидку из цены: `this.price = this.price - скидка`.

Например, если:
- Цена товара = 1700.
- Скидка = 15%.

То:
- Скидка = 1700 * 15 / 100 = 255.
- Новая цена = 1700 - 255 = 1445.

### Окончательный код:

```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(), 10);
    var discount = parseInt(readLine(), 10);
    
    var prod1 = new Product(prodID, price);
    console.log(prod1.prodID + " price: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " new price: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        this.price = this.price - (this.price * discount / 100);
    }
}
```

### Пояснение:
1. Мы создали объект `Product` с ID продукта и начальной ценой.
2. Метод `changePrice` применяет скидку, рассчитывая новую цену.
3. Мы выводим старую и новую цену продукта после изменения.

Этот код делает именно то, что требуется: получает ID, цену, скидку, выводит цену до и после применения скидки. Надеюсь, это помогло тебе лучше понять, как всё работает!

### [Назад к оглавлению](#back)


<a id="add_methods_1"></a>
## Продолжение главы "добавление методов"

### Методы

Еще раз повторим:

Ключевое слово **this** в методе означает - **текущий объект**

Вы также можете определить функцию вне конструктора функции и связать ее с объектом.
```js
function person(name, age) {
  this.name= name;  
  this.age = age;
  this.yearOfBirth = bornYear;
}
function bornYear() {
  return 2024 - this.age;
}
```

Как вы можете видеть, мы назначили свойству объекта `yearOfBirth` функцию `bornYear`.

Ключевое слово `this` используется для доступа к свойству `age` объекта, который будет вызывать метод. 

Обратите внимание, что не обязательно писать скобки функции при ее присваивании объекту.

Следующий код связывает функцию конструктора `testData` с методом под названием `mymethod`:
```js
function testData (first, second) {
  this.first = first;
  this.second = second;
  this.checkData = mymethod;
}
```

Обычный вызов метода (код отобразит 1982):
```js
function person(name, age) {
    this.name= name;
    this.age = age;
    this.yearOfBirth = bornYear;
}
function bornYear() {
    return 2024 - this.age;
}

var p = new person("A", 42);

document.write(p.yearOfBirth());
```

Чтобы использовать свойства объекта в функции, используйте ключевое слово **"this"**.

<a id="gpt_comment_1"></a>
### Коментарий GPT-4o

В этом примере происходит путаница между тем, как назначаются методы объектам в JavaScript. Давай разберём по шагам, что тут происходит и как это исправить.

### Разбор кода:

1. **Конструктор `person`**:
    ```js
    function person(name, age) {
        this.name = name; // Присваиваем свойству `name` значение параметра `name`
        this.age = age;   // Присваиваем свойству `age` значение параметра `age`
        this.yearOfBirth = bornYear; // Присваиваем свойству `yearOfBirth` ссылку на функцию bornYear
    }
    ```

   Здесь создаётся конструктор для объекта `person`, где:
   - `this.name` — это имя объекта.
   - `this.age` — возраст объекта.
   - **Важный момент**: `this.yearOfBirth = bornYear;` — здесь мы присваиваем свойству объекта ссылку на функцию `bornYear`.

2. **Функция `bornYear`**:
    ```js
    function bornYear() {
        return 2016 - this.age;
    }
    ```

   Это обычная функция, которая вычисляет год рождения, основываясь на возрасте. Однако есть проблема: в этой функции используется `this.age`, но если вызвать её без привязки к объекту, `this` не будет ссылаться на текущий объект.

3. **Создание объекта**:
    ```js
    var p = new person("A", 22);
    ```

    Мы создаём новый объект `p`, где:
    - `p.name = "A"`.
    - `p.age = 22`.
    - `p.yearOfBirth` теперь ссылается на функцию `bornYear`.

4. **Вызов метода**:
    ```js
    document.write(p.yearOfBirth());
    ```

   Здесь мы пытаемся вызвать метод `yearOfBirth` через объект `p`. В теории, он должен вернуть год рождения, но будет ошибка, потому что в функции `bornYear` `this` указывает не на объект `p`, а на глобальный объект, где свойства `age` нет.

### Что значит **вызовите метод по свойству, а не по имени функции**?

Это значит, что вместо вызова функции напрямую (например, `bornYear()`), нужно использовать свойство объекта. В данном случае, ты правильно вызываешь метод через свойство объекта: `p.yearOfBirth()`.

Но, чтобы это заработало, нужно правильно привязать `this` к текущему объекту. Для этого нужно либо переписать функцию как метод объекта, либо воспользоваться стрелочной функцией.

### Исправление:

Чтобы всё заработало правильно, нужно убедиться, что `this` в функции `bornYear` ссылается на объект. Есть несколько способов это сделать.

#### Способ 1: Определить функцию `bornYear` как метод объекта

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = function() {
        return 2016 - this.age; // Здесь `this` указывает на объект `p`
    };
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Теперь метод `yearOfBirth` является частью объекта, и `this` будет ссылаться на объект `p`, поэтому всё сработает корректно.

#### Способ 2: Использовать стрелочную функцию

Стрелочные функции автоматически привязывают контекст `this` к текущему объекту.

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = () => 2016 - this.age; // Стрелочная функция
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Стрелочная функция захватывает контекст `this` объекта `p`, поэтому всё работает правильно.

### Вывод:

- **Вызов по свойству** означает, что ты должен использовать `p.yearOfBirth()` вместо прямого вызова `bornYear()`, чтобы метод работал как часть объекта.
- Чтобы код работал корректно, `this` в методе должен ссылаться на текущий объект. Это можно сделать, объявив метод внутри конструктора или используя стрелочную функцию.

Теперь код будет работать как надо!

### [Назад к оглавлению](#back)


<a id="qviz_1"></a>
## Квиз Модуля 1
1. Свойства объекта похожи на переменные; методы похожи на:

- [ ] операторы
- [x] функции
- [ ] свойства
- [ ] условные операторы

2. Каков результат следующего выражения?
```js
var myString = "abcdef";
document.write(myString.length);
```
Ответ: 6

3. Завершите выражение для создания конструктора объекта, учитывая, что **height** и **weight** являются свойствами, а **calculate** является методом для данного объекта:
```js
function mathCalc (height, weight) {
  this.height = [height];
  this.weight = [weight];
  this.sampleCalc = [calculate];
}
// *в квадратных скобках [] указаны места, куда нужно было вставить недостающие части выражения. Скобки не учитываются.
```

### [Назад к оглавлению](#back)


<a id="qviz_1_pract"></a>
## Менеджер контактов
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ 

Вы работаете над приложением Менеджер контактов.

Вы создали конструктор объекта `contact`, который имеет два аргумента, `name` и `number`.

Вам нужно добавить метод `print()` к объекту, который будет выводить данные контакта в консоль в следующем формате: `name: number`

Данный код объявляет два объекта и вызывает их методы `print()`. Завершите код, определив метод `print()` для объектов.

> Обратите внимание на пробел после двоеточия при выводе контактных данных.
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);
a.print();
b.print();
```

Решение способом **определения функции как метод объекта** (пример решения способом стрелочной функции [был описан выше](#gpt_comment_1)):
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
    // Определить функцию print как метод объекта
    this.print = function() {
        return name + ": " + number;
    }
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);

// Вывести метод print объекта contact в консоль
console.log(a.print());
console.log(b.print());
```

### [Назад к оглавлению](#back)


<a id="core_obj"></a>
# Core Objects

<a id="arrays"></a>
## Массивы

### Массивы в JavaScript
Массивы хранят несколько значений в одной переменной. 

Чтобы сохранить названия трех курсов, вам потребуются три переменные.
```js
var course1 ="HTML";
var course2 ="CSS";
var course3 ="JS";
```

Но что, если у вас было 500 курсов? Решение - **array (массив)**.
```js
var courses = new Array("HTML", "CSS", "JS");
```

Этот синтаксис объявляет массив с именем **courses**, который хранит три значения или элемента.

Два ключевых слова для создания массива:
- **new**
- **Array**

### Обращение к элементам массива
Вы обращаетесь к элементу массива, указывая **номер индекса** в **квадратных скобках**. 

Следующе утверждение обращается к значению первого элемента в `courses` и изменяет значение второго элемента.
```js
var courses = new Array("HTML", "CSS", "JS");
var course = courses[0]; // Обращение к HTML
courses[1] = "C++"; // Изменение второго элемента
```

- **[0]** - первый элемент в массиве. 
- **[1]** - второй элемент. 

> Индексы массива начинаются с ноля - `0`.

Результатом выполнения следующего кода - станет `6`:
```sql
var arr = new Array(3, 6, 8);
document.write(arr[1]);
```

### Доступ к массиву
Попытка доступа к индексу за пределами массива возвращает значение `undefined`, что буквально означает - неопределено. Таким выводом будет итог работы следующего кода:
```js
var courses = new Array("HTML", "CSS", "JS"); 
document.write(courses[10]);
```

Наш массив `courses` имеет всего три элемента, поэтому десятый индекс, который является 11-м элементом, не существует (не определен).

### [Назад к оглавлению](#back)


<a id="pract_3"></a>
## Пушистые блинчики (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Массивы 
Представленный вам массив представляет собой меню завтраков, доступных в отеле.

Шеф-повар решил заменить один из вариантов на "Fluffy Pancakes" (Пушистые блинчики).

Напишите программу, чтобы взять индекс как ввод, заменить элемент с этим индексом на "Fluffy Pancakes" и вывести новое меню в консоль в виде массива.
```js
Пример ввода:
2

Пример вывода:
[
  'Cinnamon Doughnuts',
  'Waffles',
  'Fluffy Pancakes',
  'Chorizo Burrito',
  'French Toast'
]
```
Элемент с индексом `2` был заменен в выходном массиве.

Помните, что первый элемент массива имеет индекс `0`.
```js
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    // замените соответствующий элемент на 'Fluffy Pancakes'.
    
    // вывести menu в консоль
    
}
```

Решение:
```sql
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    //замените соответствующий элемент на "Fluffy Pancakes".
    breakfasts[index] = "Fluffy Pancakes";
    //вывести меню на консоль
    console.log(breakfasts);
}
```

### [Назад к оглавлению](#back)


<a id="another_make_array"></a>
## Другие способы создания массивов
### Создание массивов
Вы также можете объявить массив, указать количество элементов, которые он будет хранить, и добавить элементы позже.

Следующий код выведет `"JS"`:
```js
var courses = new Array(3);
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";

document.write(courses[2]);
```

Массив - это особый тип объекта.
- **Массив** использует **числа** для доступа к своим элементам, а 
- **Объект** использует **имена** для доступа к своим членам.

### Создание массивов
Массивы в JavaScript динамические, поэтому вы можете объявить массив и не передавать никаких аргументов с конструктором `Array()`. Затем вы можете динамически добавлять элементы:
```js
var courses = new Array();
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";
courses[3] = "C++";

document.write(courses[2]);
```

Вы можете добавить столько элементов, сколько вам нужно.

### Литерал массива
Для большей простоты, удобочитаемости и скорости выполнения, вы также можете объявлять массивы, используя синтаксис **литерала массива**.
```js
var courses = ["HTML", "CSS", "JS"]; 

document.write(courses[2]);
```
Такой синтаксис приводит к созданию такого же массива, как и тот, который создается с использованием нового синтаксиса `Array()`. Код выдаст результат - "JS".

Вы можете получить доступ и изменить элементы массива, используя номер индекса, как вы делали раньше.

Синтаксис **литерала массива** является **рекомендуемым** способом объявления массивов.

Вводя `var example = new Array();`, мы создаем пустой массив, который можно заполнить **в любое время позже**.

### [Назад к оглавлению](#back)


<a id="props_methods_array"></a>
## Свойства и методы массива

### Свойство length
У массивов JavaScript есть полезные встроенные свойства и методы.

Свойство `length` массива возвращает количество его элементов. Следующий код вернет число 9:
```js
var courses = ["HTML", "CSS", "JS"];
document.write(courses.length);
```

Свойство `length` всегда на одну единицу больше, чем самый высокий индекс массива.

Если массив пуст, свойство `length` возвращает ноль - `0`.

Массив имеет свойство `length` - потому что является объектом.

### Объединение массивов
Метод `concat()` в JavaScript позволяет вам объединять массивы и создавать совершенно новый массив. 
```js
var c1 = ["HTML", "CSS"];
var c2 = ["JS", "C++"];
var courses = c1.concat(c2);

document.write(courses[2]);
```

Массив `courses`, который получается в результате, содержит 4 элемента (HTML, CSS, JS, C++). На выходе получаем неизменый JS. 

Операция `concat` не влияет на массивы `c1` и `c2` - она возвращает результат конкатенации в виде **нового массива**.

Таким образом метод `concat` принимает два массива и объединяет их в один новый массив

### [Назад к оглавлению](#back)


<a id="pract_4"></a>
## Повысь уровень! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Свойства и методы массивов
Игрок получает очки после прохождения каждого уровня игры.

Данная программа принимает число пройденных уровней в качестве входных данных, за которыми следуют набранные за каждый уровень очки, и создает соответствующий массив очков.

Дополните программу, чтобы рассчитать и вывести на консоль сумму всех набранных очков.
```js
Пример ввода
3
1
4
8

Пример вывода
13
```

Объяснение

Первый ввод представляет собой число пройденных уровней, -- в этом случае, 3 (размер создаваемого массива). Следующие 3 ввода -- это очки, начисленные игроку за прохождение каждого уровня. Игрок набрал 1+4+8 очков за 3 пройденных уровня, что затем выводится.

Обратите внимание, что первое введенное число может быть использовано в качестве длины массива.
```js
function main() {
    // Получение числа пройденных уровней
    var levels = parseInt(readLine(),10);
    var points = new Array();
    
    var count = 0;
    while(count<levels){
        var elem = parseInt(readLine(),10);
        points[count] = elem;
        count++;
    }
    
    var sum = 0;
    //вычислить сумму баллов
     
    
    //output
    console.log(sum);
}
```

### [Назад к оглавлению](#back)


<a id="pract_4_gpt"></a>
## Решение от GPT-4o

Решение этой задачи заключается в том, чтобы просуммировать очки, введенные пользователем, и вывести итоговое значение. Давай разберем пошагово, что нужно сделать в этой программе.

### Задача:
1. Пользователь вводит количество уровней.
2. Затем вводит очки за каждый уровень.
3. Нужно создать массив, в который будут записаны эти очки.
4. После этого нужно просуммировать все очки и вывести результат.

### Разбор программы:

```js
function main() {
    // Получаем количество уровней (размер массива)
    var levels = parseInt(readLine(), 10);
    
    // Создаем пустой массив для очков
    var points = new Array();
    
    var count = 0;
    
    // Читаем и записываем очки в массив
    while(count < levels) {
        var elem = parseInt(readLine(), 10);
        points[count] = elem;  // Записываем очки в массив
        count++;
    }
    
    // Теперь нужно посчитать сумму всех очков
    var sum = 0;
    for (var i = 0; i < points.length; i++) {
        sum += points[i];  // Добавляем каждое значение из массива к сумме
    }
    
    // Выводим итоговую сумму
    console.log(sum);
}
```

### Пояснение решения:
1. **Получение количества уровней**:  
   Мы начинаем с того, что принимаем первое число, которое указывает количество уровней.  
   `var levels = parseInt(readLine(), 10);` — эта строка превращает ввод пользователя в целое число (количество уровней).
   
2. **Создание массива для очков**:  
   `var points = new Array();` — создаём пустой массив, в который будем добавлять очки за каждый уровень.

3. **Чтение очков и их добавление в массив**:  
   Мы используем цикл `while`, чтобы прочитать очки за каждый уровень:
   ```js
   while(count < levels) {
       var elem = parseInt(readLine(), 10);
       points[count] = elem;  // Записываем очки в массив
       count++;
   }
   ```
   В этом блоке происходит следующее:
   - Вводим очередное число (очки за уровень).
   - Записываем это число в массив `points` на позицию `count`.
   - Увеличиваем счетчик `count`, чтобы перейти к следующему элементу массива.

4. **Вычисление суммы очков**:  
   После того как все очки введены, мы должны их просуммировать. Для этого используем цикл `for`:
   ```js
   for (var i = 0; i < points.length; i++) {
       sum += points[i];  // Добавляем каждое значение из массива к сумме
   }
   ```
   Этот цикл проходит по всем элементам массива `points` и добавляет их к переменной `sum`, которая изначально равна 0.

5. **Вывод результата**:  
   После того как сумма всех очков посчитана, выводим результат:
   ```js
   console.log(sum);
   ```

### Пример работы программы:
Если ввести следующие данные:
```
3
1
4
8
```

Программа:
- Считает количество уровней (`3`).
- Считает очки за каждый уровень (`1`, `4`, `8`).
- Вычисляет сумму: `1 + 4 + 8 = 13`.
- Выведет `13`.

### Заключение:
Мы использовали цикл для чтения очков и суммирования значений. Важно правильно работать с массивами и циклами, чтобы корректно обработать ввод и посчитать результат.

### Про выражение while(count < levels)

Выражение `while(count < levels)` используется для того, чтобы цикл выполнялся **до тех пор**, пока значение переменной `count` меньше, чем количество уровней `levels`.

### Пояснение:
- **`count`** — это счётчик, который отслеживает количество введённых очков за уровни.
- **`levels`** — это количество уровней, которое ввёл пользователь, и, соответственно, это количество очков, которое нужно ввести.

Цикл `while` работает по следующему принципу:
- Выполняется, пока условие в скобках `count < levels` возвращает `true`.
- Как только счётчик `count` достигает значения `levels` (то есть мы ввели нужное количество очков), условие становится `false`, и цикл завершается.

### Почему используется `while(count < levels)`:
1. **Количество итераций**: Это условие гарантирует, что цикл выполнится **ровно столько раз**, сколько уровней (и, соответственно, очков) нужно обработать.
2. **Чтение данных**: После каждой итерации счётчик `count` увеличивается (`count++`), что означает, что вводится одно новое очко. Когда введено ровно столько очков, сколько уровней, цикл завершится.
3. **Гибкость**: Если пользователь введёт любое другое количество уровней, цикл корректно адаптируется к этому числу и будет работать для любого количества очков.

### Пример:
- Допустим, пользователь ввёл `3` как количество уровней.
- Тогда цикл начнётся с `count = 0` и будет продолжаться до тех пор, пока `count < 3`. То есть он выполнится для `count = 0`, `count = 1` и `count = 2`.
- Как только `count` станет равен `3`, условие перестанет быть истинным, и цикл завершится.

Если бы вместо `while(count < levels)` мы использовали другое условие (например, `while(true)`), цикл мог бы стать бесконечным или некорректно завершаться.

### [Назад к оглавлению](#back)


<a id="asoc_arriv"></a>
## Ассоциативные массивы

Хотя многие языки программирования поддерживают массивы с именованными индексами (текст вместо чисел), называемые **ассоциативными массивами** - JavaScript их **не поддерживает**.

Однако вы все еще можете использовать синтаксис именованных массивов, который создаст объект.

Например:
```js
var person = []; //empty array
person["name"] = "John";
person["age"] = 46;
document.write(person["age"]);
```

Теперь `person` рассматривается как объект, а не как массив. 
Именованные индексы `name` и `age` становятся свойствами объекта `person`.

Поскольку массив `person` рассматривается как объект, стандартные методы и свойства массива дадут неправильные результаты. Например, `person.length` вернет ноль - `0`.

В **ассоциативных массивах**, индексные номера заменяются на **строки**.

Помните, что JavaScript **не поддерживает** массивы с именованными индексами.
- В JavaScript массивы всегда используют номерные индексы.
- Лучше использовать **объект**, когда вы хотите, чтобы индекс был **строкой** (текст).
- Используйте **массив**, когда вы хотите, чтобы индекс был **числом**.
- Если вы используете именованный индекс, JavaScript переопределит массив в стандартный объект.

Чтобы использовать ассоциативные массивы, "ассоциированное" имя помещается **вквадратные скобки** `[]`.

### [Назад к оглавлению](#back)


<a id="math_obj"></a>
## Математический объект

Объект **Math** позволяет вам выполнять математические задачи и включает в себя несколько свойств.

|Property |Description |Перевод описания |
|---------|------------|--|
|**E** |Euler's constant |Постоянная Эйлера |
|**LN2** |Natural log of the value 2 |Натуральный логарифм значения 2 |
|**LN10** |Natural log of the value 10 |Натуральный логарифм значения 10 |
|**LOG2E** |The base 2 log of Euler's constant (E) |Логарифм константы Эйлера (E) по основанию 2 |
|**LOG10E** |The base 10 log of Euler's constant (E) |Логарифм константы Эйлера (E) по основанию 10 |
|**PI** |Returns the constant Pi |Возвращает число пи (3,14) |

Например результатом отображения в браузере следующего кода будет вывод числа Пи: 3.141592653589793
```js
document.write(Math.PI);
```

**Math** не имеет конструктора. Нет необходимости сначала создавать объект `Math`.

### Методы объекта Math
Объект **Math** содержит ряд методов, которые используются для вычислений:

|Method |Description |Перевод |
|--|--|--|
|**abs(x)** |Returns the absolute value of x  |Возвращает абсолютное значение x  |
|**acos(x)** |Returns the arccosine of x, in radians  |Возвращает арккосинус x, в радианах  |
|**asin(x)**  |Returns the arsine of x, in radians |Возвращает арксинус x, в радианах  |
|**atan(x)** |Returns the arctangent of x as a numeric value between [-PI/2] and [PI/2] radians  |Возвращает арктангенс x в виде числового значения между [-PI/2] и [PI/2] радиан  |
|**atan2(y,x)** |Returns the arctangent of the quotient of its arguments  |Возвращает арктангенс колличества своих аргументов  |
|**ceil(x)**  |Returns x, rounded upwards to the nearest integer  |Возвращает x, округленное в большую сторону до ближайшего целого числа  |
|**cos(x)** |Returns the cosine of x (x is in radians)  |Возвращает косинус x (x в радианах)  |
|**exp(x)** |Returns the value of E*  |Возвращает значение E*  |
|**floor(x)**  |Returns x, rounded downwards to the nearest integer  |Возвращает x, округленное в меньшую сторону до ближайшего целого числа  |
|**log(x)** |Returns the natural logarithm (base E) of x  |Возвращает натуральный логарифм (основание E) от x  |
|**max(x,y,z,...,n)** |Returns the number with the highest value  |Возвращает число с наибольшим значением  |
|**min(x,y,z,...,n)** |Returns the number with the lowest value  |Возвращает число с наименьшим значением  |
|**pow(x,y)** |Returns the value of x to the power of y  |Возвращает значение x в степени y  |
|**random()** |Returns a random number between 0 and 1  |Возвращает случайное число от 0 до 1  |
|**round(x)** |Rounds x to the nearest integer  |Округляет x до ближайшего целого числа  |
|**sin(x)** |Returns the sine of x (x is in radians) |Возвращает синус x (x в радианах)  |
|**sqrt(x)** |Returns the square root of x  |Возвращает квадратный корень из x  |
|**tan(x)** |Returns the tangent of an angle |Возвращает тангенс угла |

Например, следующий код вычислит **квадратный корень** числа:
```js
var number = Math.sqrt(4); 
document.write(number);
```

Чтобы получить случайное число от 1 до 10, используйте `Math.random()`, который дает вам число от 0 до 1. Затем умножьте число на 10, а затем воспользуйтесь функцией `Math.ceil()`: `Math.ceil(Math.random() * 10)`.

### [Назад к оглавлению](#back)


<a id="pract_5"></a>
## Какой век? (Практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Объект Math

Создайте функцию, которая возвращает век в зависимости от года, заданного в качестве параметра.
```js
Пример ввода:
1993

Пример вывода:
20
```

#### Подсказка

Вам нужно разделить 1993 на 100: 1993/100 = 19.93, затем округлить его до ближайшего целого числа, которое в этом случае равно 20.

Используйте `Math.ceil(x)`, который возвращает `x`, округленное вверх до ближайшего целого числа:
```js
function main() {
    var year = parseInt(readLine(), 10);  // Получаем значение года
    
    // Выводим результат, вызывая функцию calcCent с аргументом year
    console.log(calcCent(year));
}

// Дополняем функцию
function calcCent(year) {
    year = year / 100;  // Делим год на 100
    return Math.ceil(year);  // Округляем вверх до целого числа и возвращаем результат
}
```

Пояснение:

1. В функции `main()` вызывается функция `calcCent()` и передаётся переменная `year` как аргумент: `calcCent(year)`.
2. Функция `calcCent()` принимает этот аргумент: `function calcCent(year)`.
3. Внутри функции `calcCent()` вы делите year на 100 и округляете результат вверх с помощью `Math.ceil()`.
4. Округлённое значение возвращается через `return`, чтобы вывести его в `console.log`.

Объект Math
Давайте создадим программу, которая будет просить пользователя ввести число и выводить его квадратный корень.
```js
var n = prompt("Enter a number", "");
var answer = Math.sqrt(n);
alert("The square root of " + n + " is " + answer);
```

Результат:

![pic1](https://lecontent.sololearn.com/material-images/bd4171a04aef463a9d096c398acba66a-2770.png)

Введите число, например 64.
![pic2](https://lecontent.sololearn.com/material-images/420f29528f3b4004a236197bfc56ff56-2771.png)

**Math** - это удобный объект. Вы можете сэкономить много времени, используя Math, вместо написания своих собственных функций каждый раз.

Результатом `Math.sqrt(81);` - будет девять.

### [Назад к оглавлению](#back)


<a id="date_obj"></a>
## Объект Date
### setInterval
Метод **setInterval()** вызывает функцию или вычисляет выражение через указанные интервалы (в миллисекундах). 

Он продолжит вызывать функцию до тех пор, пока не будет вызван **clearInterval()** или окно не будет закрыто.
```js
function myAlert() {
    alert("Hi");
}
setInterval(myAlert, 3000);
```

Это вызовет функцию **myAlert** каждые 3 секунды (1000 мс = 1 секунда).

Напишите имя функции без скобок при передаче его в метод **setInterval**.

Например код чтобы вызвать функцию **calc()** каждые 2 секунды:
```js
setInterval(calc, 2000);
```

### Объект Date
Объект **Date** позволяет нам работать с датами.

Дата состоит из года, месяца, дня, часа, минуты, секунды и миллисекунд.

Используя **new Date()**, создайте новый объект даты с текущей датой и временем.
```js
var d = new Date();
//d сохраняет текущую дату и время
```

Другие способы инициализации дат позволяют создавать новые объекты даты из указанной даты и времени.
```js
new Date(milliseconds)
new Date(dateString)
new Date(year, month, day, hours, minutes, seconds, milliseconds)
```

Даты в JavaScript рассчитываются в миллисекундах с 01 января 1970 года в 00:00:00 по Всемирному времени (UTC). Один день содержит 86,400,000 миллисекунд.

Например:
```js
//Fri Jan 02 1970 00:00:00
var d1 = new Date(86400000);

//Fri Jan 02 2015 10:42:00
var d2 = new Date("January 2, 2015 10:42:00");

//Sat Jun 11 1988 11:42:00
var d3 = new Date(88,5,11,11,42,0,0);
```

JavaScript считает месяцы от 0 до 11. Январь - это **0**, а декабрь - **11**.

Объекты Date являются статическими, а не динамическими. Время на компьютере идет, но объекты даты не меняются, после их создания.

### Методы Date
Когда создается объект `Date`, ряд методов позволяет выполнять с ним операции. 

|Method |Description |Перевод |
|-------|------------|--------|
|getFullYear() |gets the year |получает год |
|getMonth() |gets the month |получает месяц |
|getDate() |gets the day of the month |получает день месяца |
|getDay() |gets the day of the week |получает день недели |
|getHours() |gets the hour |получает час |
|getMinutes() |gets the minutes |получает минуту |
|getSeconds() |gets the seconds |получает секунду |
|getMilliseconds() |get the milliseconds |получает миллисекунду |

Например:
```js
var d = new Date();
var hours = d.getHours();

console.log(hours);
```

Давайте создадим программу, которая выводит текущее время в браузер каждую секунду.
```js
function printTime() {
    var d = new Date();
    var hours = d.getHours();
    var mins = d.getMinutes();
    var secs = d.getSeconds();
    document.body.innerHTML = hours+":"+mins+":"+secs;
}
setInterval(printTime, 1000);
```

Мы объявили функцию `printTime()`, которая получает текущее время из объекта даты и выводит его на экран.

Затем мы вызвали эту функцию каждую секунду, используя метод `setInterval`.

Свойство `innerHTML` устанавливает или возвращает HTML-содержимое элемента.

В нашем случае, мы изменяем HTML-содержимое тела нашего документа. Это перезаписывает содержимое каждую секунду, вместо того чтобы повторно выводить его на экран.

Еще раз пример инициализации объекта даты, представляющего текущую дату и время:
```
var date = new Date();
```

### [Назад к оглавлению](#back)


<a id="pract_6"></a>
### Понедельник до Воскресенья (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

Объект Date 

Программа, которую вы получили, принимает на вход год, месяц и день.

Создайте функцию, которая принимает их в качестве аргументов и возвращает соответствующий день недели.
```js
Пример ввода:
1993
7
12

Пример вывода:
Thursday
```
>Подсказка: Данный код создает объект Date из параметров. Используйте метод `getDay()` объекта date для получения индекса, затем используйте его в данном массиве имен для возвращения названия дня.
```js
function main() {
   var year = parseInt(readLine(), 10);
   var month = parseInt(readLine(), 10);
   var day = parseInt(readLine(), 10);
    
   console.log(getWeekDay(year, month, day)); 
}

function getWeekDay(year, month, day) {
   var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
   var d = new Date(year, month, day);
    //complete the function
    
}
```

<a id="pract_6_gpt"></a>
### Решение от GPT-4o

Вот комментарии к твоему коду:

```js
function main() {
   var year = parseInt(readLine(), 10);  // Чтение года и преобразование его в целое число
   var month = parseInt(readLine(), 10);  // Чтение месяца и преобразование его в целое число (в этом коде месяц начинается с 1)
   var day = parseInt(readLine(), 10);  // Чтение дня и преобразование его в целое число
    
   console.log(getWeekDay(year, month, day));  // Вызов функции getWeekDay с переданными значениями года, месяца и дня
}

function getWeekDay(year, month, day) {
   var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];  // Массив названий дней недели, где 0 = Воскресенье и 6 = Суббота
   
   // Создаём объект Date, передавая год, месяц и день.
   // Обратите внимание, что объект Date в JavaScript автоматически преобразует месяц, начиная с 0, поэтому здесь корректировка не нужна.
   var date = new Date(year, month, day);  
   
   var day = date.getDay();  // Получаем день недели (от 0 до 6) с помощью метода getDay() объекта Date
   return names[day];  // Возвращаем название дня недели, используя индекс массива names
}
```

### Пояснение:
- **Date**: Объект `Date` в JavaScript принимает год, месяц и день, но месяц начинается с 0 (то есть январь — это 0, февраль — 1 и так далее), поэтому переданный месяц уменьшаем на 1.
- **getDay()**: Этот метод возвращает индекс дня недели, начиная с 0 для воскресенья и до 6 для субботы. Этот индекс используется для получения правильного названия дня недели из массива `names`.

### [Назад к оглавлению](#back)


<a id="exam_2"></a>
## Викторина модуля 2

1. Учитывая массив ниже, пожалуйста, завершите выражение, чтобы было выдано предупреждение с "яблоко".
```js
var fruits = new Array("pear", "orange",
"apple", "grapefruit");
alert(fruits[2]);
```
2. Каков результат следующего выражения?
```js
alert(Math.sqrt(36));
```
Ответ: 6

3. Пожалуйста, заполните пропуски, чтобы вывести текущие минуты.
```js
var date = new Date();
alert(date.getMinutes());
```

4. Какой результат выполнения этого кода?
```js
var arr = new Array("a", "b", "c"); 
alert(arr[1]);
```
Ответ: b

5. Перетащите и отпустите из приведенных ниже вариантов, чтобы получить уведомление с значением константы PI.
```js
alert(Math.PI);
```

### [Назад к оглавлению](#back)


<a id="pract_7"></a>
## Менеджер магазина (практическое упражнение)

Вы работаете над программой Менеджер магазина, которая хранит цены в массиве.

Вам нужно добавить функционал увеличения цен на заданную сумму.

Переменная increase берется из пользовательского ввода. Вам нужно увеличить все цены в данном массиве на эту сумму и вывести в консоль получившийся массив.

> Используйте цикл для итерации по массиву и увеличения всех элементов.
```js
function main() {
    var increase = parseInt(readLine(), 10);
    var prices = [98.99, 15.2, 20, 1026];
    //your code goes here
    
}
```

<a id="pract_7_gpt"></a>
### Решение от GPT-4o
Давай разберём решение этой задачи пошагово. Нужно пройти по каждому элементу массива `prices`, увеличить его на значение переменной `increase`, которую мы получаем из пользовательского ввода, и затем вывести обновлённый массив.

### Решение:

1. **Чтение значения для увеличения**:  
   В переменную `increase` сохраняется число, которое ввёл пользователь. Это число будет добавлено ко всем элементам массива `prices`.

2. **Цикл для обхода массива**:  
   Для того чтобы увеличить каждую цену, мы будем использовать цикл `for`. Цикл проходит по каждому элементу массива и добавляет к нему значение `increase`.

3. **Обновление массива**:  
   Внутри цикла каждый элемент массива обновляется — к его текущему значению добавляется введённое пользователем число.

4. **Вывод обновлённого массива**:  
   После того как все цены обновлены, мы выводим весь массив на консоль.

### Код с подробным объяснением:

```js
function main() {
    // Чтение значения, на которое будем увеличивать цены
    var increase = parseInt(readLine(), 10);
    
    // Массив с исходными ценами
    var prices = [98.99, 15.2, 20, 1026];
    
    // Цикл для обхода каждого элемента массива
    for (var i = 0; i < prices.length; i++) {
        prices[i] += increase;  // Увеличиваем текущую цену на значение increase
    }
    
    // Выводим обновлённый массив
    console.log(prices);
}
```

### Пояснение:
1. **`var increase = parseInt(readLine(), 10);`**  
   Эта строка получает число от пользователя и преобразует его в целое число с помощью функции `parseInt()`. Пользователь вводит, на сколько нужно увеличить цены.

2. **`for (var i = 0; i < prices.length; i++) { ... }`**  
   Это стандартный цикл `for`, который проходит по каждому элементу массива `prices`. Внутри цикла:
   - Мы используем индекс `i`, чтобы обратиться к каждому элементу массива.
   - Выражение `prices[i] += increase;` увеличивает значение текущего элемента массива на заданную сумму `increase`.

3. **`console.log(prices);`**  
   После того как цикл завершён и все цены обновлены, мы выводим обновлённый массив с новыми значениями.

### Пример работы программы:

Если пользователь введёт `10` как значение увеличения, то программа обновит массив следующим образом:
Исходные цены:
```
[98.99, 15.2, 20, 1026]
```
После увеличения на `10`:
```
[108.99, 25.2, 30, 1036]
```

Вывод программы будет:
```
[108.99, 25.2, 30, 1036]
```

### Заключение:
Мы использовали цикл `for` для того, чтобы пройти по массиву, и обновили каждый элемент массива на заданное значение.

### [Назад к оглавлению](#back)


<a id="dom_events"></a>
# DOM & События

<a id="what_is_dom"></a>
## Что такое DOM?

Когда вы открываете любую веб-страницу в браузере, HTML страницы загружается и визуально отображается на экране.

Для этого браузер создает **Document Object Model** этой страницы, который представляет собой объектно-ориентированную модель его логической структуры.

**DOM** HTML документа может быть представлен в виде вложенного набора блоков:

![dom](https://lecontent.sololearn.com/material-images/643c1ed149ec4e239be6852f7b00deb5-2773.png)

JavaScript можно использовать для динамического управления DOM страницы с целью добавления, удаления и изменения элементов.

### Дерево DOM
DOM представляет документ в виде структуры дерева.

HTML элементы становятся взаимосвязанными узлами в дереве.

Все эти узлы в дереве имеют какие-то отношения друг с другом. Узлы могут иметь дочерние узлы. Узлы на одном уровне дерева называются братьями и сестрами.

Например, рассмотрите следующую структуру:
![dom2](https://lecontent.sololearn.com/material-images/66db5ddcc4714483bf7b5622fd267c3b-2773.png)

Для приведенного выше примера:

- &lt;html&gt; имеет двух детей (&lt;head&gt;, &lt;body&gt;);
- &lt;head&gt; имеет одного ребенка (&lt;title&gt;) и одного родителя (&lt;html&gt;);
- &lt;title&gt; имеет одного родителя (&lt;head&gt;) и не имеет детей;
- &lt;body&gt; имеет двух детей (&lt;h1&gt; и &lt;a&gt;) и одного родителя (&lt;html&gt;);

Важно понимать взаимосвязи между элементами в HTML-документе, чтобы иметь возможность манипулировать ими с помощью JavaScript.

В следующем HTML, элемент &lt;p&gt; является родительским:
```js
<body>
  <p><h1>Hi</h1></p>
</body>
```

### Объект document
В JavaScript предопределен **объект document**, который можно использовать для доступа ко всем элементам в DOM.

Иными словами, **объект document** является **владельцем** (или **root**) всех объектов на вашей веб-странице.

Так что, если вы хотите получить доступ к объектам на HTML-странице, вы всегда начинаете с доступа к **объекту document**.

Например:
```js
document.body.innerHTML = "Some text";
```

Поскольку `body` является элементом **DOM**, мы можем получить доступ к нему с помощью **объекта document** и изменить содержимое свойства `innerHTML`.

Свойство `innerHTML` можно использовать почти на всех элементах HTML для изменения их содержимого.

- `innerHTML` - это свойство
- Объект `document` - является корнем DOM

### [Назад к оглавлению](#back)


<a id="elements_select"></a>
## Выбор элементов

Все элементы HTML являются объектами. И как мы знаем, каждый объект имеет свойства и методы.

Объект **document** имеет методы, которые позволяют вам выбирать нужный элемент HTML.

Эти три метода наиболее часто используются для выбора элементов HTML:
```js
//finds element by id
document.getElementById(id)

//finds elements by class name
document.getElementsByClassName(name)

//finds elements by tag name
document.getElementsByTagName(name)
```

В приведенном ниже примере метод `getElementById` используется для выбора элемента с `id="demo"` и изменения его содержимого:
```js
var elem = document.getElementById("demo");
elem.innerHTML = "Hello World!";
```

Пример выше предполагает, что HTML содержит элемент `с id="demo"`, например **&lt;div id="demo"&gt;&lt;/div&gt;**.

Далее пример, выбрать элемент с `id="text"` и изменить его содержимое на "Привет".
```js
var ob = document.getElementById("text");
ob.innerHTML = "Привет";
```

Метод **getElementsByClassName()** возвращает коллекцию всех элементов в документе с указанным именем класса.

Например, если на нашей HTML-странице содержится три элемента с `class="demo"`, следующий код вернет все эти элементы в виде массива: 
```js
var arr = document.getElementsByClassName("demo");
//accessing the second element
arr[1].innerHTML = "Hi";
```

Аналогично, метод **getElementsByTagName** возвращает все элементы с указанным именем тега в виде массива.

В следующем примере получаются все элементы параграфа страницы и изменяется их содержимое:
```html
<p>hi</p>
<p>hello</p>
<p>hi</p>
<script>
var arr = document.getElementsByTagName("p");
for (var x = 0; x < arr.length; x++) {
  arr[x].innerHTML = "Hi there";
}
</script>
```

Скрипт приведет к следующему HTML:
```html
<p>Hi there</p>
<p>Hi there</p>
<p>Hi there</p>
```

Мы использовали свойство **length** массива для прохождения через все выбранные элементы в приведенном выше примере.

Пример: выбрать все элементы `div` и вывести содержимое третьего элемента `div`.
```js
var arr = document.getElementsByTagName("div");
alert(arr[2].innerHTML);
```

### Работа с DOM
У каждого элемента в DOM есть набор свойств и методов, которые предоставляют информацию о их взаимосвязях в DOM:

|Свойство/метод |Описание |
|---------------|---------|
|element.childNodes |возвращает массив дочерних узлов элемента. |
|element.firstChild |возвращает первый дочерний узел элемента. |
|element.lastChild |возвращает последний дочерний узел элемента. |
|element.hasChildNodes |возвращает true, если у элемента есть дочерние узлы, в противном случае false. |
|element.nextSibling |возвращает следующий узел на том же уровне дерева. |
|element.previousSibling |возвращает предыдущий узел на том же уровне дерева. |
|element.parentNode |возвращает родительский узел элемента.

Мы можем, например, выбрать все дочерние узлы элемента и изменить их содержимое. В указанном ниже коде текст обоих абзацев изменяется на "новый текст".
```html
<html>
    <body>
         <div id ="demo">
            <p>some text</p>
            <p>some other text</p>
        </div>
    </body>
</html>
```
```js
function setText() {
    var a = document.getElementById("demo");
     var arr = a.childNodes;
     for(var x=0;x<arr.length;x++) {
       arr[x].innerHTML = "новый текст";
     }
}

//вызов функции с setTimeout, чтобы убедиться, что HTML загружен
setTimeout(setText, 500);
```

Узел в DOM - **НЕ может** иметь несколько родительских узлов.

### [Назад к оглавлению](#back)


<a id="change_elements"></a>
## Изменение элементов
### Изменение атрибутов
Как только вы выбрали элемент(ы), с которыми хотите работать, вы можете изменить их атрибуты. 

Как мы видели в предыдущих уроках, мы можем изменить текстовое содержимое элемента с помощью свойства **innerHTML**.

Аналогично, мы можем изменить атрибуты элементов.

Например, мы можем изменить атрибут **src** изображения: 
```js
<img id="myimg" src="orange.png" alt="" />
<script>
var el = document.getElementById("myimg");
el.src = "apple.png";
</script>
```

Замена ссылки:
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		<a href="http://www.example.com">Some link</a>
	</body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var el = document.getElementsByTagName('a');
    el[0].href= 'http://www.sololearn.com';
};
```

Практически все атрибуты элемента можно изменить с использованием JavaScript.

Пример: выбрать все изображения на странице и изменить их атрибут **src**.
```js
var arr = document.
    getElementsByTagName("img");
for(var x=0; x<arr.length; x++) {
  arr[x].src = "demo.jpg";
}
```

### Изменение стиля
Стиль элементов HTML также можно изменять с помощью JavaScript.

Все атрибуты стиля можно получить с помощью объекта **style** элемента. 

Например:
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		<div id="demo" style="width:200px">some text</div>
	</body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var x = document.getElementById("demo");
    x.style.color = 'white';
    x.style.width = '100px';
    x.style.backgroundColor = 'blue'
};
```

Приведенный выше код изменяет **цвета текста**, **заливки** и **ширины** элемента `div`.

Все свойства CSS можно устанавливать и изменять с помощью JavaScript. Просто помните, что вы не можете использовать дефисы (`-`) в названиях свойств: они заменяются версиями **camelCase**, где составные слова начинаются с заглавной буквы.

Например, свойство `background-color` следует обозначать как `backgroundColor`.

Пример: изменить цвет фона всех элементов span на странице.
```js
var s = document.
    getElementsByTagName("span");
for(var x=0; x<s.length;x++) {
  s[x].style.backgroundColor = "#33EA73";
}
```

### [Назад к оглавлению](#back)


<a id="add_del_elements"></a>
## Добавление и удаление элементов
### Создание элементов
Используйте следующие методы для создания новых узлов:
- **element.cloneNode()** клонирует элемент и возвращает получившийся узел.
- **document.createElement(element)** создает новый узел элемента. 
- **document.createTextNode(text)** создает новый текстовый узел.

Например:
```js
var node = document.createTextNode("Some new text");
```

Это создаст новый текстовый узел, но он не появится в документе, пока вы не добавите его к существующему элементу одним из следующих методов:
- **element.appendChild(newNode)** добавляет новый дочерний узел к элементу в качестве последнего дочернего узла.
- **element.insertBefore(node1, node2)** вставляет node1 как дочерний узел перед node2.

Пример:
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Название страницы</title>
	</head>
	<body>
		<div id="demo">некое содержимое</div>
	</body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    //создание нового абзаца
    var p = document.createElement("p");
    var node = document.createTextNode("Какой-то новый текст");
    //добавление текста в абзац
    p.appendChild(node);

    var div = document.getElementById("demo");
    //добавление абзаца в div
    div.appendChild(p);
};
```
Это создает новый абзац и добавляет его к существующему элементу div на странице.

Вывод браузера:
>некое содержимое
>
>Какой-то новый текст

Еще пример, как добавить новый элемент **&lt;li&gt;** в неупорядоченный список с **id="list"**.
```js
var el = document.createElement("li");
var txt = document.createTextNode("B");
el.appendChild(txt);
var ul = document.getElementById("list");
ul.appendChild(el);
```

### Удаление элементов
Чтобы удалить элемент HTML, вы должны выбрать родителя элемента и использовать метод **removeChild(node)**.

Например:
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		<div id="demo">
            <p id="p1">This is a paragraph.</p>
            <p id="p2">This is another paragraph.</p>
        </div>
	</body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var parent = document.getElementById("demo");
    var child = document.getElementById("p1");
    parent.removeChild(child);
};
```

Это удаляет абзац с **id="p1"** со страницы. Ответ браузера:
> This is another paragraph.

Альтернативный способ достижения того же результата - использование свойства **parentNode** для получения родителя элемента, который мы хотим удалить:
```js
var child = document.getElementById("p1");
child.parentNode.removeChild(child);
```
Пример, как можно удалить элемент `node` со страницы (`par` является родительским элементом для `node`).
```js
var par = document.getElementById("par");
var node = document.getElementById("node");
par.removeChild(node);
```

### Замена элементов
Чтобы заменить элемент HTML, используется метод:
```js
element.replaceChild(newNode, oldNode).
```
Например:
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		<div id="demo">
            <p id="p1">Параграф</p>
            <p id="p2">Другой параграф.</p>
        </div>
	</body>
</html>
```
```js
//включение функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var p = document.createElement("p");
    var node = document.createTextNode("Новый параграф");
    p.appendChild(node);

    var parent = document.getElementById("demo");
    var child = document.getElementById("p1");
    parent.replaceChild(p, child);
};
```
Приведенный выше код создает новый элемент абзаца (Новый параграф), который заменяет существующий абзац **p1** (Параграф). Вывод в браузер:
> Новый параграф
>
>Другой параграф.

Еще раз: для замены узлов используется метод **replaceChild**.

### [Назад к оглавлению](#back)


<a id="criate_animation"></a>
## Создание анимаций

Теперь, когда мы знаем, как выбирать и изменять элементы DOM, мы можем создать простую анимацию.

Давайте создадим простую HTML-страницу с элементом **box**, который будет анимирован с помощью JS. 
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		<div id="container">
            <div id="box"> </div>
        </div>
	</body>
</html>
```
```CSS
#container {
    width: 200px;
    height: 200px;
    background: green;
    position: relative;
}
#box {
    width: 50px;
    height: 50px;
    background: red;
    position: absolute;
}
```
Наш элемент `box` находится внутри элемента `container`. Обратите внимание на атрибут `position`, используемый для элементов: для **контейнера** установлено значение `relative`, а для **блока** - значение `absolute`. Это позволит нам создать анимацию относительно контейнера.

![animation](https://lecontent.sololearn.com/material-images/1adf8a760a954b8f85711a3c89d1d756-3032.png)

Мы будем анимировать красный блок, чтобы он переместился к правой стороне контейнера.

Вам нужно быть знакомым с CSS, чтобы лучше понимать предоставленный код.

Чтобы создать анимацию относительно контейнера, атрибут `position` для **контейнера** должен быть установлен на `relative` - относительный.

Чтобы создать анимацию, нам нужно изменять свойства элемента через небольшие промежутки времени. Мы можем достичь этого, используя метод **setInterval()**, который позволяет нам создать таймер и вызывать функцию для повторяющегося изменения свойств через определенные промежутки времени (в миллисекундах). Например:
```js
var t = setInterval(move, 500);
```

Этот код создает таймер, который вызывает функцию `move()` каждые 500 миллисекунд.

Теперь нам нужно определить функцию `move()`, которая изменяет позицию коробки.
```js
// starting position
var pos = 0; 
//our box element
var box = document.getElementById("box");

function move() {
  pos += 1;
  box.style.left = pos+"px"; //px = pixels
}
```
Функция `move()` увеличивает свойство `left` элемента **box** на один каждый раз, когда она вызывается.

У следующего таймера, интервал - 10 секунд:
```js
var t = setInterval(func, 10000);
```

Следующий код определяет таймер, который вызывает функцию `move()` каждые 10 миллисекунд:
```js
var t = setInterval(move, 10)
```

Однако, это заставляет наш квадрат двигаться вправо бесконечно. Чтобы остановить анимацию, когда квадрат достигает конца контейнера, мы добавляем простую проверку в функцию `move()` и используем метод **clearInterval()** для остановки таймера.
```js
function move() {
  if(pos >= 150) {
    clearInterval(t);
  }
  else {
    pos += 1;
    box.style.left = pos+"px";
  }
}
```
Когда атрибут `left` у блока достигает значения `150`, блок достигает конца контейнера, исходя из ширины контейнера 200 и ширины блока 50.

Итоговый код:
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var pos = 0; 
    //элемент нашей коробки
    var box = document.getElementById('box');
    var t = setInterval(move, 10);
  
    function move() {
        if(pos >= 150) {
            clearInterval(t);
        }
        else {
            pos += 1;
            box.style.left = pos+'px';
        }
    }
};
```

Поздравляем, при запуске кода красный квадрат будет двигаться. Вы создали свою первую анимацию!

### [Назад к оглавлению](#back)


<a id="event_handling"></a>
## Обработка событий
### События
Вы можете написать код на JavaScript, который выполняется, когда происходит событие, например, когда пользователь нажимает на элемент HTML, двигает мышь или отправляет форму.

Когда событие происходит на целевом элементе, выполняется функция обработчика. 

Обычные события HTML включают в себя: 
|Событие |Описание
|------|----------
|onclick |происходит, когда пользователь нажимает на элемент
|onload |происходит, когда объект загрузился
|onunload |происходит после выгрузки страницы (для &lt;body&gt;)
|onchange |происходит, когда содержимое элемента формы, выбор или отмеченное состояние изменились (для &lt;input&gt;, &lt;keygen&gt;,&lt;select&gt; и &lt;textareas&gt;)
|onmouseover |происходит, когда указатель перемещается на элемент или при наведении курсора на один из его дочерних элементов
|onmouseout |происходит, когда пользователь перемещает указатель мыши за пределы элемента onmouse или за пределы одного из его дочерних элементов 
|onmousedown |происходит, когда пользователь нажимает кнопку мыши на элементе
|onmouseup |происходит, когда пользователь отпускает кнопку мыши над элементом
|onblur |происходит, когда элемент теряет фокус
|onfocus |происходит, когда элемент получает фокус

Соответствующие события могут быть добавлены к элементам HTML в виде атрибутов. Например: 
```html
<p onclick="someFunc()">некоторый текст</p>
```

Тип функции, который выполняется, когда происходит событие, называется **обработчиком событий**.

### Обработка событий 
Давайте отобразим всплывающее окно с предупреждением **Hi there**, когда пользователь нажимает на кнопку **"Click Me"**: 
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		<button onclick="show();">Click Me</button>
	</body>
</html>
```
```js
function show() {
    alert("Hi there");
}
```

Вы можете привязать события почти ко всем HTML элементам.

Еще раз, например, чтобы вызвать `func()` при нажатии на кнопку "Нажмите здесь":
```js
<button onclick="func()">
  Нажмите здесь
</button>
```

### События 
События **onload** и **onunload** срабатывают, когда пользователь заходит на страницу или покидает ее. Они могут быть полезны при выполнении действий после загрузки страницы. 
```js
<body onload="doSomething()">
```

Аналогично, событие **window.onload** можно использовать для выполнения кода после загрузки всей страницы.
```js
window.onload= function() {
   //some code
}
```
Событие **onchange** в основном используется в текстовых полях. Обработчик событий вызывается, когда текст внутри текстового поля изменяется и фокус теряется с элемента. 

В следующем примере после переключения из поля ввода (потери фокуса), введеный текст преобазуется в заглавный:
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		<input type="text" id="name" onchange="change()">
	</body>
</html>
```
```js
function change() {
    var x = document.getElementById('name');
    x.value = x.value.toUpperCase();
}
```

Важно понимать события, потому что они являются неотъемлемой частью динамических веб-страниц.

Еще пример - вызвать функцию `clear()` после загрузки тела:
```js
<body=onload="clear()">
</body>
```

### Обработчики событий 
Метод **addEventListener()** присоединяет обработчик событий к элементу без перезаписи существующих обработчиков событий. Вы можете добавить много обработчиков событий к одному элементу.

Вы также можете добавить много обработчиков событий одного типа к одному элементу, т.е., два события "click".
```js
element.addEventListener(event, function, useCapture);
```
- Первый параметр - это **тип** события (например, "click" или "mousedown").
- Второй параметр - это **функция**, которую мы хотим вызвать при возникновении события.
- Третий параметр - это булево значение, указывающее, следует ли использовать **всплытие** событий или **захват** событий. Этот параметр необязателен и будет описан в следующем уроке.
> Обратите внимание, что вы не используете префикс "on" для этого события; используйте "click" вместо "onclick".
```js
element.addEventListener("click", myFunction);
element.addEventListener("mouseover", myFunction);

function myFunction() {
  alert("Hello World!");
}
```
Это добавляет два слушателя событий к элементу. Мы можем удалить одного из слушателей:
```js
element.removeEventListener("mouseover", myFunction);
```

Давайте создадим обработчик событий, который удаляет себя после выполнения:
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Page Title</title>
	</head>
	<body>
		  <button id="demo">Start</button>
	</body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var btn = document.getElementById("demo");
    btn.addEventListener("click", myFunction);

    function myFunction() {
        alert(Math.random());
        btn.removeEventListener("click", myFunction);
    }
};
```

После нажатия на кнопку отображается предупреждение с случайным числом и слушатель событий удаляется.

> Версии Internet Explorer 8 и ниже не поддерживают методы **addEventListener()** и **removeEventListener()**. Однако, вы можете использовать метод **document.attachEvent()** для привязки обработчиков событий в Internet Explorer.

### [Назад к оглавлению](#back)


<a id="event_spreading"></a>
## Распространение событий
# JavaScript – Средний уровень

Вы уже знакомы с основами JavaScript и хотели бы пополнить свои знания? Тогда вы в правильном месте. На этом курсе вы научитесь создавать более сложные и гибкие программы, а также ещё более интерактивные сайты. Этот курс является продолжением нашего курса Введение в Javascript. Мы рекомендуем вам ознакомиться содержанием курса "Введение в Javascript", прежде чем начать этот курс.

<a id="back"></a>
### Оглавление:
### [Объекты](#obj)
#### [Введение в объекты](#intro_obj)
#### [Создание cобственных Объектов](#oun_obj)
#### [Приземлились! (практика)](#pract_1)
##### [Решение от GPT-4o](#pract_1_gpt)
#### [Инициализация объекта](#init_obj)
#### [Добавление методов](#add_methods)
#### [Расчет скидки (практика)](#pract_2)
##### [Решение от GPT-4o](#pract_2_gpt)
#### [Продолжение главы "добавление методов"](#add_methods_1)
##### [Коментарий GPT-4o](#gpt_comment_1)
#### [Квиз Модуля 1](#qviz_1)
#### [Менеджер контактов (практика)](#qviz_1_pract)
### [Core Objects](#core_obj)
#### [Массивы](#arrays)
#### [Пушистые блинчики (практика)](#pract_3)
#### [Другие способы создания массивов](#another_make_array)
#### [Свойства и методы массива](#props_methods_array)
#### [Повысь уровень! (практика)](#pract_4)
##### [Решение от GPT-4o](#pract_4_gpt)
#### [Ассоциативные массивы](#asoc_arriv)
#### [Математический объект](#math_obj)
#### [Какой век? (Практика)](#pract_5)
#### [Объект Date](#date_obj)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)
#### [ipsum](#lorem)





<a id="obj"></a>
# Объекты

### [Назад к оглавлению](#back)


<a id="intro_obj"></a>
## Введение в объекты

### Объекты JavaScript
Переменные JavaScript являются контейнерами для значений данных. 

**Объекты** также являются переменными, но они могут содержать много значений.

Считайте объект списком значений, которые записаны как пары `имя:значение`, где имена и значения разделены двоеточиями.

Пример:
```js
var person = {
 name: "John", age: 31, 
 favColor: "green", height: 183
};
```
Эти значения называются **properties**.

|Property |Property Value |
|--|--|
|**name** |John |
|**age** |31 |
|**favColor** |green |
|**height** |183 |

Относительно объекта, `color`, `height`, `weight` и `name` являются примерами **свойства**.

### Свойства объекта
Вы можете получить доступ к свойствам объекта двумя способами.
```js
objectName.propertyName
//or
objectName['propertyName']
```
Этот пример демонстрирует, как получить доступ к `age` нашего объекта person.
```js
var age = person.age /* проверить позже */
```

Встроенное свойство `length` в JavaScript используется для подсчета количества символов в свойстве или строке.
```js
var course = {name: "JS", lessons: 41};
document.write(course.name.length);
```

Объекты являются одной из основных концепций в JavaScript.

### Методы объекта
**Метод объекта** - это свойство, содержащее **определение функции**.

Используйте следующий синтаксис для доступа к методу объекта.
```js
objectName.methodName()
```
Как вы уже знаете, `console.log()` регистрирует текст в консоли. Функция `log()` на самом деле является методом объекта `console`.
```js
console.log("This is some text");
```
**Методы** - это функции, которые хранятся в качестве свойств объекта.

### Объем кубоида (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

#### Введение в объекты
Данный класс представляет собой параллелепипед (например, прямоугольный), который содержит свойства длины, ширины и высоты.

Дополните программу, чтобы рассчитать и вывести в консоль объем данного параллелепипеда.

>> Подсказка: чтобы вычислить объем параллелепипеда, используйте формулу `length*width*height`.
```js
var cuboid = {
    length: 25,
    width: 50,
    height: 200
};

//your code goes here

console.log(cuboid.length * cuboid.width * cuboid.height)
```

Доступ к свойству `color` объекта `hair` используя синтаксис с точкой:
```js
hair.color
```

### [Назад к оглавлению](#back)


<a id="oun_obj"></a>
## Создание cобственных Объектов

### Конструктор объекта
В предыдущем уроке мы создали объект, используя **синтаксис литерала** (или инициализатора) объекта (объектный литерал).
```js
var person = {
  name: "John", age: 42, favColor: "green"
};
```
>> **Литерал** — это фиксированное значение, которое напрямую указывается в коде программы. Это может быть число, строка, логическое значение или объект, которое не требует вычисления или вызова функций.
>>
>> - Числовой литерал: 42
>> - Строковый литерал: "Hello, World!" или 'Hello, World!'
>> - Булевый литерал: true или false
>> - Объектный литерал: { name: "John", age: 42 }

Это позволяет вам создать только один объект.

Иногда нам нужно установить **"тип объекта"**, который может быть использован для создания нескольких объектов одного типа.

Стандартный способ создания "типа объекта" - использовать функцию **конструктора объекта**.
```js
function person(name, age, color) {
  this.name = name;
  this.age = age;
  this.favColor = color;
}
```
Вышеуказанная функция (`person`) является конструктором объекта, который принимает параметры и присваивает их свойствам объекта.

> Подсказка: ключевое слово **this** относится к **текущему объекту**.
>
> Обратите внимание, что this не является переменной. Это ключевое слово, и его значение не может быть изменено.

Пример создания функции конструктора:
```js
function movie(title, director) {
  this.title = title;
  this.director = director;
}
```

### Создание объектов
Как только у вас есть конструктор объектов, вы можете использовать ключевое слово **new** для создания новых объектов того же типа.
```js
function person(name, age, color) {
    this.name = name;
    this.age = age;
    this.favColor = color;
}

var p1 = new person("John", 42, "green");
var p2 = new person("Amy", 21, "red");

document.write(p1.age); 
```
> `p1` и `p2` теперь являются объектами типа `person`. Их свойства присваиваются соответствующим значениям.

Для создания экземпляра объекта используется ключевое слово - **new**.

### Создание объектов
Рассмотрим следующий пример.
```js
function person (name, age) {
    this.name = name;
    this.age = age;
}
var John = new person("John", 25);
var James = new person("James", 21);

document.write(John.age);
```
Доступ к свойствам объекта осуществляется с использованием **синтаксиса с точкой**, как вы делали это ранее.

|Object's |Property's name |
|--|--|
|**John.** |name |
|**John.** |age |
|**James.** |name |
|**James.** |age |

> Понимание создания объектов является важным.

В качестве примера - два компонента необходимых для использования информации, содержащейся в объекте:
- имя объекта
- имя свойства

### [Назад к оглавлению](#back)


<a id="pract_1"></a>
### Приземлились! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Создание собственных объектов
Боба наняли информационным офицером аэропорта, и ему нужно генерировать статусные сообщения для каждого рейса. Давайте поможем ему!

Дополните данную программу, исправив конструктор, создав объект рейса и присвоив его данной переменной, чтобы правильно выполнить соответствующее сообщение.

ID рейса и статус рейса (приземлился, вовремя, задержка и т.д.) принимаются в качестве входных данных.

```js
Пример ввода:
NGT 929
приземлился

Пример вывода:
Flight NGT 929 has landed
```
> Используйте ключевое слово `new` для создания нового объекта с использованием конструктора.

Оригинальный код:
```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    var flight1;
    //assign a flight object to flight1 variable
    
    //output
    console.log('The flight ' + flight1.number + ' is ' + flight1.status)
    
}

function Flight(flightNumber, status) {
    //fix the constructor
    number = flightNumber;
    status = status;
};
```

<a id="pract_1_gpt"></a>
### Решение от GPT-4o

Окей, давай разберем твою задачу шаг за шагом и объясню, что нужно сделать.

### 1. **Ошибка в конструкторе**
В конструкторе функции `Flight` у тебя объявлены переменные `number` и `status`, но они не привязаны к объекту, который создается с помощью этого конструктора. В JavaScript, чтобы создать свойства объекта внутри конструктора, нужно использовать ключевое слово `this`.

### 2. **Исправляем конструктор**
Когда создается объект с помощью `new Flight(...)`, нам нужно привязать свойства `number` и `status` к самому объекту, используя `this`. Это позволит обращаться к этим свойствам у объекта.

Вот как нужно исправить:

```js
function Flight(flightNumber, status) {
    this.number = flightNumber; // Привязываем параметр к объекту через this
    this.status = status;       // То же самое со статусом
}
```

Теперь свойства `number` и `status` станут частью объекта, который мы создадим через `new Flight()`.

### 3. **Создание объекта**
Теперь, когда конструктор исправлен, можно создать объект рейса и присвоить его переменной `flight1`.

```js
var flight1 = new Flight(flightNumber, flightStatus);
```

Это создаст новый объект `flight1`, где:
- `flight1.number` будет равно значению `flightNumber`
- `flight1.status` будет равно значению `flightStatus`

### 4. **Окончательный код**
Теперь соберем всё вместе:

```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    // Создаем объект рейса, используя конструктор
    var flight1 = new Flight(flightNumber, flightStatus);
    
    // Выводим сообщение с использованием свойств объекта
    console.log('The flight ' + flight1.number + ' is ' + flight1.status);
}

function Flight(flightNumber, status) {
    // Привязываем свойства к объекту через this
    this.number = flightNumber;
    this.status = status;
}
```

### 5. **Объяснение для чайника**

- **Конструктор `Flight`** — это как шаблон для создания объекта рейса. Когда ты создаёшь объект (например, `flight1`), конструктор берет параметры (номер рейса и статус) и сохраняет их в свойствах объекта с помощью `this`.
  
  `this.number = flightNumber` означает: «В объекте, который сейчас создаётся, создай свойство `number` и присвой ему значение переменной `flightNumber`».

- **Создание объекта `flight1`** через `new Flight(...)` означает: «Создай новый объект рейса, используя указанный номер рейса и статус».

- **`flight1.number`** и **`flight1.status`** — это свойства объекта `flight1`, к которым мы можем обращаться и выводить их значения.

Теперь программа будет выводить корректное сообщение о статусе рейса!
</spoiler>


### [Назад к оглавлению](#back)


<a id="init_obj"></a>
## Инициализация объекта

Используйте синтаксис **объектного литерала** или **инициализатора** для создания отдельных объектов.
```js
var John = {name: "John", age: 25};
var James = {name: "James", age: 21};
```

Объекты состоят из свойств, которые используются для описания объекта. Значения свойств объекта могут содержать как примитивные типы данных, так и другие объекты.
```js
simba = {
    category: "lion", 
    gender: "male"
}
```

### Использование инициализаторов объектов

Пробелы и переносы строк не важны. Определение объекта может занимать несколько строк.

 Независимо от того, как создан объект, синтаксис для доступа к свойствам и методам не меняется.
```js
var John = {
    name: "John",
    age: 25
};
var James = {
    name: "James",
    age: 21
};

document.write(John.age);
//альтернатива: document.write(John['age']);
```

Код выше отобразит 25. Не заывайте об альтернативном способе доступа к свойству объекта: `document.write(John['age']);`.

Например следующее выражение отобразит свойство `category` объекта `simba` на экране:
```js
document.write(simba.category);
```

### [Назад к оглавлению](#back)


<a id="add_methods"></a>
## Добавление методов

### Методы - это функции, которые хранятся в свойствах объекта. 

Используйте следующий синтаксис для создания метода объекта:
```js
methodName = function() { code lines }
```

Доступ к методу объекта осуществляется с использованием следующего синтаксиса:
```js
objectName.methodName()
```

**Метод** - это функция, принадлежащая объекту. Она может быть вызвана с использованием ключевого слова **this**. 

Ключевое слово **this** используется как **ссылка на текущий объект**, что означает, что вы можете получить доступ к свойствам и методам объекта, используя его.

Определение методов производится внутри функции-конструктора.
```sql
function person(name, age) {
    this.name = name;  
    this.age = age;
    this.changeName = function (name) {
        this.name = name;
    }
}

var p = new person("David", 21);
p.changeName("John");

document.write(p.name);
```

В приведенном выше примере мы определили метод с именем `changeName` для нашего `person`, который является функцией, принимающей параметр `name` и присваивающей его свойству `name` объекта.

`this.name` относится к свойству `name` объекта.

>> Метод `changeName` изменяет свойство `name` объекта на его аргумент.


### [Назад к оглавлению](#back)


<a id="pract_2"></a>
## Расчет скидки (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Добавление методов
  

Менеджеру магазина нужна программа для установки скидок на товары.  Программа должна принимать ID продукта, цену и скидку в качестве ввода и выводить цену со скидкой. Однако метод `changePrice`, который должен рассчитывать скидку, неполный. Исправьте это!
```js
Пример ввода
LD1493
1700
15

Пример вывода
LD1493 цена: 1700
LD1493 новая цена: 1445
```
> Подсказка: первый ввод - это ID продукта, второй - цена до скидки, а третий - процент скидки.
>
>Так что после применения скидки новая цена будет 1700-(0.15*1700) = 1445.
```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(),10);
    var discount = parseInt(readLine(),10);
    
    var prod1= new Product(prodID, price);
    console.log(prod1.prodID + " цена: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " новая цена: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        //your code goes here
        
    }
}
```

<a id="pract_2_gpt"></a>
### Решение от GPT-4o
Давай разберем этот пример шаг за шагом, чтобы всё стало максимально понятно. В этой задаче мы должны создать класс продукта, и добавить в него метод для расчета новой цены с учётом скидки.

### Разбор задачи:

1. **Входные данные**:
    - **ID продукта** (`prodID`): Например, "LD1493".
    - **Цена продукта** (`price`): Например, 1700.
    - **Скидка** (`discount`): Например, 15 (процентов).

2. **Вывод**:
    - Сначала нужно вывести цену до скидки.
    - Затем нужно рассчитать цену после применения скидки и вывести новую цену.

### Код:

1. Функция `main`:
    - **`prodID = readLine();`** — получаем ID продукта.
    - **`price = parseInt(readLine(), 10);`** — получаем цену продукта и преобразуем её в целое число с помощью `parseInt()`.
    - **`discount = parseInt(readLine(), 10);`** — получаем размер скидки (в процентах) и тоже преобразуем его в число.

2. **Создание объекта**:
    - **`var prod1 = new Product(prodID, price);`** — создаём объект класса `Product` с параметрами `prodID` и `price`.

3. **Вывод первоначальной цены**:
    - **`console.log(prod1.prodID + " price: " + prod1.price);`** — выводим ID продукта и его первоначальную цену.

4. **Применение скидки**:
    - **`prod1.changePrice(discount);`** — вызываем метод `changePrice`, который должен изменить цену продукта с учётом скидки.
    - **`console.log(prod1.prodID + " new price: " + prod1.price);`** — выводим ID продукта и новую цену после применения скидки.

### Конструктор `Product`:

```js
function Product(prodID, price) {
    this.prodID = prodID; // Идентификатор продукта
    this.price = price;   // Цена продукта
}
```

Этот конструктор принимает два параметра (ID продукта и цену) и присваивает их свойствам создаваемого объекта (`this.prodID` и `this.price`).

### Метод `changePrice`:

Здесь мы добавляем логику для расчета новой цены:

```js
this.changePrice = function(discount) {
    // Рассчитываем новую цену с учётом скидки
    this.price = this.price - (this.price * discount / 100);
}
```

#### Как работает:
- Мы берём текущую цену продукта: `this.price`.
- Вычисляем скидку: `this.price * discount / 100`. Это процент скидки от цены.
- Вычитаем эту скидку из цены: `this.price = this.price - скидка`.

Например, если:
- Цена товара = 1700.
- Скидка = 15%.

То:
- Скидка = 1700 * 15 / 100 = 255.
- Новая цена = 1700 - 255 = 1445.

### Окончательный код:

```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(), 10);
    var discount = parseInt(readLine(), 10);
    
    var prod1 = new Product(prodID, price);
    console.log(prod1.prodID + " price: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " new price: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        this.price = this.price - (this.price * discount / 100);
    }
}
```

### Пояснение:
1. Мы создали объект `Product` с ID продукта и начальной ценой.
2. Метод `changePrice` применяет скидку, рассчитывая новую цену.
3. Мы выводим старую и новую цену продукта после изменения.

Этот код делает именно то, что требуется: получает ID, цену, скидку, выводит цену до и после применения скидки. Надеюсь, это помогло тебе лучше понять, как всё работает!

### [Назад к оглавлению](#back)


<a id="add_methods_1"></a>
## Продолжение главы "добавление методов"

### Методы

Еще раз повторим:

Ключевое слово **this** в методе означает - **текущий объект**

Вы также можете определить функцию вне конструктора функции и связать ее с объектом.
```js
function person(name, age) {
  this.name= name;  
  this.age = age;
  this.yearOfBirth = bornYear;
}
function bornYear() {
  return 2024 - this.age;
}
```

Как вы можете видеть, мы назначили свойству объекта `yearOfBirth` функцию `bornYear`.

Ключевое слово `this` используется для доступа к свойству `age` объекта, который будет вызывать метод. 

Обратите внимание, что не обязательно писать скобки функции при ее присваивании объекту.

Следующий код связывает функцию конструктора `testData` с методом под названием `mymethod`:
```js
function testData (first, second) {
  this.first = first;
  this.second = second;
  this.checkData = mymethod;
}
```

Обычный вызов метода (код отобразит 1982):
```js
function person(name, age) {
    this.name= name;
    this.age = age;
    this.yearOfBirth = bornYear;
}
function bornYear() {
    return 2024 - this.age;
}

var p = new person("A", 42);

document.write(p.yearOfBirth());
```

Чтобы использовать свойства объекта в функции, используйте ключевое слово **"this"**.

<a id="gpt_comment_1"></a>
### Коментарий GPT-4o

В этом примере происходит путаница между тем, как назначаются методы объектам в JavaScript. Давай разберём по шагам, что тут происходит и как это исправить.

### Разбор кода:

1. **Конструктор `person`**:
    ```js
    function person(name, age) {
        this.name = name; // Присваиваем свойству `name` значение параметра `name`
        this.age = age;   // Присваиваем свойству `age` значение параметра `age`
        this.yearOfBirth = bornYear; // Присваиваем свойству `yearOfBirth` ссылку на функцию bornYear
    }
    ```

   Здесь создаётся конструктор для объекта `person`, где:
   - `this.name` — это имя объекта.
   - `this.age` — возраст объекта.
   - **Важный момент**: `this.yearOfBirth = bornYear;` — здесь мы присваиваем свойству объекта ссылку на функцию `bornYear`.

2. **Функция `bornYear`**:
    ```js
    function bornYear() {
        return 2016 - this.age;
    }
    ```

   Это обычная функция, которая вычисляет год рождения, основываясь на возрасте. Однако есть проблема: в этой функции используется `this.age`, но если вызвать её без привязки к объекту, `this` не будет ссылаться на текущий объект.

3. **Создание объекта**:
    ```js
    var p = new person("A", 22);
    ```

    Мы создаём новый объект `p`, где:
    - `p.name = "A"`.
    - `p.age = 22`.
    - `p.yearOfBirth` теперь ссылается на функцию `bornYear`.

4. **Вызов метода**:
    ```js
    document.write(p.yearOfBirth());
    ```

   Здесь мы пытаемся вызвать метод `yearOfBirth` через объект `p`. В теории, он должен вернуть год рождения, но будет ошибка, потому что в функции `bornYear` `this` указывает не на объект `p`, а на глобальный объект, где свойства `age` нет.

### Что значит **вызовите метод по свойству, а не по имени функции**?

Это значит, что вместо вызова функции напрямую (например, `bornYear()`), нужно использовать свойство объекта. В данном случае, ты правильно вызываешь метод через свойство объекта: `p.yearOfBirth()`.

Но, чтобы это заработало, нужно правильно привязать `this` к текущему объекту. Для этого нужно либо переписать функцию как метод объекта, либо воспользоваться стрелочной функцией.

### Исправление:

Чтобы всё заработало правильно, нужно убедиться, что `this` в функции `bornYear` ссылается на объект. Есть несколько способов это сделать.

#### Способ 1: Определить функцию `bornYear` как метод объекта

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = function() {
        return 2016 - this.age; // Здесь `this` указывает на объект `p`
    };
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Теперь метод `yearOfBirth` является частью объекта, и `this` будет ссылаться на объект `p`, поэтому всё сработает корректно.

#### Способ 2: Использовать стрелочную функцию

Стрелочные функции автоматически привязывают контекст `this` к текущему объекту.

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = () => 2016 - this.age; // Стрелочная функция
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Стрелочная функция захватывает контекст `this` объекта `p`, поэтому всё работает правильно.

### Вывод:

- **Вызов по свойству** означает, что ты должен использовать `p.yearOfBirth()` вместо прямого вызова `bornYear()`, чтобы метод работал как часть объекта.
- Чтобы код работал корректно, `this` в методе должен ссылаться на текущий объект. Это можно сделать, объявив метод внутри конструктора или используя стрелочную функцию.

Теперь код будет работать как надо!

### [Назад к оглавлению](#back)


<a id="qviz_1"></a>
## Квиз Модуля 1
1. Свойства объекта похожи на переменные; методы похожи на:

- [ ] операторы
- [x] функции
- [ ] свойства
- [ ] условные операторы

2. Каков результат следующего выражения?
```js
var myString = "abcdef";
document.write(myString.length);
```
Ответ: 6

3. Завершите выражение для создания конструктора объекта, учитывая, что **height** и **weight** являются свойствами, а **calculate** является методом для данного объекта:
```js
function mathCalc (height, weight) {
  this.height = [height];
  this.weight = [weight];
  this.sampleCalc = [calculate];
}
// *в квадратных скобках [] указаны места, куда нужно было вставить недостающие части выражения. Скобки не учитываются.
```

### [Назад к оглавлению](#back)


<a id="qviz_1_pract"></a>
## Менеджер контактов
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ 

Вы работаете над приложением Менеджер контактов.

Вы создали конструктор объекта `contact`, который имеет два аргумента, `name` и `number`.

Вам нужно добавить метод `print()` к объекту, который будет выводить данные контакта в консоль в следующем формате: `name: number`

Данный код объявляет два объекта и вызывает их методы `print()`. Завершите код, определив метод `print()` для объектов.

> Обратите внимание на пробел после двоеточия при выводе контактных данных.
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);
a.print();
b.print();
```

Решение способом **определения функции как метод объекта** (пример решения способом стрелочной функции [был описан выше](#gpt_comment_1)):
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
    // Определить функцию print как метод объекта
    this.print = function() {
        return name + ": " + number;
    }
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);

// Вывести метод print объекта contact в консоль
console.log(a.print());
console.log(b.print());
```

### [Назад к оглавлению](#back)


<a id="core_obj"></a>
# Core Objects

<a id="arrays"></a>
## Массивы

### Массивы в JavaScript
Массивы хранят несколько значений в одной переменной. 

Чтобы сохранить названия трех курсов, вам потребуются три переменные.
```js
var course1 ="HTML";
var course2 ="CSS";
var course3 ="JS";
```

Но что, если у вас было 500 курсов? Решение - **array (массив)**.
```js
var courses = new Array("HTML", "CSS", "JS");
```

Этот синтаксис объявляет массив с именем **courses**, который хранит три значения или элемента.

Два ключевых слова для создания массива:
- **new**
- **Array**

### Обращение к элементам массива
Вы обращаетесь к элементу массива, указывая **номер индекса** в **квадратных скобках**. 

Следующе утверждение обращается к значению первого элемента в `courses` и изменяет значение второго элемента.
```js
var courses = new Array("HTML", "CSS", "JS");
var course = courses[0]; // Обращение к HTML
courses[1] = "C++"; // Изменение второго элемента
```

- **[0]** - первый элемент в массиве. 
- **[1]** - второй элемент. 

> Индексы массива начинаются с ноля - `0`.

Результатом выполнения следующего кода - станет `6`:
```sql
var arr = new Array(3, 6, 8);
document.write(arr[1]);
```

### Доступ к массиву
Попытка доступа к индексу за пределами массива возвращает значение `undefined`, что буквально означает - неопределено. Таким выводом будет итог работы следующего кода:
```js
var courses = new Array("HTML", "CSS", "JS"); 
document.write(courses[10]);
```

Наш массив `courses` имеет всего три элемента, поэтому десятый индекс, который является 11-м элементом, не существует (не определен).

### [Назад к оглавлению](#back)


<a id="pract_3"></a>
## Пушистые блинчики (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Массивы 
Представленный вам массив представляет собой меню завтраков, доступных в отеле.

Шеф-повар решил заменить один из вариантов на "Fluffy Pancakes" (Пушистые блинчики).

Напишите программу, чтобы взять индекс как ввод, заменить элемент с этим индексом на "Fluffy Pancakes" и вывести новое меню в консоль в виде массива.
```js
Пример ввода:
2

Пример вывода:
[
  'Cinnamon Doughnuts',
  'Waffles',
  'Fluffy Pancakes',
  'Chorizo Burrito',
  'French Toast'
]
```
Элемент с индексом `2` был заменен в выходном массиве.

Помните, что первый элемент массива имеет индекс `0`.
```js
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    // замените соответствующий элемент на 'Fluffy Pancakes'.
    
    // вывести menu в консоль
    
}
```

Решение:
```sql
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    //замените соответствующий элемент на "Fluffy Pancakes".
    breakfasts[index] = "Fluffy Pancakes";
    //вывести меню на консоль
    console.log(breakfasts);
}
```

### [Назад к оглавлению](#back)


<a id="another_make_array"></a>
## Другие способы создания массивов
### Создание массивов
Вы также можете объявить массив, указать количество элементов, которые он будет хранить, и добавить элементы позже.

Следующий код выведет `"JS"`:
```js
var courses = new Array(3);
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";

document.write(courses[2]);
```

Массив - это особый тип объекта.
- **Массив** использует **числа** для доступа к своим элементам, а 
- **Объект** использует **имена** для доступа к своим членам.

### Создание массивов
Массивы в JavaScript динамические, поэтому вы можете объявить массив и не передавать никаких аргументов с конструктором `Array()`. Затем вы можете динамически добавлять элементы:
```js
var courses = new Array();
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";
courses[3] = "C++";

document.write(courses[2]);
```

Вы можете добавить столько элементов, сколько вам нужно.

### Литерал массива
Для большей простоты, удобочитаемости и скорости выполнения, вы также можете объявлять массивы, используя синтаксис **литерала массива**.
```js
var courses = ["HTML", "CSS", "JS"]; 

document.write(courses[2]);
```
Такой синтаксис приводит к созданию такого же массива, как и тот, который создается с использованием нового синтаксиса `Array()`. Код выдаст результат - "JS".

Вы можете получить доступ и изменить элементы массива, используя номер индекса, как вы делали раньше.

Синтаксис **литерала массива** является **рекомендуемым** способом объявления массивов.

Вводя `var example = new Array();`, мы создаем пустой массив, который можно заполнить **в любое время позже**.

### [Назад к оглавлению](#back)


<a id="props_methods_array"></a>
## Свойства и методы массива

### Свойство length
У массивов JavaScript есть полезные встроенные свойства и методы.

Свойство `length` массива возвращает количество его элементов. Следующий код вернет число 9:
```js
var courses = ["HTML", "CSS", "JS"];
document.write(courses.length);
```

Свойство `length` всегда на одну единицу больше, чем самый высокий индекс массива.

Если массив пуст, свойство `length` возвращает ноль - `0`.

Массив имеет свойство `length` - потому что является объектом.

### Объединение массивов
Метод `concat()` в JavaScript позволяет вам объединять массивы и создавать совершенно новый массив. 
```js
var c1 = ["HTML", "CSS"];
var c2 = ["JS", "C++"];
var courses = c1.concat(c2);

document.write(courses[2]);
```

Массив `courses`, который получается в результате, содержит 4 элемента (HTML, CSS, JS, C++). На выходе получаем неизменый JS. 

Операция `concat` не влияет на массивы `c1` и `c2` - она возвращает результат конкатенации в виде **нового массива**.

Таким образом метод `concat` принимает два массива и объединяет их в один новый массив

### [Назад к оглавлению](#back)


<a id="pract_4"></a>
## Повысь уровень! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Свойства и методы массивов
Игрок получает очки после прохождения каждого уровня игры.

Данная программа принимает число пройденных уровней в качестве входных данных, за которыми следуют набранные за каждый уровень очки, и создает соответствующий массив очков.

Дополните программу, чтобы рассчитать и вывести на консоль сумму всех набранных очков.
```js
Пример ввода
3
1
4
8

Пример вывода
13
```

Объяснение

Первый ввод представляет собой число пройденных уровней, -- в этом случае, 3 (размер создаваемого массива). Следующие 3 ввода -- это очки, начисленные игроку за прохождение каждого уровня. Игрок набрал 1+4+8 очков за 3 пройденных уровня, что затем выводится.

Обратите внимание, что первое введенное число может быть использовано в качестве длины массива.
```js
function main() {
    // Получение числа пройденных уровней
    var levels = parseInt(readLine(),10);
    var points = new Array();
    
    var count = 0;
    while(count<levels){
        var elem = parseInt(readLine(),10);
        points[count] = elem;
        count++;
    }
    
    var sum = 0;
    //вычислить сумму баллов
     
    
    //output
    console.log(sum);
}
```

### [Назад к оглавлению](#back)


<a id="pract_4_gpt"></a>
## Решение от GPT-4o

Решение этой задачи заключается в том, чтобы просуммировать очки, введенные пользователем, и вывести итоговое значение. Давай разберем пошагово, что нужно сделать в этой программе.

### Задача:
1. Пользователь вводит количество уровней.
2. Затем вводит очки за каждый уровень.
3. Нужно создать массив, в который будут записаны эти очки.
4. После этого нужно просуммировать все очки и вывести результат.

### Разбор программы:

```js
function main() {
    // Получаем количество уровней (размер массива)
    var levels = parseInt(readLine(), 10);
    
    // Создаем пустой массив для очков
    var points = new Array();
    
    var count = 0;
    
    // Читаем и записываем очки в массив
    while(count < levels) {
        var elem = parseInt(readLine(), 10);
        points[count] = elem;  // Записываем очки в массив
        count++;
    }
    
    // Теперь нужно посчитать сумму всех очков
    var sum = 0;
    for (var i = 0; i < points.length; i++) {
        sum += points[i];  // Добавляем каждое значение из массива к сумме
    }
    
    // Выводим итоговую сумму
    console.log(sum);
}
```

### Пояснение решения:
1. **Получение количества уровней**:  
   Мы начинаем с того, что принимаем первое число, которое указывает количество уровней.  
   `var levels = parseInt(readLine(), 10);` — эта строка превращает ввод пользователя в целое число (количество уровней).
   
2. **Создание массива для очков**:  
   `var points = new Array();` — создаём пустой массив, в который будем добавлять очки за каждый уровень.

3. **Чтение очков и их добавление в массив**:  
   Мы используем цикл `while`, чтобы прочитать очки за каждый уровень:
   ```js
   while(count < levels) {
       var elem = parseInt(readLine(), 10);
       points[count] = elem;  // Записываем очки в массив
       count++;
   }
   ```
   В этом блоке происходит следующее:
   - Вводим очередное число (очки за уровень).
   - Записываем это число в массив `points` на позицию `count`.
   - Увеличиваем счетчик `count`, чтобы перейти к следующему элементу массива.

4. **Вычисление суммы очков**:  
   После того как все очки введены, мы должны их просуммировать. Для этого используем цикл `for`:
   ```js
   for (var i = 0; i < points.length; i++) {
       sum += points[i];  // Добавляем каждое значение из массива к сумме
   }
   ```
   Этот цикл проходит по всем элементам массива `points` и добавляет их к переменной `sum`, которая изначально равна 0.

5. **Вывод результата**:  
   После того как сумма всех очков посчитана, выводим результат:
   ```js
   console.log(sum);
   ```

### Пример работы программы:
Если ввести следующие данные:
```
3
1
4
8
```

Программа:
- Считает количество уровней (`3`).
- Считает очки за каждый уровень (`1`, `4`, `8`).
- Вычисляет сумму: `1 + 4 + 8 = 13`.
- Выведет `13`.

### Заключение:
Мы использовали цикл для чтения очков и суммирования значений. Важно правильно работать с массивами и циклами, чтобы корректно обработать ввод и посчитать результат.

### Про выражение while(count < levels)

Выражение `while(count < levels)` используется для того, чтобы цикл выполнялся **до тех пор**, пока значение переменной `count` меньше, чем количество уровней `levels`.

### Пояснение:
- **`count`** — это счётчик, который отслеживает количество введённых очков за уровни.
- **`levels`** — это количество уровней, которое ввёл пользователь, и, соответственно, это количество очков, которое нужно ввести.

Цикл `while` работает по следующему принципу:
- Выполняется, пока условие в скобках `count < levels` возвращает `true`.
- Как только счётчик `count` достигает значения `levels` (то есть мы ввели нужное количество очков), условие становится `false`, и цикл завершается.

### Почему используется `while(count < levels)`:
1. **Количество итераций**: Это условие гарантирует, что цикл выполнится **ровно столько раз**, сколько уровней (и, соответственно, очков) нужно обработать.
2. **Чтение данных**: После каждой итерации счётчик `count` увеличивается (`count++`), что означает, что вводится одно новое очко. Когда введено ровно столько очков, сколько уровней, цикл завершится.
3. **Гибкость**: Если пользователь введёт любое другое количество уровней, цикл корректно адаптируется к этому числу и будет работать для любого количества очков.

### Пример:
- Допустим, пользователь ввёл `3` как количество уровней.
- Тогда цикл начнётся с `count = 0` и будет продолжаться до тех пор, пока `count < 3`. То есть он выполнится для `count = 0`, `count = 1` и `count = 2`.
- Как только `count` станет равен `3`, условие перестанет быть истинным, и цикл завершится.

Если бы вместо `while(count < levels)` мы использовали другое условие (например, `while(true)`), цикл мог бы стать бесконечным или некорректно завершаться.

### [Назад к оглавлению](#back)


<a id="asoc_arriv"></a>
## Ассоциативные массивы

Хотя многие языки программирования поддерживают массивы с именованными индексами (текст вместо чисел), называемые **ассоциативными массивами** - JavaScript их **не поддерживает**.

Однако вы все еще можете использовать синтаксис именованных массивов, который создаст объект.

Например:
```js
var person = []; //empty array
person["name"] = "John";
person["age"] = 46;
document.write(person["age"]);
```

Теперь `person` рассматривается как объект, а не как массив. 
Именованные индексы `name` и `age` становятся свойствами объекта `person`.

Поскольку массив `person` рассматривается как объект, стандартные методы и свойства массива дадут неправильные результаты. Например, `person.length` вернет ноль - `0`.

В **ассоциативных массивах**, индексные номера заменяются на **строки**.

Помните, что JavaScript **не поддерживает** массивы с именованными индексами.
- В JavaScript массивы всегда используют номерные индексы.
- Лучше использовать **объект**, когда вы хотите, чтобы индекс был **строкой** (текст).
- Используйте **массив**, когда вы хотите, чтобы индекс был **числом**.
- Если вы используете именованный индекс, JavaScript переопределит массив в стандартный объект.

Чтобы использовать ассоциативные массивы, "ассоциированное" имя помещается **вквадратные скобки** `[]`.

### [Назад к оглавлению](#back)


<a id="math_obj"></a>
## Математический объект

Объект **Math** позволяет вам выполнять математические задачи и включает в себя несколько свойств.

|Property |Description |Перевод описания |
|---------|------------|--|
|**E** |Euler's constant |Постоянная Эйлера |
|**LN2** |Natural log of the value 2 |Натуральный логарифм значения 2 |
|**LN10** |Natural log of the value 10 |Натуральный логарифм значения 10 |
|**LOG2E** |The base 2 log of Euler's constant (E) |Логарифм константы Эйлера (E) по основанию 2 |
|**LOG10E** |The base 10 log of Euler's constant (E) |Логарифм константы Эйлера (E) по основанию 10 |
|**PI** |Returns the constant Pi |Возвращает число пи (3,14) |

Например результатом отображения в браузере следующего кода будет вывод числа Пи: 3.141592653589793
```js
document.write(Math.PI);
```

**Math** не имеет конструктора. Нет необходимости сначала создавать объект `Math`.

### Методы объекта Math
Объект **Math** содержит ряд методов, которые используются для вычислений:

|Method |Description |Перевод |
|--|--|--|
|**abs(x)** |Returns the absolute value of x  |Возвращает абсолютное значение x  |
|**acos(x)** |Returns the arccosine of x, in radians  |Возвращает арккосинус x, в радианах  |
|**asin(x)**  |Returns the arsine of x, in radians |Возвращает арксинус x, в радианах  |
|**atan(x)** |Returns the arctangent of x as a numeric value between [-PI/2] and [PI/2] radians  |Возвращает арктангенс x в виде числового значения между [-PI/2] и [PI/2] радиан  |
|**atan2(y,x)** |Returns the arctangent of the quotient of its arguments  |Возвращает арктангенс колличества своих аргументов  |
|**ceil(x)**  |Returns x, rounded upwards to the nearest integer  |Возвращает x, округленное в большую сторону до ближайшего целого числа  |
|**cos(x)** |Returns the cosine of x (x is in radians)  |Возвращает косинус x (x в радианах)  |
|**exp(x)** |Returns the value of E*  |Возвращает значение E*  |
|**floor(x)**  |Returns x, rounded downwards to the nearest integer  |Возвращает x, округленное в меньшую сторону до ближайшего целого числа  |
|**log(x)** |Returns the natural logarithm (base E) of x  |Возвращает натуральный логарифм (основание E) от x  |
|**max(x,y,z,...,n)** |Returns the number with the highest value  |Возвращает число с наибольшим значением  |
|**min(x,y,z,...,n)** |Returns the number with the lowest value  |Возвращает число с наименьшим значением  |
|**pow(x,y)** |Returns the value of x to the power of y  |Возвращает значение x в степени y  |
|**random()** |Returns a random number between 0 and 1  |Возвращает случайное число от 0 до 1  |
|**round(x)** |Rounds x to the nearest integer  |Округляет x до ближайшего целого числа  |
|**sin(x)** |Returns the sine of x (x is in radians) |Возвращает синус x (x в радианах)  |
|**sqrt(x)** |Returns the square root of x  |Возвращает квадратный корень из x  |
|**tan(x)** |Returns the tangent of an angle |Возвращает тангенс угла |

Например, следующий код вычислит **квадратный корень** числа:
```js
var number = Math.sqrt(4); 
document.write(number);
```

Чтобы получить случайное число от 1 до 10, используйте `Math.random()`, который дает вам число от 0 до 1. Затем умножьте число на 10, а затем воспользуйтесь функцией `Math.ceil()`: `Math.ceil(Math.random() * 10)`.

### [Назад к оглавлению](#back)


<a id="pract_5"></a>
## Какой век? (Практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Объект Math

Создайте функцию, которая возвращает век в зависимости от года, заданного в качестве параметра.
```js
Пример ввода:
1993

Пример вывода:
20
```

#### Подсказка

Вам нужно разделить 1993 на 100: 1993/100 = 19.93, затем округлить его до ближайшего целого числа, которое в этом случае равно 20.

Используйте `Math.ceil(x)`, который возвращает `x`, округленное вверх до ближайшего целого числа:
```js
function main() {
    var year = parseInt(readLine(), 10);  // Получаем значение года
    
    // Выводим результат, вызывая функцию calcCent с аргументом year
    console.log(calcCent(year));
}

// Дополняем функцию
function calcCent(year) {
    year = year / 100;  // Делим год на 100
    return Math.ceil(year);  // Округляем вверх до целого числа и возвращаем результат
}
```

Пояснение:

1. В функции `main()` вызывается функция `calcCent()` и передаётся переменная `year` как аргумент: `calcCent(year)`.
2. Функция `calcCent()` принимает этот аргумент: `function calcCent(year)`.
3. Внутри функции `calcCent()` вы делите year на 100 и округляете результат вверх с помощью `Math.ceil()`.
4. Округлённое значение возвращается через `return`, чтобы вывести его в `console.log`.

Объект Math
Давайте создадим программу, которая будет просить пользователя ввести число и выводить его квадратный корень.
```js
var n = prompt("Enter a number", "");
var answer = Math.sqrt(n);
alert("The square root of " + n + " is " + answer);
```

Результат:

![pic1](https://lecontent.sololearn.com/material-images/bd4171a04aef463a9d096c398acba66a-2770.png)

Введите число, например 64.
![pic2](https://lecontent.sololearn.com/material-images/420f29528f3b4004a236197bfc56ff56-2771.png)

**Math** - это удобный объект. Вы можете сэкономить много времени, используя Math, вместо написания своих собственных функций каждый раз.

Результатом `Math.sqrt(81);` - будет девять.

### [Назад к оглавлению](#back)


<a id="date_obj"></a>
## Объект Date

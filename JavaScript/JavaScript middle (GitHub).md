# JavaScript – Средний уровень

Вы уже знакомы с основами JavaScript и хотели бы пополнить свои знания? Тогда вы в правильном месте. На этом курсе вы научитесь создавать более сложные и гибкие программы, а также ещё более интерактивные сайты. Этот курс является продолжением нашего курса Введение в Javascript. Мы рекомендуем вам ознакомиться содержанием курса "Введение в Javascript", прежде чем начать этот курс.

<a name="back"></a>
### Оглавление:
### [Объекты](#obj)
#### [Введение в объекты](#intro_obj)
#### [Создание cобственных Объектов](#oun_obj)
##### [Приземлились! (практика)](#pract_1)
<!--##### [Решение от GPT-4o](#pract_1_gpt)-->
#### [Инициализация объекта](#init_obj)
#### [Добавление методов](#add_methods)
##### [Расчет скидки (практика)](#pract_2)
<!--##### [Решение от GPT-4o](#pract_2_gpt)-->
#### [Продолжение главы "добавление методов"](#add_methods_1)
#### [Объекты и методы: коментарий GPT-4o](#gpt_comment_1)
#### [Квиз Модуля 1](#qviz_1)
##### [Менеджер контактов (практика)](#qviz_1_pract)
### [Core Objects](#core_obj)
#### [Массивы](#arrays)
##### [Пушистые блинчики (практика)](#pract_3)
#### [Другие способы создания массивов](#another_make_array)
#### [Свойства и методы массива](#props_methods_array)
##### [Повысь уровень! (практика)](#pract_4)
<!--##### [Решение от GPT-4o](#pract_4_gpt)-->
#### [Ассоциативные массивы](#asoc_arriv)
#### [Математический объект](#math_obj)
##### [Какой век? (Практика)](#pract_5)
#### [Объект Date](#date_obj)
##### [Понедельник до Воскресенья (практика)](#pract_6)
<!--##### [Решение от GPT-4o](#pract_6_gpt)-->
#### [Викторина модуля 2](#exam_2)
##### [Менеджер магазина (практическое упражнение)](#pract_7)
<!--##### [Решение от GPT-4o](#pract_7_gpt)-->
### [DOM & События](#dom_events)
#### [Что такое DOM?](#what_is_dom)
#### [Выбор элементов](#elements_select)
#### [Изменение элементов](#change_elements)
#### [Добавление и удаление элементов](#add_del_elements)
#### [Создание анимаций](#criate_animation)
#### [Обработка событий](#event_handling)
#### [Распространение событий](#event_spreading)
#### [Создание слайдера изображений](#image_slider)
#### [Проверка Формы](#form_checking)
#### [Квиз Модуль 3](#qviz_3)
### [ECMAScript](#ecma_script)
#### [Введение в ES6](#es6_intro)
#### [ES6 Переменные и строки](#es6_var_st)
##### [London is the capital (практика)](#pract_8)
#### [Циклы и функции в ES6](#es6_func)
#### [For...in, For...of: коментарий GPT-4o](#gpt_comment_2)
##### [Оценка 70 и выше! (практика)](#pract_9)
#### [Продолжение Циклы и функции в ES6](#es6_func2)
#### [ES6 Объекты](#es6_obj)
##### [Тренируйтесь усерднее! (практика)](#pract_10)
#### [ES6 Destructuring](#es6_destruct)
#### [Rest & Spread](#es6_rest_spread)
##### [Калькулятор суммы (практика)](#pract_11)
#### [Продолжение Rest & Spread](#es6_rest_spread2)
#### [ES6 Классы](#es6_class)
##### [Средний балл экзамена (практика)](#pract_12)
#### [Продолжение Классы в ES6](#es6_class2)
#### [Map & Set](#map_&_set)
##### [Карта сотрудников (практика)](#pract_13)
#### [Продолжение Map & Set](#map_&_set2)
#### [Больше о ES6](#es6_more)
#### [ES6 Promises: коментарий GPT-4o](#gpt_comment_3)
#### [Продолжение "Больше о ES6"](#es6_more2)
#### [ES6 итераторы и генераторы: коментарий GPT-4o](#gpt_comment_5)
#### [Продолжение "Больше о ES6"](#es6_more3)
#### [JS Промежуточный Модуль 4 Викторина](#qviz4)
#### [ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ Слова](#pract_4_f)
#### [Решение GPT-4o](#pract_4_f_gpt)
--- 

<a name="obj"></a>
# Объекты

### [Назад к оглавлению](#back)


<a name="intro_obj"></a>
## Введение в объекты

### Объекты JavaScript
Переменные JavaScript являются контейнерами для значений данных. 

**Объекты** также являются переменными, но они могут содержать много значений.

Считайте объект списком значений, которые записаны как пары `имя:значение`, где имена и значения разделены двоеточиями.

Пример:
```js
var person = {
 name: "John", age: 31, 
 favColor: "green", height: 183
};
```
Эти значения называются **properties**.

|Property |Property Value |
|--|--|
|**name** |John |
|**age** |31 |
|**favColor** |green |
|**height** |183 |

Относительно объекта, `color`, `height`, `weight` и `name` являются примерами **свойства**.

### Свойства объекта
Вы можете получить доступ к свойствам объекта двумя способами.
```js
objectName.propertyName
//or
objectName['propertyName']
```
Этот пример демонстрирует, как получить доступ к `age` нашего объекта person.
```js
var age = person.age /* проверить позже */
```

Встроенное свойство `length` в JavaScript используется для подсчета количества символов в свойстве или строке.
```js
var course = {name: "JS", lessons: 41};
document.write(course.name.length);
```

Объекты являются одной из основных концепций в JavaScript.

### Методы объекта
**Метод объекта** - это свойство, содержащее **определение функции**.

Используйте следующий синтаксис для доступа к методу объекта.
```js
objectName.methodName()
```
Как вы уже знаете, `console.log()` регистрирует текст в консоли. Функция `log()` на самом деле является методом объекта `console`.
```js
console.log("This is some text");
```
**Методы** - это функции, которые хранятся в качестве свойств объекта.

### Объем кубоида (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

#### Введение в объекты
Данный класс представляет собой параллелепипед (например, прямоугольный), который содержит свойства длины, ширины и высоты.

Дополните программу, чтобы рассчитать и вывести в консоль объем данного параллелепипеда.

>> Подсказка: чтобы вычислить объем параллелепипеда, используйте формулу `length*width*height`.
```js
var cuboid = {
    length: 25,
    width: 50,
    height: 200
};

//your code goes here

console.log(cuboid.length * cuboid.width * cuboid.height)
```

Доступ к свойству `color` объекта `hair` используя синтаксис с точкой:
```js
hair.color
```

### [Назад к оглавлению](#back)


<a name="oun_obj"></a>
## Создание cобственных Объектов

### Конструктор объекта
В предыдущем уроке мы создали объект, используя **синтаксис литерала** (или инициализатора) объекта (объектный литерал).
```js
var person = {
  name: "John", age: 42, favColor: "green"
};
```
>> **Литерал** — это фиксированное значение, которое напрямую указывается в коде программы. Это может быть число, строка, логическое значение или объект, которое не требует вычисления или вызова функций.
>>
>> - Числовой литерал: 42
>> - Строковый литерал: "Hello, World!" или 'Hello, World!'
>> - Булевый литерал: true или false
>> - Объектный литерал: { name: "John", age: 42 }

Это позволяет вам создать только один объект.

Иногда нам нужно установить **"тип объекта"**, который может быть использован для создания нескольких объектов одного типа.

Стандартный способ создания "типа объекта" - использовать функцию **конструктора объекта**.
```js
function person(name, age, color) {
  this.name = name;
  this.age = age;
  this.favColor = color;
}
```
Вышеуказанная функция (`person`) является конструктором объекта, который принимает параметры и присваивает их свойствам объекта.

> Подсказка: ключевое слово **this** относится к **текущему объекту**.
>
> Обратите внимание, что this не является переменной. Это ключевое слово, и его значение не может быть изменено.

Пример создания функции конструктора:
```js
function movie(title, director) {
  this.title = title;
  this.director = director;
}
```

### Создание объектов
Как только у вас есть конструктор объектов, вы можете использовать ключевое слово **new** для создания новых объектов того же типа.
```js
function person(name, age, color) {
    this.name = name;
    this.age = age;
    this.favColor = color;
}

var p1 = new person("John", 42, "green");
var p2 = new person("Amy", 21, "red");

document.write(p1.age); 
```
> `p1` и `p2` теперь являются объектами типа `person`. Их свойства присваиваются соответствующим значениям.

Для создания экземпляра объекта используется ключевое слово - **new**.

### Создание объектов
Рассмотрим следующий пример.
```js
function person (name, age) {
    this.name = name;
    this.age = age;
}
var John = new person("John", 25);
var James = new person("James", 21);

document.write(John.age);
```
Доступ к свойствам объекта осуществляется с использованием **синтаксиса с точкой**, как вы делали это ранее.

|Object's |Property's name |
|--|--|
|**John.** |name |
|**John.** |age |
|**James.** |name |
|**James.** |age |

> Понимание создания объектов является важным.

В качестве примера - два компонента необходимых для использования информации, содержащейся в объекте:
- имя объекта
- имя свойства

### [Назад к оглавлению](#back)


<a name="pract_1"></a>
### Приземлились! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Создание собственных объектов
Боба наняли информационным офицером аэропорта, и ему нужно генерировать статусные сообщения для каждого рейса. Давайте поможем ему!

Дополните данную программу, исправив конструктор, создав объект рейса и присвоив его данной переменной, чтобы правильно выполнить соответствующее сообщение.

ID рейса и статус рейса (приземлился, вовремя, задержка и т.д.) принимаются в качестве входных данных.

```js
Пример ввода:
NGT 929
приземлился

Пример вывода:
Flight NGT 929 has landed
```
> Используйте ключевое слово `new` для создания нового объекта с использованием конструктора.

Оригинальный код:
```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    var flight1;
    //assign a flight object to flight1 variable
    
    //output
    console.log('The flight ' + flight1.number + ' is ' + flight1.status)
    
}

function Flight(flightNumber, status) {
    //fix the constructor
    number = flightNumber;
    status = status;
};
```

<a name="pract_1_gpt"></a>
### Решение от GPT-4o

Окей, давай разберем твою задачу шаг за шагом и объясню, что нужно сделать.

### 1. **Ошибка в конструкторе**
В конструкторе функции `Flight` у тебя объявлены переменные `number` и `status`, но они не привязаны к объекту, который создается с помощью этого конструктора. В JavaScript, чтобы создать свойства объекта внутри конструктора, нужно использовать ключевое слово `this`.

### 2. **Исправляем конструктор**
Когда создается объект с помощью `new Flight(...)`, нам нужно привязать свойства `number` и `status` к самому объекту, используя `this`. Это позволит обращаться к этим свойствам у объекта.

Вот как нужно исправить:

```js
function Flight(flightNumber, status) {
    this.number = flightNumber; // Привязываем параметр к объекту через this
    this.status = status;       // То же самое со статусом
}
```

Теперь свойства `number` и `status` станут частью объекта, который мы создадим через `new Flight()`.

### 3. **Создание объекта**
Теперь, когда конструктор исправлен, можно создать объект рейса и присвоить его переменной `flight1`.

```js
var flight1 = new Flight(flightNumber, flightStatus);
```

Это создаст новый объект `flight1`, где:
- `flight1.number` будет равно значению `flightNumber`
- `flight1.status` будет равно значению `flightStatus`

### 4. **Окончательный код**
Теперь соберем всё вместе:

```js
function main() {
    //take flight number and its status
    var flightNumber = readLine();
    var flightStatus = readLine();
    
    // Создаем объект рейса, используя конструктор
    var flight1 = new Flight(flightNumber, flightStatus);
    
    // Выводим сообщение с использованием свойств объекта
    console.log('The flight ' + flight1.number + ' is ' + flight1.status);
}

function Flight(flightNumber, status) {
    // Привязываем свойства к объекту через this
    this.number = flightNumber;
    this.status = status;
}
```

### 5. **Объяснение для чайника**

- **Конструктор `Flight`** — это как шаблон для создания объекта рейса. Когда ты создаёшь объект (например, `flight1`), конструктор берет параметры (номер рейса и статус) и сохраняет их в свойствах объекта с помощью `this`.
  
  `this.number = flightNumber` означает: «В объекте, который сейчас создаётся, создай свойство `number` и присвой ему значение переменной `flightNumber`».

- **Создание объекта `flight1`** через `new Flight(...)` означает: «Создай новый объект рейса, используя указанный номер рейса и статус».

- **`flight1.number`** и **`flight1.status`** — это свойства объекта `flight1`, к которым мы можем обращаться и выводить их значения.

Теперь программа будет выводить корректное сообщение о статусе рейса!
</spoiler>


### [Назад к оглавлению](#back)


<a name="init_obj"></a>
## Инициализация объекта

Используйте синтаксис **объектного литерала** или **инициализатора** для создания отдельных объектов.
```js
var John = {name: "John", age: 25};
var James = {name: "James", age: 21};
```

Объекты состоят из свойств, которые используются для описания объекта. Значения свойств объекта могут содержать как примитивные типы данных, так и другие объекты.
```js
simba = {
    category: "lion", 
    gender: "male"
}
```

### Использование инициализаторов объектов

Пробелы и переносы строк не важны. Определение объекта может занимать несколько строк.

 Независимо от того, как создан объект, синтаксис для доступа к свойствам и методам не меняется.
```js
var John = {
    name: "John",
    age: 25
};
var James = {
    name: "James",
    age: 21
};

document.write(John.age);
//альтернатива: document.write(John['age']);
```

Код выше отобразит 25. Не заывайте об альтернативном способе доступа к свойству объекта: `document.write(John['age']);`.

Например следующее выражение отобразит свойство `category` объекта `simba` на экране:
```js
document.write(simba.category);
```

### [Назад к оглавлению](#back)


<a name="add_methods"></a>
## Добавление методов

### Методы - это функции, которые хранятся в свойствах объекта. 

Используйте следующий синтаксис для создания метода объекта:
```js
methodName = function() { code lines }
```

Доступ к методу объекта осуществляется с использованием следующего синтаксиса:
```js
objectName.methodName()
```

**Метод** - это функция, принадлежащая объекту. Она может быть вызвана с использованием ключевого слова **this**. 

Ключевое слово **this** используется как **ссылка на текущий объект**, что означает, что вы можете получить доступ к свойствам и методам объекта, используя его.

Определение методов производится внутри функции-конструктора.
```sql
function person(name, age) {
    this.name = name;  
    this.age = age;
    this.changeName = function (name) {
        this.name = name;
    }
}

var p = new person("David", 21);
p.changeName("John");

document.write(p.name);
```

В приведенном выше примере мы определили метод с именем `changeName` для нашего `person`, который является функцией, принимающей параметр `name` и присваивающей его свойству `name` объекта.

`this.name` относится к свойству `name` объекта.

>> Метод `changeName` изменяет свойство `name` объекта на его аргумент.


### [Назад к оглавлению](#back)


<a name="pract_2"></a>
## Расчет скидки (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Добавление методов
  

Менеджеру магазина нужна программа для установки скидок на товары.  Программа должна принимать ID продукта, цену и скидку в качестве ввода и выводить цену со скидкой. Однако метод `changePrice`, который должен рассчитывать скидку, неполный. Исправьте это!
```js
Пример ввода
LD1493
1700
15

Пример вывода
LD1493 цена: 1700
LD1493 новая цена: 1445
```
> Подсказка: первый ввод - это ID продукта, второй - цена до скидки, а третий - процент скидки.
>
>Так что после применения скидки новая цена будет 1700-(0.15*1700) = 1445.
```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(),10);
    var discount = parseInt(readLine(),10);
    
    var prod1= new Product(prodID, price);
    console.log(prod1.prodID + " цена: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " новая цена: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        //your code goes here
        
    }
}
```

<a name="pract_2_gpt"></a>
### Решение от GPT-4o
Давай разберем этот пример шаг за шагом, чтобы всё стало максимально понятно. В этой задаче мы должны создать класс продукта, и добавить в него метод для расчета новой цены с учётом скидки.

### Разбор задачи:

1. **Входные данные**:
    - **ID продукта** (`prodID`): Например, "LD1493".
    - **Цена продукта** (`price`): Например, 1700.
    - **Скидка** (`discount`): Например, 15 (процентов).

2. **Вывод**:
    - Сначала нужно вывести цену до скидки.
    - Затем нужно рассчитать цену после применения скидки и вывести новую цену.

### Код:

1. Функция `main`:
    - **`prodID = readLine();`** — получаем ID продукта.
    - **`price = parseInt(readLine(), 10);`** — получаем цену продукта и преобразуем её в целое число с помощью `parseInt()`.
    - **`discount = parseInt(readLine(), 10);`** — получаем размер скидки (в процентах) и тоже преобразуем его в число.

2. **Создание объекта**:
    - **`var prod1 = new Product(prodID, price);`** — создаём объект класса `Product` с параметрами `prodID` и `price`.

3. **Вывод первоначальной цены**:
    - **`console.log(prod1.prodID + " price: " + prod1.price);`** — выводим ID продукта и его первоначальную цену.

4. **Применение скидки**:
    - **`prod1.changePrice(discount);`** — вызываем метод `changePrice`, который должен изменить цену продукта с учётом скидки.
    - **`console.log(prod1.prodID + " new price: " + prod1.price);`** — выводим ID продукта и новую цену после применения скидки.

### Конструктор `Product`:

```js
function Product(prodID, price) {
    this.prodID = prodID; // Идентификатор продукта
    this.price = price;   // Цена продукта
}
```

Этот конструктор принимает два параметра (ID продукта и цену) и присваивает их свойствам создаваемого объекта (`this.prodID` и `this.price`).

### Метод `changePrice`:

Здесь мы добавляем логику для расчета новой цены:

```js
this.changePrice = function(discount) {
    // Рассчитываем новую цену с учётом скидки
    this.price = this.price - (this.price * discount / 100);
}
```

#### Как работает:
- Мы берём текущую цену продукта: `this.price`.
- Вычисляем скидку: `this.price * discount / 100`. Это процент скидки от цены.
- Вычитаем эту скидку из цены: `this.price = this.price - скидка`.

Например, если:
- Цена товара = 1700.
- Скидка = 15%.

То:
- Скидка = 1700 * 15 / 100 = 255.
- Новая цена = 1700 - 255 = 1445.

### Окончательный код:

```js
function main() {
    var prodID = readLine();
    var price = parseInt(readLine(), 10);
    var discount = parseInt(readLine(), 10);
    
    var prod1 = new Product(prodID, price);
    console.log(prod1.prodID + " price: " + prod1.price);
    
    prod1.changePrice(discount);
    console.log(prod1.prodID + " new price: " + prod1.price);
}

function Product(prodID, price) {
    this.prodID = prodID;
    this.price = price;

    this.changePrice = function(discount) {
        this.price = this.price - (this.price * discount / 100);
    }
}
```

### Пояснение:
1. Мы создали объект `Product` с ID продукта и начальной ценой.
2. Метод `changePrice` применяет скидку, рассчитывая новую цену.
3. Мы выводим старую и новую цену продукта после изменения.

Этот код делает именно то, что требуется: получает ID, цену, скидку, выводит цену до и после применения скидки. Надеюсь, это помогло тебе лучше понять, как всё работает!

### [Назад к оглавлению](#back)


<a name="add_methods_1"></a>
## Продолжение главы "добавление методов"

### Методы

Еще раз повторим:

Ключевое слово **this** в методе означает - **текущий объект**

Вы также можете определить функцию вне конструктора функции и связать ее с объектом.
```js
function person(name, age) {
  this.name= name;  
  this.age = age;
  this.yearOfBirth = bornYear;
}
function bornYear() {
  return 2024 - this.age;
}
```

Как вы можете видеть, мы назначили свойству объекта `yearOfBirth` функцию `bornYear`.

Ключевое слово `this` используется для доступа к свойству `age` объекта, который будет вызывать метод. 

Обратите внимание, что не обязательно писать скобки функции при ее присваивании объекту.

Следующий код связывает функцию конструктора `testData` с методом под названием `mymethod`:
```js
function testData (first, second) {
  this.first = first;
  this.second = second;
  this.checkData = mymethod;
}
```

Обычный вызов метода (код отобразит 1982):
```js
function person(name, age) {
    this.name= name;
    this.age = age;
    this.yearOfBirth = bornYear;
}
function bornYear() {
    return 2024 - this.age;
}

var p = new person("A", 42);

document.write(p.yearOfBirth());
```

Чтобы использовать свойства объекта в функции, используйте ключевое слово **"this"**.

### [Назад к оглавлению](#back)


<a name="gpt_comment_1"></a>
### Объекты и методы: коментарий GPT-4o

В этом примере происходит путаница между тем, как назначаются методы объектам в JavaScript. Давай разберём по шагам, что тут происходит и как это исправить.

### Разбор кода:

1. **Конструктор `person`**:
    ```js
    function person(name, age) {
        this.name = name; // Присваиваем свойству `name` значение параметра `name`
        this.age = age;   // Присваиваем свойству `age` значение параметра `age`
        this.yearOfBirth = bornYear; // Присваиваем свойству `yearOfBirth` ссылку на функцию bornYear
    }
    ```

   Здесь создаётся конструктор для объекта `person`, где:
   - `this.name` — это имя объекта.
   - `this.age` — возраст объекта.
   - **Важный момент**: `this.yearOfBirth = bornYear;` — здесь мы присваиваем свойству объекта ссылку на функцию `bornYear`.

2. **Функция `bornYear`**:
    ```js
    function bornYear() {
        return 2016 - this.age;
    }
    ```

   Это обычная функция, которая вычисляет год рождения, основываясь на возрасте. Однако есть проблема: в этой функции используется `this.age`, но если вызвать её без привязки к объекту, `this` не будет ссылаться на текущий объект.

3. **Создание объекта**:
    ```js
    var p = new person("A", 22);
    ```

    Мы создаём новый объект `p`, где:
    - `p.name = "A"`.
    - `p.age = 22`.
    - `p.yearOfBirth` теперь ссылается на функцию `bornYear`.

4. **Вызов метода**:
    ```js
    document.write(p.yearOfBirth());
    ```

   Здесь мы пытаемся вызвать метод `yearOfBirth` через объект `p`. В теории, он должен вернуть год рождения, но будет ошибка, потому что в функции `bornYear` `this` указывает не на объект `p`, а на глобальный объект, где свойства `age` нет.

### Что значит **вызовите метод по свойству, а не по имени функции**?

Это значит, что вместо вызова функции напрямую (например, `bornYear()`), нужно использовать свойство объекта. В данном случае, ты правильно вызываешь метод через свойство объекта: `p.yearOfBirth()`.

Но, чтобы это заработало, нужно правильно привязать `this` к текущему объекту. Для этого нужно либо переписать функцию как метод объекта, либо воспользоваться стрелочной функцией.

### Исправление:

Чтобы всё заработало правильно, нужно убедиться, что `this` в функции `bornYear` ссылается на объект. Есть несколько способов это сделать.

#### Способ 1: Определить функцию `bornYear` как метод объекта

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = function() {
        return 2016 - this.age; // Здесь `this` указывает на объект `p`
    };
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Теперь метод `yearOfBirth` является частью объекта, и `this` будет ссылаться на объект `p`, поэтому всё сработает корректно.

#### Способ 2: Использовать стрелочную функцию

Стрелочные функции автоматически привязывают контекст `this` к текущему объекту.

```js
function person(name, age) {
    this.name = name;
    this.age = age;
    this.yearOfBirth = () => 2016 - this.age; // Стрелочная функция
}

var p = new person("A", 22);
document.write(p.yearOfBirth()); // Выведет: 1994
```

Стрелочная функция захватывает контекст `this` объекта `p`, поэтому всё работает правильно.

### Вывод:

- **Вызов по свойству** означает, что ты должен использовать `p.yearOfBirth()` вместо прямого вызова `bornYear()`, чтобы метод работал как часть объекта.
- Чтобы код работал корректно, `this` в методе должен ссылаться на текущий объект. Это можно сделать, объявив метод внутри конструктора или используя стрелочную функцию.

Теперь код будет работать как надо!

### [Назад к оглавлению](#back)


<a name="qviz_1"></a>
## Квиз Модуля 1
1. Свойства объекта похожи на переменные; методы похожи на:

- [ ] операторы
- [x] функции
- [ ] свойства
- [ ] условные операторы

2. Каков результат следующего выражения?
```js
var myString = "abcdef";
document.write(myString.length);
```
Ответ: 6

3. Завершите выражение для создания конструктора объекта, учитывая, что **height** и **weight** являются свойствами, а **calculate** является методом для данного объекта:
```js
function mathCalc (height, weight) {
  this.height = [height];
  this.weight = [weight];
  this.sampleCalc = [calculate];
}
// *в квадратных скобках [] указаны места, куда нужно было вставить недостающие части выражения. Скобки не учитываются.
```

### [Назад к оглавлению](#back)


<a name="qviz_1_pract"></a>
## Менеджер контактов
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ 

Вы работаете над приложением Менеджер контактов.

Вы создали конструктор объекта `contact`, который имеет два аргумента, `name` и `number`.

Вам нужно добавить метод `print()` к объекту, который будет выводить данные контакта в консоль в следующем формате: `name: number`

Данный код объявляет два объекта и вызывает их методы `print()`. Завершите код, определив метод `print()` для объектов.

> Обратите внимание на пробел после двоеточия при выводе контактных данных.
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);
a.print();
b.print();
```

Решение способом **определения функции как метод объекта** (пример решения способом стрелочной функции [был описан выше](#gpt_comment_1)):
```js
function contact(name, number) {
    this.name = name;
    this.number = number;
    // Определить функцию print как метод объекта
    this.print = function() {
        return name + ": " + number;
    }
}

var a = new contact("David", 12345);
var b = new contact("Amy", 987654321);

// Вывести метод print объекта contact в консоль
console.log(a.print());
console.log(b.print());
```

### [Назад к оглавлению](#back)


<a name="core_obj"></a>
# Core Objects

<a name="arrays"></a>
## Массивы

### Массивы в JavaScript
Массивы хранят несколько значений в одной переменной. 

Чтобы сохранить названия трех курсов, вам потребуются три переменные.
```js
var course1 ="HTML";
var course2 ="CSS";
var course3 ="JS";
```

Но что, если у вас было 500 курсов? Решение - **array (массив)**.
```js
var courses = new Array("HTML", "CSS", "JS");
```

Этот синтаксис объявляет массив с именем **courses**, который хранит три значения или элемента.

Два ключевых слова для создания массива:
- **new**
- **Array**

### Обращение к элементам массива
Вы обращаетесь к элементу массива, указывая **номер индекса** в **квадратных скобках**. 

Следующе утверждение обращается к значению первого элемента в `courses` и изменяет значение второго элемента.
```js
var courses = new Array("HTML", "CSS", "JS");
var course = courses[0]; // Обращение к HTML
courses[1] = "C++"; // Изменение второго элемента
```

- **[0]** - первый элемент в массиве. 
- **[1]** - второй элемент. 

> Индексы массива начинаются с ноля - `0`.

Результатом выполнения следующего кода - станет `6`:
```sql
var arr = new Array(3, 6, 8);
document.write(arr[1]);
```

### Доступ к массиву
Попытка доступа к индексу за пределами массива возвращает значение `undefined`, что буквально означает - неопределено. Таким выводом будет итог работы следующего кода:
```js
var courses = new Array("HTML", "CSS", "JS"); 
document.write(courses[10]);
```

Наш массив `courses` имеет всего три элемента, поэтому десятый индекс, который является 11-м элементом, не существует (не определен).

### [Назад к оглавлению](#back)


<a name="pract_3"></a>
## Пушистые блинчики (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Массивы 
Представленный вам массив представляет собой меню завтраков, доступных в отеле.

Шеф-повар решил заменить один из вариантов на "Fluffy Pancakes" (Пушистые блинчики).

Напишите программу, чтобы взять индекс как ввод, заменить элемент с этим индексом на "Fluffy Pancakes" и вывести новое меню в консоль в виде массива.
```js
Пример ввода:
2

Пример вывода:
[
  'Cinnamon Doughnuts',
  'Waffles',
  'Fluffy Pancakes',
  'Chorizo Burrito',
  'French Toast'
]
```
Элемент с индексом `2` был заменен в выходном массиве.

Помните, что первый элемент массива имеет индекс `0`.
```js
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    // замените соответствующий элемент на 'Fluffy Pancakes'.
    
    // вывести menu в консоль
    
}
```

Решение:
```sql
function main() {
    var breakfasts = ['Cinnamon Doughnuts', 'Waffles', 'Granola', 'Chorizo Burrito', 'French Toast'];
    var index = parseInt(readLine(), 10)
   
    //замените соответствующий элемент на "Fluffy Pancakes".
    breakfasts[index] = "Fluffy Pancakes";
    //вывести меню на консоль
    console.log(breakfasts);
}
```

### [Назад к оглавлению](#back)


<a name="another_make_array"></a>
## Другие способы создания массивов
### Создание массивов
Вы также можете объявить массив, указать количество элементов, которые он будет хранить, и добавить элементы позже.

Следующий код выведет `"JS"`:
```js
var courses = new Array(3);
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";

document.write(courses[2]);
```

Массив - это особый тип объекта.
- **Массив** использует **числа** для доступа к своим элементам, а 
- **Объект** использует **имена** для доступа к своим членам.

### Создание массивов
Массивы в JavaScript динамические, поэтому вы можете объявить массив и не передавать никаких аргументов с конструктором `Array()`. Затем вы можете динамически добавлять элементы:
```js
var courses = new Array();
courses[0] = "HTML";
courses[1] = "CSS";
courses[2] = "JS";
courses[3] = "C++";

document.write(courses[2]);
```

Вы можете добавить столько элементов, сколько вам нужно.

### Литерал массива
Для большей простоты, удобочитаемости и скорости выполнения, вы также можете объявлять массивы, используя синтаксис **литерала массива**.
```js
var courses = ["HTML", "CSS", "JS"]; 

document.write(courses[2]);
```
Такой синтаксис приводит к созданию такого же массива, как и тот, который создается с использованием нового синтаксиса `Array()`. Код выдаст результат - "JS".

Вы можете получить доступ и изменить элементы массива, используя номер индекса, как вы делали раньше.

Синтаксис **литерала массива** является **рекомендуемым** способом объявления массивов.

Вводя `var example = new Array();`, мы создаем пустой массив, который можно заполнить **в любое время позже**.

### [Назад к оглавлению](#back)


<a name="props_methods_array"></a>
## Свойства и методы массива

### Свойство length
У массивов JavaScript есть полезные встроенные свойства и методы.

Свойство `length` массива возвращает количество его элементов. Следующий код вернет число 9:
```js
var courses = ["HTML", "CSS", "JS"];
document.write(courses.length);
```

Свойство `length` всегда на одну единицу больше, чем самый высокий индекс массива.

Если массив пуст, свойство `length` возвращает ноль - `0`.

Массив имеет свойство `length` - потому что является объектом.

### Объединение массивов
Метод `concat()` в JavaScript позволяет вам объединять массивы и создавать совершенно новый массив. 
```js
var c1 = ["HTML", "CSS"];
var c2 = ["JS", "C++"];
var courses = c1.concat(c2);

document.write(courses[2]);
```

Массив `courses`, который получается в результате, содержит 4 элемента (HTML, CSS, JS, C++). На выходе получаем неизменый JS. 

Операция `concat` не влияет на массивы `c1` и `c2` - она возвращает результат конкатенации в виде **нового массива**.

Таким образом метод `concat` принимает два массива и объединяет их в один новый массив

### [Назад к оглавлению](#back)


<a name="pract_4"></a>
## Повысь уровень! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Свойства и методы массивов
Игрок получает очки после прохождения каждого уровня игры.

Данная программа принимает число пройденных уровней в качестве входных данных, за которыми следуют набранные за каждый уровень очки, и создает соответствующий массив очков.

Дополните программу, чтобы рассчитать и вывести на консоль сумму всех набранных очков.
```js
Пример ввода
3
1
4
8

Пример вывода
13
```

Объяснение

Первый ввод представляет собой число пройденных уровней, -- в этом случае, 3 (размер создаваемого массива). Следующие 3 ввода -- это очки, начисленные игроку за прохождение каждого уровня. Игрок набрал 1+4+8 очков за 3 пройденных уровня, что затем выводится.

Обратите внимание, что первое введенное число может быть использовано в качестве длины массива.
```js
function main() {
    // Получение числа пройденных уровней
    var levels = parseInt(readLine(),10);
    var points = new Array();
    
    var count = 0;
    while(count<levels){
        var elem = parseInt(readLine(),10);
        points[count] = elem;
        count++;
    }
    
    var sum = 0;
    //вычислить сумму баллов
     
    
    //output
    console.log(sum);
}
```

### [Назад к оглавлению](#back)


<a name="pract_4_gpt"></a>
## Решение от GPT-4o

Решение этой задачи заключается в том, чтобы просуммировать очки, введенные пользователем, и вывести итоговое значение. Давай разберем пошагово, что нужно сделать в этой программе.

### Задача:
1. Пользователь вводит количество уровней.
2. Затем вводит очки за каждый уровень.
3. Нужно создать массив, в который будут записаны эти очки.
4. После этого нужно просуммировать все очки и вывести результат.

### Разбор программы:

```js
function main() {
    // Получаем количество уровней (размер массива)
    var levels = parseInt(readLine(), 10);
    
    // Создаем пустой массив для очков
    var points = new Array();
    
    var count = 0;
    
    // Читаем и записываем очки в массив
    while(count < levels) {
        var elem = parseInt(readLine(), 10);
        points[count] = elem;  // Записываем очки в массив
        count++;
    }
    
    // Теперь нужно посчитать сумму всех очков
    var sum = 0;
    for (var i = 0; i < points.length; i++) {
        sum += points[i];  // Добавляем каждое значение из массива к сумме
    }
    
    // Выводим итоговую сумму
    console.log(sum);
}
```

### Пояснение решения:
1. **Получение количества уровней**:  
   Мы начинаем с того, что принимаем первое число, которое указывает количество уровней.  
   `var levels = parseInt(readLine(), 10);` — эта строка превращает ввод пользователя в целое число (количество уровней).
   
2. **Создание массива для очков**:  
   `var points = new Array();` — создаём пустой массив, в который будем добавлять очки за каждый уровень.

3. **Чтение очков и их добавление в массив**:  
   Мы используем цикл `while`, чтобы прочитать очки за каждый уровень:
   ```js
   while(count < levels) {
       var elem = parseInt(readLine(), 10);
       points[count] = elem;  // Записываем очки в массив
       count++;
   }
   ```
   В этом блоке происходит следующее:
   - Вводим очередное число (очки за уровень).
   - Записываем это число в массив `points` на позицию `count`.
   - Увеличиваем счетчик `count`, чтобы перейти к следующему элементу массива.

4. **Вычисление суммы очков**:  
   После того как все очки введены, мы должны их просуммировать. Для этого используем цикл `for`:
   ```js
   for (var i = 0; i < points.length; i++) {
       sum += points[i];  // Добавляем каждое значение из массива к сумме
   }
   ```
   Этот цикл проходит по всем элементам массива `points` и добавляет их к переменной `sum`, которая изначально равна 0.

5. **Вывод результата**:  
   После того как сумма всех очков посчитана, выводим результат:
   ```js
   console.log(sum);
   ```

### Пример работы программы:
Если ввести следующие данные:
```
3
1
4
8
```

Программа:
- Считает количество уровней (`3`).
- Считает очки за каждый уровень (`1`, `4`, `8`).
- Вычисляет сумму: `1 + 4 + 8 = 13`.
- Выведет `13`.

### Заключение:
Мы использовали цикл для чтения очков и суммирования значений. Важно правильно работать с массивами и циклами, чтобы корректно обработать ввод и посчитать результат.

### Про выражение while(count < levels)

Выражение `while(count < levels)` используется для того, чтобы цикл выполнялся **до тех пор**, пока значение переменной `count` меньше, чем количество уровней `levels`.

### Пояснение:
- **`count`** — это счётчик, который отслеживает количество введённых очков за уровни.
- **`levels`** — это количество уровней, которое ввёл пользователь, и, соответственно, это количество очков, которое нужно ввести.

Цикл `while` работает по следующему принципу:
- Выполняется, пока условие в скобках `count < levels` возвращает `true`.
- Как только счётчик `count` достигает значения `levels` (то есть мы ввели нужное количество очков), условие становится `false`, и цикл завершается.

### Почему используется `while(count < levels)`:
1. **Количество итераций**: Это условие гарантирует, что цикл выполнится **ровно столько раз**, сколько уровней (и, соответственно, очков) нужно обработать.
2. **Чтение данных**: После каждой итерации счётчик `count` увеличивается (`count++`), что означает, что вводится одно новое очко. Когда введено ровно столько очков, сколько уровней, цикл завершится.
3. **Гибкость**: Если пользователь введёт любое другое количество уровней, цикл корректно адаптируется к этому числу и будет работать для любого количества очков.

### Пример:
- Допустим, пользователь ввёл `3` как количество уровней.
- Тогда цикл начнётся с `count = 0` и будет продолжаться до тех пор, пока `count < 3`. То есть он выполнится для `count = 0`, `count = 1` и `count = 2`.
- Как только `count` станет равен `3`, условие перестанет быть истинным, и цикл завершится.

Если бы вместо `while(count < levels)` мы использовали другое условие (например, `while(true)`), цикл мог бы стать бесконечным или некорректно завершаться.

### [Назад к оглавлению](#back)


<a name="asoc_arriv"></a>
## Ассоциативные массивы

Хотя многие языки программирования поддерживают массивы с именованными индексами (текст вместо чисел), называемые **ассоциативными массивами** - JavaScript их **не поддерживает**.

Однако вы все еще можете использовать синтаксис именованных массивов, который создаст объект.

Например:
```js
var person = []; //empty array
person["name"] = "John";
person["age"] = 46;
document.write(person["age"]);
```

Теперь `person` рассматривается как объект, а не как массив. 
Именованные индексы `name` и `age` становятся свойствами объекта `person`.

Поскольку массив `person` рассматривается как объект, стандартные методы и свойства массива дадут неправильные результаты. Например, `person.length` вернет ноль - `0`.

В **ассоциативных массивах**, индексные номера заменяются на **строки**.

Помните, что JavaScript **не поддерживает** массивы с именованными индексами.
- В JavaScript массивы всегда используют номерные индексы.
- Лучше использовать **объект**, когда вы хотите, чтобы индекс был **строкой** (текст).
- Используйте **массив**, когда вы хотите, чтобы индекс был **числом**.
- Если вы используете именованный индекс, JavaScript переопределит массив в стандартный объект.

Чтобы использовать ассоциативные массивы, "ассоциированное" имя помещается **вквадратные скобки** `[]`.

### [Назад к оглавлению](#back)


<a name="math_obj"></a>
## Математический объект

Объект **Math** позволяет вам выполнять математические задачи и включает в себя несколько свойств.

|Property |Description |Перевод описания |
|---------|------------|--|
|**E** |Euler's constant |Постоянная Эйлера |
|**LN2** |Natural log of the value 2 |Натуральный логарифм значения 2 |
|**LN10** |Natural log of the value 10 |Натуральный логарифм значения 10 |
|**LOG2E** |The base 2 log of Euler's constant (E) |Логарифм константы Эйлера (E) по основанию 2 |
|**LOG10E** |The base 10 log of Euler's constant (E) |Логарифм константы Эйлера (E) по основанию 10 |
|**PI** |Returns the constant Pi |Возвращает число пи (3,14) |

Например результатом отображения в браузере следующего кода будет вывод числа Пи: 3.141592653589793
```js
document.write(Math.PI);
```

**Math** не имеет конструктора. Нет необходимости сначала создавать объект `Math`.

### Методы объекта Math
Объект **Math** содержит ряд методов, которые используются для вычислений:

|Method |Description |Перевод |
|--|--|--|
|**abs(x)** |Returns the absolute value of x  |Возвращает абсолютное значение x  |
|**acos(x)** |Returns the arccosine of x, in radians  |Возвращает арккосинус x, в радианах  |
|**asin(x)**  |Returns the arsine of x, in radians |Возвращает арксинус x, в радианах  |
|**atan(x)** |Returns the arctangent of x as a numeric value between [-PI/2] and [PI/2] radians  |Возвращает арктангенс x в виде числового значения между [-PI/2] и [PI/2] радиан  |
|**atan2(y,x)** |Returns the arctangent of the quotient of its arguments  |Возвращает арктангенс колличества своих аргументов  |
|**ceil(x)**  |Returns x, rounded upwards to the nearest integer  |Возвращает x, округленное в большую сторону до ближайшего целого числа  |
|**cos(x)** |Returns the cosine of x (x is in radians)  |Возвращает косинус x (x в радианах)  |
|**exp(x)** |Returns the value of E*  |Возвращает значение E*  |
|**floor(x)**  |Returns x, rounded downwards to the nearest integer  |Возвращает x, округленное в меньшую сторону до ближайшего целого числа  |
|**log(x)** |Returns the natural logarithm (base E) of x  |Возвращает натуральный логарифм (основание E) от x  |
|**max(x,y,z,...,n)** |Returns the number with the highest value  |Возвращает число с наибольшим значением  |
|**min(x,y,z,...,n)** |Returns the number with the lowest value  |Возвращает число с наименьшим значением  |
|**pow(x,y)** |Returns the value of x to the power of y  |Возвращает значение x в степени y  |
|**random()** |Returns a random number between 0 and 1  |Возвращает случайное число от 0 до 1  |
|**round(x)** |Rounds x to the nearest integer  |Округляет x до ближайшего целого числа  |
|**sin(x)** |Returns the sine of x (x is in radians) |Возвращает синус x (x в радианах)  |
|**sqrt(x)** |Returns the square root of x  |Возвращает квадратный корень из x  |
|**tan(x)** |Returns the tangent of an angle |Возвращает тангенс угла |

Например, следующий код вычислит **квадратный корень** числа:
```js
var number = Math.sqrt(4); 
document.write(number);
```

Чтобы получить случайное число от 1 до 10, используйте `Math.random()`, который дает вам число от 0 до 1. Затем умножьте число на 10, а затем воспользуйтесь функцией `Math.ceil()`: `Math.ceil(Math.random() * 10)`.

### [Назад к оглавлению](#back)


<a name="pract_5"></a>
## Какой век? (Практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### Объект Math

Создайте функцию, которая возвращает век в зависимости от года, заданного в качестве параметра.
```js
Пример ввода:
1993

Пример вывода:
20
```

#### Подсказка

Вам нужно разделить 1993 на 100: 1993/100 = 19.93, затем округлить его до ближайшего целого числа, которое в этом случае равно 20.

Используйте `Math.ceil(x)`, который возвращает `x`, округленное вверх до ближайшего целого числа:
```js
function main() {
    var year = parseInt(readLine(), 10);  // Получаем значение года
    
    // Выводим результат, вызывая функцию calcCent с аргументом year
    console.log(calcCent(year));
}

// Дополняем функцию
function calcCent(year) {
    year = year / 100;  // Делим год на 100
    return Math.ceil(year);  // Округляем вверх до целого числа и возвращаем результат
}
```

Пояснение:

1. В функции `main()` вызывается функция `calcCent()` и передаётся переменная `year` как аргумент: `calcCent(year)`.
2. Функция `calcCent()` принимает этот аргумент: `function calcCent(year)`.
3. Внутри функции `calcCent()` вы делите year на 100 и округляете результат вверх с помощью `Math.ceil()`.
4. Округлённое значение возвращается через `return`, чтобы вывести его в `console.log`.

Объект Math
Давайте создадим программу, которая будет просить пользователя ввести число и выводить его квадратный корень.
```js
var n = prompt("Enter a number", "");
var answer = Math.sqrt(n);
alert("The square root of " + n + " is " + answer);
```

Результат:

![pic1](https://lecontent.sololearn.com/material-images/bd4171a04aef463a9d096c398acba66a-2770.png)

Введите число, например 64.
![pic2](https://lecontent.sololearn.com/material-images/420f29528f3b4004a236197bfc56ff56-2771.png)

**Math** - это удобный объект. Вы можете сэкономить много времени, используя Math, вместо написания своих собственных функций каждый раз.

Результатом `Math.sqrt(81);` - будет девять.

### [Назад к оглавлению](#back)


<a name="date_obj"></a>
## Объект Date
### setInterval
Метод **setInterval()** вызывает функцию или вычисляет выражение через указанные интервалы (в миллисекундах). 

Он продолжит вызывать функцию до тех пор, пока не будет вызван **clearInterval()** или окно не будет закрыто.
```js
function myAlert() {
    alert("Hi");
}
setInterval(myAlert, 3000);
```

Это вызовет функцию **myAlert** каждые 3 секунды (1000 мс = 1 секунда).

Напишите имя функции без скобок при передаче его в метод **setInterval**.

Например код чтобы вызвать функцию **calc()** каждые 2 секунды:
```js
setInterval(calc, 2000);
```

### Объект Date
Объект **Date** позволяет нам работать с датами.

Дата состоит из года, месяца, дня, часа, минуты, секунды и миллисекунд.

Используя **new Date()**, создайте новый объект даты с текущей датой и временем.
```js
var d = new Date();
//d сохраняет текущую дату и время
```

Другие способы инициализации дат позволяют создавать новые объекты даты из указанной даты и времени.
```js
new Date(milliseconds)
new Date(dateString)
new Date(year, month, day, hours, minutes, seconds, milliseconds)
```

Даты в JavaScript рассчитываются в миллисекундах с 01 января 1970 года в 00:00:00 по Всемирному времени (UTC). Один день содержит 86,400,000 миллисекунд.

Например:
```js
//Fri Jan 02 1970 00:00:00
var d1 = new Date(86400000);

//Fri Jan 02 2015 10:42:00
var d2 = new Date("January 2, 2015 10:42:00");

//Sat Jun 11 1988 11:42:00
var d3 = new Date(88,5,11,11,42,0,0);
```

JavaScript считает месяцы от 0 до 11. Январь - это **0**, а декабрь - **11**.

Объекты Date являются статическими, а не динамическими. Время на компьютере идет, но объекты даты не меняются, после их создания.

### Методы Date
Когда создается объект `Date`, ряд методов позволяет выполнять с ним операции. 

|Method |Description |Перевод |
|-------|------------|--------|
|getFullYear() |gets the year |получает год |
|getMonth() |gets the month |получает месяц |
|getDate() |gets the day of the month |получает день месяца |
|getDay() |gets the day of the week |получает день недели |
|getHours() |gets the hour |получает час |
|getMinutes() |gets the minutes |получает минуту |
|getSeconds() |gets the seconds |получает секунду |
|getMilliseconds() |get the milliseconds |получает миллисекунду |

Например:
```js
var d = new Date();
var hours = d.getHours();

console.log(hours);
```

Давайте создадим программу, которая выводит текущее время в браузер каждую секунду.
```js
function printTime() {
    var d = new Date();
    var hours = d.getHours();
    var mins = d.getMinutes();
    var secs = d.getSeconds();
    document.body.innerHTML = hours+":"+mins+":"+secs;
}
setInterval(printTime, 1000);
```

Мы объявили функцию `printTime()`, которая получает текущее время из объекта даты и выводит его на экран.

Затем мы вызвали эту функцию каждую секунду, используя метод `setInterval`.

Свойство `innerHTML` устанавливает или возвращает HTML-содержимое элемента.

В нашем случае, мы изменяем HTML-содержимое тела нашего документа. Это перезаписывает содержимое каждую секунду, вместо того чтобы повторно выводить его на экран.

Еще раз пример инициализации объекта даты, представляющего текущую дату и время:
```
var date = new Date();
```

### [Назад к оглавлению](#back)


<a name="pract_6"></a>
### Понедельник до Воскресенья (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

Объект Date 

Программа, которую вы получили, принимает на вход год, месяц и день.

Создайте функцию, которая принимает их в качестве аргументов и возвращает соответствующий день недели.
```js
Пример ввода:
1993
7
12

Пример вывода:
Thursday
```
>Подсказка: Данный код создает объект Date из параметров. Используйте метод `getDay()` объекта date для получения индекса, затем используйте его в данном массиве имен для возвращения названия дня.
```js
function main() {
   var year = parseInt(readLine(), 10);
   var month = parseInt(readLine(), 10);
   var day = parseInt(readLine(), 10);
    
   console.log(getWeekDay(year, month, day)); 
}

function getWeekDay(year, month, day) {
   var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
   var d = new Date(year, month, day);
    //complete the function
    
}
```

<a name="pract_6_gpt"></a>
### Решение от GPT-4o

Вот комментарии к твоему коду:

```js
function main() {
   var year = parseInt(readLine(), 10);  // Чтение года и преобразование его в целое число
   var month = parseInt(readLine(), 10);  // Чтение месяца и преобразование его в целое число (в этом коде месяц начинается с 1)
   var day = parseInt(readLine(), 10);  // Чтение дня и преобразование его в целое число
    
   console.log(getWeekDay(year, month, day));  // Вызов функции getWeekDay с переданными значениями года, месяца и дня
}

function getWeekDay(year, month, day) {
   var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];  // Массив названий дней недели, где 0 = Воскресенье и 6 = Суббота
   
   // Создаём объект Date, передавая год, месяц и день.
   // Обратите внимание, что объект Date в JavaScript автоматически преобразует месяц, начиная с 0, поэтому здесь корректировка не нужна.
   var date = new Date(year, month, day);  
   
   var day = date.getDay();  // Получаем день недели (от 0 до 6) с помощью метода getDay() объекта Date
   return names[day];  // Возвращаем название дня недели, используя индекс массива names
}
```

### Пояснение:
- **Date**: Объект `Date` в JavaScript принимает год, месяц и день, но месяц начинается с 0 (то есть январь — это 0, февраль — 1 и так далее), поэтому переданный месяц уменьшаем на 1.
- **getDay()**: Этот метод возвращает индекс дня недели, начиная с 0 для воскресенья и до 6 для субботы. Этот индекс используется для получения правильного названия дня недели из массива `names`.

### [Назад к оглавлению](#back)


<a name="exam_2"></a>
## Викторина модуля 2

1. Учитывая массив ниже, пожалуйста, завершите выражение, чтобы было выдано предупреждение с "яблоко".
```js
var fruits = new Array("pear", "orange",
"apple", "grapefruit");
alert(fruits[2]);
```
2. Каков результат следующего выражения?
```js
alert(Math.sqrt(36));
```
Ответ: 6

3. Пожалуйста, заполните пропуски, чтобы вывести текущие минуты.
```js
var date = new Date();
alert(date.getMinutes());
```

4. Какой результат выполнения этого кода?
```js
var arr = new Array("a", "b", "c"); 
alert(arr[1]);
```
Ответ: b

5. Перетащите и отпустите из приведенных ниже вариантов, чтобы получить уведомление с значением константы PI.
```js
alert(Math.PI);
```

### [Назад к оглавлению](#back)


<a name="pract_7"></a>
## Менеджер магазина (практическое упражнение)

Вы работаете над программой Менеджер магазина, которая хранит цены в массиве.

Вам нужно добавить функционал увеличения цен на заданную сумму.

Переменная increase берется из пользовательского ввода. Вам нужно увеличить все цены в данном массиве на эту сумму и вывести в консоль получившийся массив.

> Используйте цикл для итерации по массиву и увеличения всех элементов.
```js
function main() {
    var increase = parseInt(readLine(), 10);
    var prices = [98.99, 15.2, 20, 1026];
    //your code goes here
    
}
```

<a name="pract_7_gpt"></a>
### Решение от GPT-4o
Давай разберём решение этой задачи пошагово. Нужно пройти по каждому элементу массива `prices`, увеличить его на значение переменной `increase`, которую мы получаем из пользовательского ввода, и затем вывести обновлённый массив.

### Решение:

1. **Чтение значения для увеличения**:  
   В переменную `increase` сохраняется число, которое ввёл пользователь. Это число будет добавлено ко всем элементам массива `prices`.

2. **Цикл для обхода массива**:  
   Для того чтобы увеличить каждую цену, мы будем использовать цикл `for`. Цикл проходит по каждому элементу массива и добавляет к нему значение `increase`.

3. **Обновление массива**:  
   Внутри цикла каждый элемент массива обновляется — к его текущему значению добавляется введённое пользователем число.

4. **Вывод обновлённого массива**:  
   После того как все цены обновлены, мы выводим весь массив на консоль.

### Код с подробным объяснением:

```js
function main() {
    // Чтение значения, на которое будем увеличивать цены
    var increase = parseInt(readLine(), 10);
    
    // Массив с исходными ценами
    var prices = [98.99, 15.2, 20, 1026];
    
    // Цикл для обхода каждого элемента массива
    for (var i = 0; i < prices.length; i++) {
        prices[i] += increase;  // Увеличиваем текущую цену на значение increase
    }
    
    // Выводим обновлённый массив
    console.log(prices);
}
```

### Пояснение:
1. **`var increase = parseInt(readLine(), 10);`**  
   Эта строка получает число от пользователя и преобразует его в целое число с помощью функции `parseInt()`. Пользователь вводит, на сколько нужно увеличить цены.

2. **`for (var i = 0; i < prices.length; i++) { ... }`**  
   Это стандартный цикл `for`, который проходит по каждому элементу массива `prices`. Внутри цикла:
   - Мы используем индекс `i`, чтобы обратиться к каждому элементу массива.
   - Выражение `prices[i] += increase;` увеличивает значение текущего элемента массива на заданную сумму `increase`.

3. **`console.log(prices);`**  
   После того как цикл завершён и все цены обновлены, мы выводим обновлённый массив с новыми значениями.

### Пример работы программы:

Если пользователь введёт `10` как значение увеличения, то программа обновит массив следующим образом:
Исходные цены:
```
[98.99, 15.2, 20, 1026]
```
После увеличения на `10`:
```
[108.99, 25.2, 30, 1036]
```

Вывод программы будет:
```
[108.99, 25.2, 30, 1036]
```

### Заключение:
Мы использовали цикл `for` для того, чтобы пройти по массиву, и обновили каждый элемент массива на заданное значение.

### [Назад к оглавлению](#back)


<a name="dom_events"></a>
# DOM & События

<a name="what_is_dom"></a>
## Что такое DOM?

Когда вы открываете любую веб-страницу в браузере, HTML страницы загружается и визуально отображается на экране.

Для этого браузер создает **Document Object Model** этой страницы, который представляет собой объектно-ориентированную модель его логической структуры.

**DOM** HTML документа может быть представлен в виде вложенного набора блоков:

![dom](https://lecontent.sololearn.com/material-images/643c1ed149ec4e239be6852f7b00deb5-2773.png)

JavaScript можно использовать для динамического управления DOM страницы с целью добавления, удаления и изменения элементов.

### Дерево DOM
DOM представляет документ в виде структуры дерева.

HTML элементы становятся взаимосвязанными узлами в дереве.

Все эти узлы в дереве имеют какие-то отношения друг с другом. Узлы могут иметь дочерние узлы. Узлы на одном уровне дерева называются братьями и сестрами.

Например, рассмотрите следующую структуру:
![dom2](https://lecontent.sololearn.com/material-images/66db5ddcc4714483bf7b5622fd267c3b-2773.png)

Для приведенного выше примера:

- &lt;html&gt; имеет двух детей (&lt;head&gt;, &lt;body&gt;);
- &lt;head&gt; имеет одного ребенка (&lt;title&gt;) и одного родителя (&lt;html&gt;);
- &lt;title&gt; имеет одного родителя (&lt;head&gt;) и не имеет детей;
- &lt;body&gt; имеет двух детей (&lt;h1&gt; и &lt;a&gt;) и одного родителя (&lt;html&gt;);

Важно понимать взаимосвязи между элементами в HTML-документе, чтобы иметь возможность манипулировать ими с помощью JavaScript.

В следующем HTML, элемент &lt;p&gt; является родительским:
```js
<body>
  <p><h1>Hi</h1></p>
</body>
```

### Объект document
В JavaScript предопределен **объект document**, который можно использовать для доступа ко всем элементам в DOM.

Иными словами, **объект document** является **владельцем** (или **root**) всех объектов на вашей веб-странице.

Так что, если вы хотите получить доступ к объектам на HTML-странице, вы всегда начинаете с доступа к **объекту document**.

Например:
```js
document.body.innerHTML = "Some text";
```

Поскольку `body` является элементом **DOM**, мы можем получить доступ к нему с помощью **объекта document** и изменить содержимое свойства `innerHTML`.

Свойство `innerHTML` можно использовать почти на всех элементах HTML для изменения их содержимого.

- `innerHTML` - это свойство
- Объект `document` - является корнем DOM

### [Назад к оглавлению](#back)


<a name="elements_select"></a>
## Выбор элементов

Все элементы HTML являются объектами. И как мы знаем, каждый объект имеет свойства и методы.

Объект **document** имеет методы, которые позволяют вам выбирать нужный элемент HTML.

Эти три метода наиболее часто используются для выбора элементов HTML:
```js
//finds element by id
document.getElementById(id)

//finds elements by class name
document.getElementsByClassName(name)

//finds elements by tag name
document.getElementsByTagName(name)
```

В приведенном ниже примере метод `getElementById` используется для выбора элемента с `id="demo"` и изменения его содержимого:
```js
var elem = document.getElementById("demo");
elem.innerHTML = "Hello World!";
```

Пример выше предполагает, что HTML содержит элемент `с id="demo"`, например **&lt;div id="demo"&gt;&lt;/div&gt;**.

Далее пример, выбрать элемент с `id="text"` и изменить его содержимое на "Привет".
```js
var ob = document.getElementById("text");
ob.innerHTML = "Привет";
```

Метод **getElementsByClassName()** возвращает коллекцию всех элементов в документе с указанным именем класса.

Например, если на нашей HTML-странице содержится три элемента с `class="demo"`, следующий код вернет все эти элементы в виде массива: 
```js
var arr = document.getElementsByClassName("demo");
//accessing the second element
arr[1].innerHTML = "Hi";
```

Аналогично, метод **getElementsByTagName** возвращает все элементы с указанным именем тега в виде массива.

В следующем примере получаются все элементы параграфа страницы и изменяется их содержимое:
```html
<p>hi</p>
<p>hello</p>
<p>hi</p>
<script>
var arr = document.getElementsByTagName("p");
for (var x = 0; x < arr.length; x++) {
  arr[x].innerHTML = "Hi there";
}
</script>
```

Скрипт приведет к следующему HTML:
```html
<p>Hi there</p>
<p>Hi there</p>
<p>Hi there</p>
```

Мы использовали свойство **length** массива для прохождения через все выбранные элементы в приведенном выше примере.

Пример: выбрать все элементы `div` и вывести содержимое третьего элемента `div`.
```js
var arr = document.getElementsByTagName("div");
alert(arr[2].innerHTML);
```

### Работа с DOM
У каждого элемента в DOM есть набор свойств и методов, которые предоставляют информацию о их взаимосвязях в DOM:

|Свойство/метод |Описание |
|---------------|---------|
|element.childNodes |возвращает массив дочерних узлов элемента. |
|element.firstChild |возвращает первый дочерний узел элемента. |
|element.lastChild |возвращает последний дочерний узел элемента. |
|element.hasChildNodes |возвращает true, если у элемента есть дочерние узлы, в противном случае false. |
|element.nextSibling |возвращает следующий узел на том же уровне дерева. |
|element.previousSibling |возвращает предыдущий узел на том же уровне дерева. |
|element.parentNode |возвращает родительский узел элемента.

Мы можем, например, выбрать все дочерние узлы элемента и изменить их содержимое. В указанном ниже коде текст обоих абзацев изменяется на "новый текст".
```html
<html>
    <body>
         <div id ="demo">
            <p>some text</p>
            <p>some other text</p>
        </div>
    </body>
</html>
```
```js
function setText() {
    var a = document.getElementById("demo");
     var arr = a.childNodes;
     for(var x=0;x<arr.length;x++) {
       arr[x].innerHTML = "новый текст";
     }
}

//вызов функции с setTimeout, чтобы убедиться, что HTML загружен
setTimeout(setText, 500);
```

Узел в DOM - **НЕ может** иметь несколько родительских узлов.

### [Назад к оглавлению](#back)


<a name="change_elements"></a>
## Изменение элементов
### Изменение атрибутов
Как только вы выбрали элемент(ы), с которыми хотите работать, вы можете изменить их атрибуты. 

Как мы видели в предыдущих уроках, мы можем изменить текстовое содержимое элемента с помощью свойства **innerHTML**.

Аналогично, мы можем изменить атрибуты элементов.

Например, мы можем изменить атрибут **src** изображения: 
```js
<img id="myimg" src="orange.png" alt="" />
<script>
var el = document.getElementById("myimg");
el.src = "apple.png";
</script>
```

Замена ссылки:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <a href="http://www.example.com">Some link</a>
    </body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var el = document.getElementsByTagName('a');
    el[0].href= 'http://www.sololearn.com';
};
```

Практически все атрибуты элемента можно изменить с использованием JavaScript.

Пример: выбрать все изображения на странице и изменить их атрибут **src**.
```js
var arr = document.
    getElementsByTagName("img");
for(var x=0; x<arr.length; x++) {
  arr[x].src = "demo.jpg";
}
```

### Изменение стиля
Стиль элементов HTML также можно изменять с помощью JavaScript.

Все атрибуты стиля можно получить с помощью объекта **style** элемента. 

Например:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <div id="demo" style="width:200px">some text</div>
    </body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var x = document.getElementById("demo");
    x.style.color = 'white';
    x.style.width = '100px';
    x.style.backgroundColor = 'blue'
};
```

Приведенный выше код изменяет **цвета текста**, **заливки** и **ширины** элемента `div`.

Все свойства CSS можно устанавливать и изменять с помощью JavaScript. Просто помните, что вы не можете использовать дефисы (`-`) в названиях свойств: они заменяются версиями **camelCase**, где составные слова начинаются с заглавной буквы.

Например, свойство `background-color` следует обозначать как `backgroundColor`.

Пример: изменить цвет фона всех элементов span на странице.
```js
var s = document.
    getElementsByTagName("span");
for(var x=0; x<s.length;x++) {
  s[x].style.backgroundColor = "#33EA73";
}
```

### [Назад к оглавлению](#back)


<a name="add_del_elements"></a>
## Добавление и удаление элементов
### Создание элементов
Используйте следующие методы для создания новых узлов:
- **element.cloneNode()** клонирует элемент и возвращает получившийся узел.
- **document.createElement(element)** создает новый узел элемента. 
- **document.createTextNode(text)** создает новый текстовый узел.

Например:
```js
var node = document.createTextNode("Some new text");
```

Это создаст новый текстовый узел, но он не появится в документе, пока вы не добавите его к существующему элементу одним из следующих методов:
- **element.appendChild(newNode)** добавляет новый дочерний узел к элементу в качестве последнего дочернего узла.
- **element.insertBefore(node1, node2)** вставляет node1 как дочерний узел перед node2.

Пример:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Название страницы</title>
    </head>
    <body>
        <div id="demo">некое содержимое</div>
    </body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    //создание нового абзаца
    var p = document.createElement("p");
    var node = document.createTextNode("Какой-то новый текст");
    //добавление текста в абзац
    p.appendChild(node);

    var div = document.getElementById("demo");
    //добавление абзаца в div
    div.appendChild(p);
};
```
Это создает новый абзац и добавляет его к существующему элементу div на странице.

Вывод браузера:
>некое содержимое
>
>Какой-то новый текст

Еще пример, как добавить новый элемент **&lt;li&gt;** в неупорядоченный список с **id="list"**.
```js
var el = document.createElement("li");
var txt = document.createTextNode("B");
el.appendChild(txt);
var ul = document.getElementById("list");
ul.appendChild(el);
```

### Удаление элементов
Чтобы удалить элемент HTML, вы должны выбрать родителя элемента и использовать метод **removeChild(node)**.

Например:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <div id="demo">
            <p id="p1">This is a paragraph.</p>
            <p id="p2">This is another paragraph.</p>
        </div>
    </body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var parent = document.getElementById("demo");
    var child = document.getElementById("p1");
    parent.removeChild(child);
};
```

Это удаляет абзац с **id="p1"** со страницы. Ответ браузера:
> This is another paragraph.

Альтернативный способ достижения того же результата - использование свойства **parentNode** для получения родителя элемента, который мы хотим удалить:
```js
var child = document.getElementById("p1");
child.parentNode.removeChild(child);
```
Пример, как можно удалить элемент `node` со страницы (`par` является родительским элементом для `node`).
```js
var par = document.getElementById("par");
var node = document.getElementById("node");
par.removeChild(node);
```

### Замена элементов
Чтобы заменить элемент HTML, используется метод:
```js
element.replaceChild(newNode, oldNode).
```
Например:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <div id="demo">
            <p id="p1">Параграф</p>
            <p id="p2">Другой параграф.</p>
        </div>
    </body>
</html>
```
```js
//включение функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var p = document.createElement("p");
    var node = document.createTextNode("Новый параграф");
    p.appendChild(node);

    var parent = document.getElementById("demo");
    var child = document.getElementById("p1");
    parent.replaceChild(p, child);
};
```
Приведенный выше код создает новый элемент абзаца (Новый параграф), который заменяет существующий абзац **p1** (Параграф). Вывод в браузер:
> Новый параграф
>
>Другой параграф.

Еще раз: для замены узлов используется метод **replaceChild**.

### [Назад к оглавлению](#back)


<a name="criate_animation"></a>
## Создание анимаций

Теперь, когда мы знаем, как выбирать и изменять элементы DOM, мы можем создать простую анимацию.

Давайте создадим простую HTML-страницу с элементом **box**, который будет анимирован с помощью JS. 
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <div id="container">
            <div id="box"> </div>
        </div>
    </body>
</html>
```
```CSS
#container {
    width: 200px;
    height: 200px;
    background: green;
    position: relative;
}
#box {
    width: 50px;
    height: 50px;
    background: red;
    position: absolute;
}
```
Наш элемент `box` находится внутри элемента `container`. Обратите внимание на атрибут `position`, используемый для элементов: для **контейнера** установлено значение `relative`, а для **блока** - значение `absolute`. Это позволит нам создать анимацию относительно контейнера.

![animation](https://lecontent.sololearn.com/material-images/1adf8a760a954b8f85711a3c89d1d756-3032.png)

Мы будем анимировать красный блок, чтобы он переместился к правой стороне контейнера.

Вам нужно быть знакомым с CSS, чтобы лучше понимать предоставленный код.

Чтобы создать анимацию относительно контейнера, атрибут `position` для **контейнера** должен быть установлен на `relative` - относительный.

Чтобы создать анимацию, нам нужно изменять свойства элемента через небольшие промежутки времени. Мы можем достичь этого, используя метод **setInterval()**, который позволяет нам создать таймер и вызывать функцию для повторяющегося изменения свойств через определенные промежутки времени (в миллисекундах). Например:
```js
var t = setInterval(move, 500);
```

Этот код создает таймер, который вызывает функцию `move()` каждые 500 миллисекунд.

Теперь нам нужно определить функцию `move()`, которая изменяет позицию коробки.
```js
// starting position
var pos = 0; 
//our box element
var box = document.getElementById("box");

function move() {
  pos += 1;
  box.style.left = pos+"px"; //px = pixels
}
```
Функция `move()` увеличивает свойство `left` элемента **box** на один каждый раз, когда она вызывается.

У следующего таймера, интервал - 10 секунд:
```js
var t = setInterval(func, 10000);
```

Следующий код определяет таймер, который вызывает функцию `move()` каждые 10 миллисекунд:
```js
var t = setInterval(move, 10)
```

Однако, это заставляет наш квадрат двигаться вправо бесконечно. Чтобы остановить анимацию, когда квадрат достигает конца контейнера, мы добавляем простую проверку в функцию `move()` и используем метод **clearInterval()** для остановки таймера.
```js
function move() {
  if(pos >= 150) {
    clearInterval(t);
  }
  else {
    pos += 1;
    box.style.left = pos+"px";
  }
}
```
Когда атрибут `left` у блока достигает значения `150`, блок достигает конца контейнера, исходя из ширины контейнера 200 и ширины блока 50.

Итоговый код:
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var pos = 0; 
    //элемент нашей коробки
    var box = document.getElementById('box');
    var t = setInterval(move, 10);
  
    function move() {
        if(pos >= 150) {
            clearInterval(t);
        }
        else {
            pos += 1;
            box.style.left = pos+'px';
        }
    }
};
```

Поздравляем, при запуске кода красный квадрат будет двигаться. Вы создали свою первую анимацию!

### [Назад к оглавлению](#back)


<a name="event_handling"></a>
## Обработка событий
### События
Вы можете написать код на JavaScript, который выполняется, когда происходит событие, например, когда пользователь нажимает на элемент HTML, двигает мышь или отправляет форму.

Когда событие происходит на целевом элементе, выполняется функция обработчика. 

Обычные события HTML включают в себя: 
|Событие |Описание
|------|----------
|onclick |происходит, когда пользователь нажимает на элемент
|onload |происходит, когда объект загрузился
|onunload |происходит после выгрузки страницы (для &lt;body&gt;)
|onchange |происходит, когда содержимое элемента формы, выбор или отмеченное состояние изменились (для &lt;input&gt;, &lt;keygen&gt;,&lt;select&gt; и &lt;textareas&gt;)
|onmouseover |происходит, когда указатель перемещается на элемент или при наведении курсора на один из его дочерних элементов
|onmouseout |происходит, когда пользователь перемещает указатель мыши за пределы элемента onmouse или за пределы одного из его дочерних элементов 
|onmousedown |происходит, когда пользователь нажимает кнопку мыши на элементе
|onmouseup |происходит, когда пользователь отпускает кнопку мыши над элементом
|onblur |происходит, когда элемент теряет фокус
|onfocus |происходит, когда элемент получает фокус

Соответствующие события могут быть добавлены к элементам HTML в виде атрибутов. Например: 
```html
<p onclick="someFunc()">некоторый текст</p>
```

Тип функции, который выполняется, когда происходит событие, называется **обработчиком событий**.

### Обработка событий 
Давайте отобразим всплывающее окно с предупреждением **Hi there**, когда пользователь нажимает на кнопку **"Click Me"**: 
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <button onclick="show();">Click Me</button>
    </body>
</html>
```
```js
function show() {
    alert("Hi there");
}
```

Вы можете привязать события почти ко всем HTML элементам.

Еще раз, например, чтобы вызвать `func()` при нажатии на кнопку "Нажмите здесь":
```js
<button onclick="func()">
  Нажмите здесь
</button>
```

### События 
События **onload** и **onunload** срабатывают, когда пользователь заходит на страницу или покидает ее. Они могут быть полезны при выполнении действий после загрузки страницы. 
```js
<body onload="doSomething()">
```

Аналогично, событие **window.onload** можно использовать для выполнения кода после загрузки всей страницы.
```js
window.onload= function() {
   //some code
}
```
Событие **onchange** в основном используется в текстовых полях. Обработчик событий вызывается, когда текст внутри текстового поля изменяется и фокус теряется с элемента. 

В следующем примере после переключения из поля ввода (потери фокуса), введеный текст преобазуется в заглавный:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <input type="text" id="name" onchange="change()">
    </body>
</html>
```
```js
function change() {
    var x = document.getElementById('name');
    x.value = x.value.toUpperCase();
}
```

Важно понимать события, потому что они являются неотъемлемой частью динамических веб-страниц.

Еще пример - вызвать функцию `clear()` после загрузки тела:
```js
<body=onload="clear()">
</body>
```

### Обработчики событий 
Метод **addEventListener()** присоединяет обработчик событий к элементу без перезаписи существующих обработчиков событий. Вы можете добавить много обработчиков событий к одному элементу.

Вы также можете добавить много обработчиков событий одного типа к одному элементу, т.е., два события "click".
```js
element.addEventListener(event, function, useCapture);
```
- Первый параметр - это **тип** события (например, "click" или "mousedown").
- Второй параметр - это **функция**, которую мы хотим вызвать при возникновении события.
- Третий параметр - это булево значение, указывающее, следует ли использовать **всплытие** событий или **захват** событий. Этот параметр необязателен и будет описан в следующем уроке.
> Обратите внимание, что вы не используете префикс "on" для этого события; используйте "click" вместо "onclick".
```js
element.addEventListener("click", myFunction);
element.addEventListener("mouseover", myFunction);

function myFunction() {
  alert("Hello World!");
}
```
Это добавляет два слушателя событий к элементу. Мы можем удалить одного из слушателей:
```js
element.removeEventListener("mouseover", myFunction);
```

Давайте создадим обработчик событий, который удаляет себя после выполнения:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
          <button id="demo">Start</button>
    </body>
</html>
```
```js
//вызов функции в window.onload, чтобы убедиться, что HTML загружен
window.onload = function() {
    var btn = document.getElementById("demo");
    btn.addEventListener("click", myFunction);

    function myFunction() {
        alert(Math.random());
        btn.removeEventListener("click", myFunction);
    }
};
```

После нажатия на кнопку отображается предупреждение с случайным числом и слушатель событий удаляется.

> Версии Internet Explorer 8 и ниже не поддерживают методы **addEventListener()** и **removeEventListener()**. Однако, вы можете использовать метод **document.attachEvent()** для привязки обработчиков событий в Internet Explorer.

### [Назад к оглавлению](#back)


<a name="event_spreading"></a>
## Распространение событий

Существует два способа распространения событий в HTML DOM: **всплытие** и **перехват**.

Распространение событий позволяет определить порядок элементов, когда происходит событие. Если у вас есть элемент &lt;p&gt; внутри элемента &lt;div&gt;, и пользователь кликает на элемент &lt;p&gt;, какое событие "клик" должно быть обработано первым?
- В **всплытии**, событие самого внутреннего элемента обрабатывается первым, а затем событие внешнего элемента. Событие клика элемента &lt;p&gt; обрабатывается первым, за ним следует событие клика элемента &lt;div&gt;.
- В **перехвате**, событие самого внешнего элемента обрабатывается первым, а затем внутреннего. Событие клика элемента &lt;div&gt; обрабатывается первым, за ним следует событие клика элемента &lt;p&gt;.

>Захват идет вниз по DOM.
>
>Всплытие идет вверх по DOM.

### Захват против всплытия 
Метод **addEventListener()** позволяет вам указать тип распространения с помощью параметра **"useCapture"**.
```js
addEventListener(event, function, useCapture)
```
- Значение по умолчанию - **false**, что означает использование распространения события по пути всплытия; 
- когда значение устанавливается в **true**, событие использует распространение по пути перехвата.
```js
//Capturing propagation Захват распространения
elem1.addEventListener("click", myFunction, true); 

//Bubbling propagation Пузырьковое распространение
elem2.addEventListener("click", myFunction, false);
```

Это особенно полезно, когда одно и то же событие обрабатывается для нескольких элементов в иерархии DOM.

Итак, например, чтобы обработать событие клика и использовать захватывающее распространение:
```js
x.addEventListener("click", func, true);
```

### [Назад к оглавлению](#back)


<a name="image_slider"></a>
## Создание слайдера изображений

Теперь мы можем создать пример проекта со слайдером изображений. Изображения будут меняться с помощью кнопок "Следующий" и "Предыдущий".

Теперь давайте создадим наш HTML, который включает в себя изображение и две кнопки навигации: 
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <div>
        <button> Предыдущий </button>
        <img src="http://www.sololearn.com/uploads/slider/1.jpg" width="200px" height="100px" />
            <button> Следующий </button>
        </div>
    </body>
</html>
```

Далее, определим наши образцы изображений в массиве:
```js
var images = [
   "http://www.sololearn.com/uploads/slider/1.jpg", 
   "http://www.sololearn.com/uploads/slider/2.jpg", 
   "http://www.sololearn.com/uploads/slider/3.jpg"
];
```

Мы собираемся использовать три образца изображений, которые мы загрузили на наш сервер. Вы можете использовать любое количество изображений.

Как выглядит массив:
```js
var arr =['A', 'B', 'C'];
```

### Слайдер изображений 
Теперь нам нужно обработать клики по кнопкам "Следующий" и "Предыдущий" и вызвать соответствующие функции для смены изображения.
```html
<div>
  <button [b]onclick="prev()"[/b]> Предыдущий </button>
  <img id="slider"
src="http://www.sololearn.com/uploads/slider/1.jpg" 
    width="200px" height="100px"/>
  <button [b]onclick="next()"[/b]> Следующий </button>
</div>
```

Все вместе:
```html
<!DOCTYPE html>
<html>
    <head>
        <title>Page Title</title>
    </head>
    <body>
        <div>
            <button onclick="prev()"> Предыдущий </button>
            <img id="slider" src="http://www.sololearn.com/uploads/slider/1.jpg" width="200px" height="100px"/>
            <button onclick="next()"> Следующий </button>
        </div>
    </body>
</html>
```
```CSS
button {
    margin-top:30px;
    float:left;
    height:50px;
}
img {
    float:left;
    margin-right:10px;
    margin-left:10px;
}
```
```js
var images = [
    'http://www.sololearn.com/uploads/slider/1.jpg', 
    'http://www.sololearn.com/uploads/slider/2.jpg', 
    'http://www.sololearn.com/uploads/slider/3.jpg'
];
var num = 0;
function next() {
    var slider = document.getElementById('slider');
    num++;
    if(num >= images.length) {
        num = 0;
    }
    slider.src = images[num];
}
function prev() {
    var slider = document.getElementById('slider');
    num--;
    if(num < 0) {
        num = images.length-1;
    }
    slider.src = images[num];
}
```

Переменная `num` содержит текущее изображение. Клики по кнопкам "вперед" и "назад" обрабатываются соответствующими функциями, которые меняют источник изображения на следующее/предыдущее изображение в массиве.

Мы создали функциональный слайдер изображений!

Содержимое параграфа после того, как пользователь кликнет по нему **дважды** - будет равняться **пяти**:
```js
<p id='txt' onclick='test();'>20</p>
<script>
function test() {
  var x=document.getElementById('txt');
  var n = x.innerHTML;
  x.innerHTML = n/2;
}
</script>
```

### [Назад к оглавлению](#back)


<a name="form_checking"></a>
## Проверка Формы

### Валидация формы 
HTML5 добавляет некоторые атрибуты, которые позволяют валидацию формы. Например, атрибут **required** можно добавить к полю ввода, чтобы сделать его обязательным для заполнения.

Более сложную валидацию формы можно выполнить с использованием JavaScript.

Элемент формы имеет событие **onsubmit**, которое можно обработать для выполнения валидации.

Например, давайте создадим форму с двумя полями ввода и одной кнопкой. Текст в обоих полях должен быть одинаковым и не пустым, чтобы пройти валидацию.
```html
<form onsubmit="return validate()" method="post">
    Number: <input type="text" name="num1" id="num1" /><br />
    Repeat: <input type="text" name="num2" id="num2" /><br />
    <input type="submit" value="Submit" />
</form>
```

Теперь нам нужно определить функцию **validate()**:
```js
function validate() {
    var n1 = document.getElementById('num1');
    var n2 = document.getElementById('num2');
    if(n1.value != '' && n2.value != '') {
        if(n1.value == n2.value) {
            return true;
        }
    }
    alert("Значения должны быть равными и не пустыми.");
    return false;
}
```

Мы возвращаем **true** только когда значения не пустые и равны. Форма не будет отправлена, если ее событие **onsubmit** возвращает **false**.

### [Назад к оглавлению](#back)


<a name="qviz_3"></a>
## Квиз Модуль 3

1. Заполните пропуски, чтобы изменить содержание всех тегов абзаца на странице на "SoloLearn".
```js
var arr = document.getElementsByTagName("p");
for(var x=0; x<arr.length; x++) 
{
   arr[x].innerHTML="SoloLearn";
}
```

2. Какой результат выполнения этого кода?
```html
<div id="test">
    <p>some text</p>
</div>
<script>
    var el=document.getElementById("test");
    alert(el.hasChildNodes());
</script>
```
Ответ: верно (true), у &lt;div&gt; есть дочерний элемент.

3. Перетащите и отпустите из предложенных ниже вариантов, чтобы изменить цвет абзаца с **id="p2"** на красный.
```html
<script>
var d = document.getElementById("p2");
d.style.color="red";
</script>
```

4. Можете ли вы обрабатывать несколько событий на одном HTML элементе?

- [ ] Нет
- [x] Да

5. Заполните пустые поля, чтобы при нажатии кнопки отображалось сообщение.
```html
<button onclick="msg()">Click me</button>
<script>
function msg() {
  alert("Hi!");
}
</script>
```

6. Отобразить предупреждение, когда указатель мыши находится над тегом div:
```html
<div onmouseover ="alert('Hi!');">
  поместите указатель мыши надо мной
</div>
```
### [Назад к оглавлению](#back)


<a name="ecma_script"></a>
# ECMAScript

<a name="es6_intro"></a>
## Введение в ES6

### ECMAScript 6 
**ECMAScript** (ES) - это спецификация языка сценариев, созданная для стандартизации JavaScript.

Шестое издание, изначально известное как **ECMAScript 6** (ES6) и позднее переименованное в **ECMAScript 2015**, добавляет значительный новый синтаксис для написания сложных приложений, включая классы и модули, итераторы и циклы for/of, генераторы, стрелочные функции, двоичные данные, типизированные массивы, коллекции (maps, sets и weak maps), обещания (promises), улучшения чисел и математики, отражение (reflection), и прокси.

Другими словами, ES6 является надмножеством JavaScript (ES5). Причина популярности ES6 заключается в том, что он ввел новые соглашения и концепции ООП, такие как классы. 

В этом модуле мы рассмотрим самые важные дополнения к **ES6**. 

Итак, давайте приступим!

### [Назад к оглавлению](#back)


<a name="es6_var_st"></a>
## ES6 Переменные и строки

### var & let 
В ES6 у нас есть три способа объявления переменных: 
```js
var a = 10;
const b = 'hello';
let c = true;
```

Используемый тип объявления переменной,  зависит от необходимой *области видимости*. **Область видимости** - это фундаментальное понятие во всех языках программирования, которое определяет видимость переменной.

**var & let**

В отличие от ключевого слова 
- **var**, которое определяет переменную глобально или локально для всей функции, независимо от области видимости блока, 
- **let** позволяет вам объявлять переменные, область видимости которых ограничена блоком, выражением или высказыванием, в которых они используются.

Например:
```js
if (true) {
    let name = 'Jack';
}
alert(name);
```

В этом случае переменная **name** доступна только в области видимости оператора **if**, потому что она была объявлена как **let**.

Чтобы продемонстрировать разницу в области видимости между **var** и **let**, рассмотрим этот пример:
```js
function varTest() {
    var x = 1;
    if (true) {
        var x = 2;  // та же переменная
        console.log(x);  // 2
    }
    console.log(x);  // 2
}

function letTest() {
    let x = 1;
    if (true) {
        let x = 2;  // другая переменная
        console.log(x);  // 2
    }
    console.log(x);  // 1
}

varTest();
letTest();
```

Одно из лучших применений для **let** в циклах:
```js
for (let i = 0; i < 3; i++) {
    document.write(i);
}
```

Здесь переменная **i** доступна только в области видимости цикла **for**, где она нужна.

> **let** не подвержен **Variable Hoisting**, что означает, что декларации **let** не перемещаются в верх текущего контекста выполнения.

Результатом выполнения следующего кода - будет четыре два (`4 2`).
```js
function letItBe() {
  let v = 2;
  if (true) {
    let v = 4;  
    console.log(v); 
  }
  console.log(v); 
}
letItBe();
```

### const 
**const** переменные имеют такую же область видимости, как переменные, объявленные с помощью **let**. Разница в том, что переменные **const** являются **неизменяемыми** - им не разрешается повторное присвоение.

Например, следующее выражение вызовет исключение: 
```js
const a = 'Hello';
a = 'Bye';
```
>> CONSOLE 
>>
>> TypeError: Assignment to constant variable.
>>>     at &lt;anonymous&gt;:2:3
>>>     at receiveMessage (https://solocode.azurewebsites.net/:127:17)

> **const** также не подвержен **Variable Hoisting**, что означает, что объявления **const** не перемещаются в начало текущего контекста выполнения.

>Также обратите внимание, что код ES6 будет работать только в браузерах, которые его поддерживают. Старые устройства и браузеры, которые не поддерживают ES6, вернут синтаксическую ошибку.

Как создать константу с именем `total` и переменную `i`, которая доступна только внутри цикла:
```js
const total = 100;
let sum = 0; 
for(let i = 0; i < total; i++) {
  sum += i;
}
```

### Шаблонные литералы в ES6 
**Шаблонные литералы** это способ вывода переменных в строке. 

До ES6 нам приходилось разрывать строку, например: 
```js
let name = 'David';
let msg = 'Welcome ' + name + '!';
console.log(msg);
```

ES6 представляет новый способ вывода значений переменных в строках. Тот же код выше может быть переписан следующим образом:
```js
let name = 'David';
let msg = `Welcome ${name}!`;
console.log(msg);
```

Обратите внимание, что шаблонные литералы заключены в символ: 
- **backtick ( ` )** вместо двойных или одинарных кавычек.
- **${expression}** - это плейсхолдер, и он может включать в себя любое выражение, которое будет вычислено и вставлено в шаблонный литерал.

Например:
```js
let a = 8;
let b = 34;
let msg = `The sum is ${a+b}`;
console.log(msg);
```

Пример: вывод "Мы изучаем ES6!".
```js
let n = 6;
let s = 'ES';
let msg = `Мы изучаем ${s + n}!`;
console.log(msg);
```

> Чтобы экранировать обратную кавычку в строковом шаблоне, поставьте обратный слеш \ перед обратной кавычкой.

### [Назад к оглавлению](#back)


<a name="pract_8"></a>
### London is the capital (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

### ES6 Переменные и строки 
Вам нужно создать карточки стран для школьного проекта.

Данная программа принимает на вход название страны и ее столицы.

Завершите функцию, чтобы она возвращала строку в формате, указанном в образце выходных данных:
```js
Пример ввода:
Portugal
Lisbon

Пример вывода:
Name: Portugal, Capital: Lisbon
```
> Используйте шаблонные литералы для вывода переменных в строках.

```js
function main() {
    var country = readLine();
    var capital = readLine();
    
    console.log(countryCard(country, capital));
}

function countryCard(country, capital) {
    //завершите функцию
    //используйте обратный апостроф backtick (``) для литерала шаблона
}
```

Ответ: нужно добавить в функцию литерал шаблона, использующий параметры на входе
```js
`Name: ${country}, Capital: ${capital}` 
```

Полностью код выглядит так:
```js
function main() {
    var country = readLine();
    var capital = readLine();
    
    console.log(countryCard(country, capital));
}

function countryCard(country, capital) {
    //завершите функцию
    //используйте обратный апостроф backtick (``) для литерала шаблона
    output = `Name: ${country}, Capital: ${capital}`;
    return output; 
}
```

### [Назад к оглавлению](#back)


<a name="es6_func"></a>
## Циклы и функции в ES6

В JavaScript мы обычно используем цикл **for** для итерации по значениям в списке:
```js
let arr = [1, 2, 3];
for (let k = 0; k < arr.length; k++) {
    console.log(arr[k]);
}
```
Цикл **for...in** предназначен для итерации по перечисляемым ключам объекта.
```js
let obj = {a: 1, b: 2, c: 3};
for (let v in obj) {
    console.log(v);
}
```
Цикл **for...in** НЕ должен использоваться для итерации по массивам, потому что, в зависимости от движка JavaScript, он может итерировать в произвольном порядке. Кроме того, переменная итерации является строкой, а не числом, поэтому если вы попытаетесь выполнить какие-либо математические операции с переменной, вы будете выполнять конкатенацию строк, а не сложение.

ES6 представляет новый цикл **for...of**, который создает цикл, итерирующий итерируемые объекты.
```js
let list = ["x", "y", "z"];
for (let val of list) {
    console.log(val);
}
```
Во время каждой итерации переменной **val** присваивается соответствующий элемент из списка.

Цикл **for...of** работает также и для других итерируемых объектов, включая **строки**:
```js
for (let ch of "Hello") {
    console.log(ch);
}
```

Цикл **for...of** также работает с недавно введенными коллекциями (**Map**, **Set**, **WeakMap**, и **WeakSet**). Мы узнаем о них в предстоящих уроках.

Обратите внимание, что код ES6 будет работать только в браузерах, которые его поддерживают. Старые устройства и браузеры, которые не поддерживают ES6, вернут ошибку синтаксиса.

### [Назад к оглавлению](#back)


<a name="gpt_comment_2"></a>
### For...in, For...of: коментарий GPT-4o 

Давай разберём функции `for...in` и `for...of` в JavaScript, начиная с их основ и примеров.

### 1. **Цикл `for...in`**

Этот цикл используется для перебора **свойств объекта** или **индексов (ключей) массива**. Он не перебирает значения напрямую, а проходит по **ключам (индексам)**.

#### Как работает:
- В случае с объектом, он перебирает **имена свойств** объекта.
- В случае с массивом, он перебирает **индексы** элементов массива.

#### Пример с объектом:
```js
const person = { name: 'Bob', age: 30, city: 'New York' };

for (let key in person) {
    console.log(key);  // выводит: name, age, city (ключи)
    console.log(person[key]);  // выводит: Bob, 30, New York (значения)
}
```
Здесь цикл `for...in` перебирает **свойства** объекта `person` (ключи: `name`, `age`, `city`).

#### Пример с массивом:
```js
const numbers = [10, 20, 30];

for (let index in numbers) {
    console.log(index);  // выводит индексы: 0, 1, 2
    console.log(numbers[index]);  // выводит значения: 10, 20, 30
}
```
В этом примере цикл перебирает индексы массива `numbers` (индексы: `0, 1, 2`), а затем с помощью индексов выводит соответствующие значения.

#### Когда использовать `for...in`:
- Когда нужно перебирать **ключи** объекта.
- Когда нужно узнать **индексы** элементов массива.

### 2. **Цикл `for...of`**

Цикл `for...of` предназначен для **перебора значений** итерируемых объектов, таких как массивы, строки, карты (Map), множества (Set), и так далее. Он **перебирает значения напрямую**, в отличие от `for...in`.

#### Как работает:
- Перебирает **значения** в массиве, строке или любом другом итерируемом объекте.

#### Пример с массивом:
```js
const numbers = [10, 20, 30];

for (let value of numbers) {
    console.log(value);  // выводит значения: 10, 20, 30
}
```
Здесь цикл `for...of` перебирает **значения** массива `numbers` (значения: `10, 20, 30`).

#### Пример со строкой:
```js
const word = 'Hello';

for (let char of word) {
    console.log(char);  // выводит: H, e, l, l, o
}
```
Этот цикл перебирает **символы** строки `word`.

#### Когда использовать `for...of`:
- Когда нужно перебирать **значения** массива, строки или любого итерируемого объекта.
- Лучше всего подходит для работы с массивами или когда значения важнее индексов.

### Сравнение `for...in` и `for...of`:

| `for...in` | `for...of` |
|------------|------------|
| Перебирает **ключи** объекта или индексы массива | Перебирает **значения** итерируемого объекта (например, массивы, строки) |
| Может применяться для объектов | Применяется только для итерируемых объектов |
| **Не подходит** для перебора значений массива | Подходит для перебора значений массива |

### Заключение:
- **`for...in`** используется для перебора **ключей** объектов или **индексов** массивов.
- **`for...of`** используется для перебора **значений** массивов, строк и других итерируемых объектов.

Если тебе нужно перебирать именно **значения массива** или строки, то лучше использовать `for...of`, а если нужно перебирать **свойства объекта** или **индексы массива** — используй `for...in`.

### [Назад к оглавлению](#back)


<a name="pract_9"></a>
### Оценка 70 и выше! (практика)

ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Циклы в ECMAScript 6 

Студентам нужно набрать как минимум 70 баллов, чтобы сдать экзамен. В данной программе объявлен массив с результатами.

Напишите программу для подсчета и вывода в консоль количества студентов, которые сдали экзамен.

Используйте цикл **for...of** для итерации по массиву.
```JS
let scores = [68,95,54,84,77,75,63,74,69,80,71,63]

//ваш код находится здесь
```

### [Назад к оглавлению](#back)


### Решение от GPT-4o:

Давай решим задачу по подсчёту студентов, которые сдали экзамен. Нам нужно перебрать массив `scores` и посчитать, сколько студентов набрали 70 баллов и более. Мы будем использовать цикл `for...of`, чтобы перебрать все элементы массива. Вот как это можно сделать:

```javascript
let scores = [68, 95, 54, 84, 77, 75, 63, 74, 69, 80, 71, 63];

// Переменная для хранения количества сдавших студентов
let passedCount = 0;

// Используем цикл for...of для итерации по массиву
for (let score of scores) {
    // Проверяем, сдал ли студент экзамен
    if (score >= 70) {
        passedCount++; // Увеличиваем счётчик
    }
}

// Выводим количество студентов, которые сдали экзамен
console.log(`Количество студентов, сдавших экзамен: ${passedCount}`);
```

### Объяснение кода:

1. **Объявляем массив `scores`**: Это массив с результатами студентов.

2. **Создаём переменную `passedCount`**: Эта переменная будет хранить количество студентов, которые сдали экзамен. Изначально она равна 0.

3. **Цикл `for...of`**: Этот цикл перебирает каждый элемент массива `scores`. Для каждого результата (балла) выполняется следующая проверка.

4. **Условие `if (score >= 70)`**: Здесь мы проверяем, сдал ли студент экзамен (набрал 70 и более баллов). Если да, то увеличиваем счётчик `passedCount` на 1.

5. **Вывод результата**: После завершения цикла выводим количество студентов, которые сдали экзамен, с помощью `console.log()`.

### Результат:
Если ты запустишь этот код, он выведет:
```
Количество студентов, сдавших экзамен: 7
```

Это означает, что 7 студентов из массива `scores` набрали 70 баллов или больше и, соответственно, сдали экзамен.

### [Назад к оглавлению](#back)


<a name="es6_func2"></a>
### Продолжение Циклы и функции в ES6

Как пример - пройти через все символы с использованием цикла for...of:
```js
for (let ch of "SoloLearn") {
  console.log(ch);
}
```

### Функции в ECMAScript 6 
До ES6, функция JavaScript определялась так: 
```js
function add(x, y) {
    var sum = x+y;  
    console.log(sum);
}
add(35, 7);
```

ES6 представляет новый синтаксис для написания функций. Та же функция, что и выше, может быть записана следующим образом:
```js
const add = (x, y) => {
    let sum = x + y;  
    console.log(sum);
}
add(35, 7);
```

Этот новый синтаксис довольно удобен, когда вам просто нужна простая функция с одним аргументом.

Вы можете пропустить написание **function** и **return**, а также некоторые скобки и фигурные скобки, например:
```js
const greet = x => "Welcome " + x;

alert(greet("David"));
```

Приведенный выше код определяет функцию с именем `greet`, которая имеет один аргумент и возвращает сообщение.

Если параметры отсутствуют, следует использовать пустую пару скобок, как в:
```js
const x = () => alert("Hi");
x();
```

Синтаксис очень полезен для встроенных функций. Например, допустим, у нас есть массив, и для каждого элемента массива нам нужно выполнить функцию. Мы используем метод **forEach** массива, чтобы вызвать функцию для каждого элемента:
```js
var arr = [2, 3, 7, 8];

arr.forEach(function(el) {
    console.log(el * 2);
});
```

Однако, в ES6, код выше может быть переписан следующим образом:
```js
const arr = [2, 3, 7, 8];

arr.forEach(v => {
    console.log(v * 2);
});
```

Код короче и выглядит довольно приятно, не так ли? :)

Пример, объявление стрелочной функции, которая принимает массив и выводит нечетные элементы:
```js
const printOdds = (arr) => {
arr.forEach(el => {
    if (el % 2 != 0) console.log(el);
  });
}
```

### Параметры по умолчанию в ES6 
В ES6 мы можем задать значения по умолчанию прямо в сигнатуре функций, например:
```js
/*
function test(a, b = 3, c = 42) {
  return a + b + c;
}
console.log(test(5)); //50 
*/

// Full ES6 equivalent
const test = (a, b = 3, c = 42) => a + b + c;
console.log(test(5)); //50 
```

И вот пример стрелочной функции со значениями параметров по умолчанию:
```js
const test = (a, b = 3, c = 42) => {
  return a + b + c;
}
console.log(test(5)); //50 
```

Выражения значений по умолчанию вычисляются во время вызова функции слева направо. Это также означает, что выражения по умолчанию могут использовать значения предварительно заполненных параметров.

Результатом выполнения следующей функции - будет 42:
```js
function magic(a, b = 40) {
  return a + b;
}
console.log(magic(2));
```

### [Назад к оглавлению](#back)


<a name="es6_obj"></a>
## ES6 Объекты
Переменные JavaScript могут быть типами данных **Object**, содержащими множество значений, называемых **свойствами**. 

Объект также может иметь свойства, которые являются определениями функций, называемые **методами** для выполнения действий над объектом. 

ES6 вводит **сокращенные** обозначения и **вычисляемые** имена свойств, которые делают объявление и использование объектов проще для понимания.

Новое сокращенное определение метода не требует использования двоеточия ( : ) или ключевого слова **function**, как в функции **grow** при объявлении объекта **tree**: 
```js
let tree = {
    height: 10,
    color: 'green',
    grow() { 
        this.height += 2;
    }
};

tree.grow();
console.log(tree.height); // 12
```

Вы также можете использовать сокращенное обозначение значения свойства при инициализации свойств переменной с тем же именем.

Например, свойства **height** и **health** инициализируются переменными с именами **height** и **health**:
```js
let height = 5;
let health = 100;

let athlete = {
    height, // height: height,
    health // health: health
};

console.log(athlete.height); // 5
```
При создании объекта с использованием дублирующихся имен свойств, последнее свойство перезапишет предыдущие с тем же именем, например:
```js
var a = {x: 1, x: 2, x: 3, x: 4};
console.log(a.x); // 4 
```

> Дублирование имен свойств вызывало SyntaxError в ES5 при использовании строгого режима. Однако, ES6 устранил это ограничение.

Следующий код выведет в консоль - 60:
```js
let car = {
  speed: 40,
  accelerate() {
    this.speed += 10;
  }
};

car.accelerate();
car.accelerate();
console.log(car.speed);
```

### Вычисляемые имена свойств 
С ES6, вы теперь можете использовать **вычисляемые свойства** для имен. Используя квадратные скобки [ ], мы можем использовать выражение для имени свойства, включая конкатенацию строк. Это может быть полезно в случаях, когда мы хотим создать определенные объекты на основе данных пользователя (например, id, email и так далее).

Вот три примера:

Пример 1:
```js
let prop = 'name';
let id = '1234';
let mobile = '08923';

let user = {
  [prop]: 'Jack',
  [`user_${id}`]: `${mobile}`
};

console.log(user.name); // Jack
console.log(user.user_1234); // 08923
```

Пример 2:
```js
var i = 0;
var a = {
  ['foo' + ++i]: i,
  ['foo' + ++i]: i,
  ['foo' + ++i]: i
};

console.log(a.foo1); // 1
console.log(a.foo2); // 2
console.log(a.foo3); // 3
```

Пример 3:
```js
var param = 'size';
var config = {
    [param]: 12,
    ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
};

console.log(config.mobileSize); // 4
```

Это очень полезно, когда вам нужно создать пользовательские объекты на основе некоторых переменных.

Пример создания объекта со своими свойствами:
```js
let prop = 'foo';
let o = {
  [prop]: 'lol',
  ['b' + 'ar']:  '123'
};
```

### Object.assign() в ES6
ES6 добавляет новый метод **Object - assign()**, который позволяет нам объединять несколько источников в одну цель для создания одного нового объекта. 

**Object.assign()** также полезен для создания дубликата существующего объекта.

Давайте посмотрим на следующий пример, чтобы увидеть, как объединить объекты: 
```js
let person = {
    name: 'Jack',
    age: 18,
    sex: 'male'
};
let student = {
    name: 'Bob',
    age: 20,
    xp: '2'
};

let newStudent = Object.assign({}, person, student);

console.log(newStudent.name); // Bob
console.log(newStudent.age); // 20
console.log(newStudent.sex); // male
console.log(newStudent.xp); // 2
```

Здесь мы использовали **Object.assign()**, где первый параметр - это **целевой объект**, к которому вы хотите применить новые свойства.

Каждый параметр после первого будет использоваться в качестве **источников** для цели. Нет ограничений на количество параметров источника. Однако порядок важен, потому что свойства во втором параметре будут переопределены свойствами с тем же именем в третьем параметре и так далее.

В приведенном выше примере мы использовали новый объект `{}` в качестве цели и использовали два объекта в качестве источников.

Попробуйте изменить порядок второго и третьего параметров, чтобы увидеть, что результат так-же изменится.

Теперь давайте посмотрим, как мы можем использовать **assign()** для создания дубликата объекта без создания ссылки (мутации) на базовый объект.

В следующем примере присваивание использовалось для попытки создать новый объект. Однако использование = создает ссылку на базовый объект. Из-за этой ссылки изменения, предназначенные для нового объекта, мутируют оригинальный объект:
```js
let person = {
    name: 'Jack',
    age: 18
};

let newPerson = person;
newPerson.name = 'Bob';

console.log(person.name); // Bob
console.log(newPerson.name); // Bob
```

Чтобы избежать этого (мутаций), используйте **Object.assign()** для создания нового объекта. Например:
```js
let person = {
    name: 'Jack',
    age: 18
};

let newPerson = Object.assign({}, person);
newPerson.name = 'Bob';

console.log(person.name); // Jack
console.log(newPerson.name); // Bob
```

Наконец, вы можете присвоить значение свойству объекта в выражении **Object.assign()**. Например:
```js
let person = {
    name: 'Jack',
    age: 18
};

let newPerson = Object.assign({}, person, {name: 'Bob'});

console.log(newPerson.name); // Bob
```

Результатом выполнения следующего кода будут четыре шесть (`4 6`):
```js
const obj1 = {
  a: 0,
  b: 2,
  c: 4
};
const obj2 = Object.assign({c: 5, d: 6}, obj1);
console.log(obj2.c, obj2.d);
```

### [Назад к оглавлению](#back)


<a name="pract_10"></a>
## Тренируйтесь усерднее! (практика)
### ES6 Объекты 
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ

Вы создаете приложение для тренировок. После завершения базовых упражнений в приложении, пользователь может получить доступ к продвинутому контенту.

Данная программа объявляет два класса - базовый и продвинутый с соответствующими свойствами. Дополните код для объединения упражнений базового и продвинутого уровня в один новый объект под названием **total**`, так чтобы данный код для финального вывода работал корректно.

> Используйте Object.assign() для выполнения запрошенной операции.
```js
let basic = {
    ex1: 'PushUps: 20 times',
    ex2: 'Jumps: 20 times'
};
let advanced = {
    ex3: 'Squats: 30 times',
    ex4: 'Run: 2km'
};

//your code goes here


for(let ex in total) {
    console.log(total[ex])
};
```

### [Назад к оглавлению](#back)


<a name="es6_destruct"></a>
## ES6 Destructuring
### Деструктуризация массивов в ES6 
Синтаксис **деструктурирующего** присваивания - это выражение JavaScript, которое позволяет распаковывать значения из массивов или свойств из объектов в отдельные переменные. 

ES6 добавил сокращенный синтаксис для деструктуризации массива.

Следующий пример демонстрирует, как распаковать элементы массива в отдельные переменные: 
```js
let arr = ['1', '2', '3'];

let [one, two, three] = arr;

console.log(one); // 1
console.log(two); // 2
console.log(three); // 3
```

Мы также можем использовать деструктуризацию массива, возвращаемого функцией. Например:
```js
let a = () => {
    return [1, 3, 2];
};

let [one, , two] = a();

console.log(one); // 1
console.log(two); // 2
```

Обратите внимание, что мы оставили место для второго аргумента пустым.

Синтаксис деструктуризации также упрощает присваивание и обмен значениями:
```js
let a, b, c = 4, d = 8;

[a, b = 6] = [2];
console.log(a); // 2
console.log(b); // 6

[c, d] = [d, c];
console.log(c); // 8
console.log(d); // 4
```

Результатом выполнения следующего кода будет `Ann`:
```js
let names = ['John', 'Fred', 'Ann'];
let [Ann, Fred, John] = names;
console.log(John);
```

### Деструктуризация объектов в ES6 

Аналогично деструктуризации массивов, **деструктуризация объектов** распаковывает свойства в отдельные переменные. Например:
```js
let obj = {h:100, s: true};
let {h, s} = obj;

console.log(h);  //100
console.log(s);  //true
```

Мы можем присваивать без объявления, но для этого есть некоторые синтаксические требования:
```js
let a, b;
({a, b} = {a: 'Hello ', b: 'Jack'});

console.log(a + b);  //Hello Jack
```

Символы **круглых скобок ()** с **точкой с запятой (;)** в конце являются **обязательными** при деструктуризации без объявления. Однако, вы также можете сделать это следующим образом, где **()** не требуются:
```js
let {a, b} = {a: 'Hello ', b: 'Jack'};

console.log(a + b);
```

Вы также можете назначить объект новым именам переменных, например:
```js
var o = {h: 42, s: true};
var {h: foo, s: bar} = o;

//console.log(h); // Error
console.log(foo); // 42
```

Наконец, вы можете назначить значения по умолчанию для переменных, на случай, если значение, извлеченное из объекта, не определено. Например:
```js
var obj = {id: 42, name: "Jack"};

let {id = 10, age = 20} = obj;

console.log(id); // 42
console.log(age); // 20
```

Следующий код - выдаст единицу ошибку `one` не определен:
```js
const obj = {one: 1, two: 2};
let {one:first, two:second} = obj;
console.log(one);
```

### [Назад к оглавлению](#back)


<a name="es6_rest_spread"></a>
## Rest & Spread
### Rest параметры ES6 
До появления ES6, если мы хотели передать переменное количество **аргументов** в функцию, мы могли использовать объект `arguments`, похожий на массив, чтобы получить доступ к переданным параметрам функции.

Например, давайте напишем функцию, которая проверяет, содержит ли массив все переданные аргументы: 
```js
function containsAll(arr) {
    for (let k = 1; k < arguments.length; k++) {
        let num = arguments[k];
        if (arr.indexOf(num) === -1) {
            return false;
        }
    }
    return true;
}

let x = [2, 4, 6, 7];
console.log(containsAll(x, 2, 4, 7));
console.log(containsAll(x, 6, 4, 9));
```

### Пояснение к этому коду GPT-4o

### 1. **Функция `containsAll(arr)`**

Функция `containsAll` принимает массив `arr` в качестве первого аргумента, а затем проверяет, содержатся ли все последующие аргументы внутри этого массива.

#### Структура функции:
- **`arr`** — первый параметр, это массив, в котором нужно искать элементы.
- **`arguments`** — специальный объект, который доступен внутри всех функций. Он содержит все аргументы, переданные функции, как массив. Например, если функция вызвана с аргументами `(x, 2, 4, 7)`, то `arguments` будет содержать: `[x, 2, 4, 7]`.
  
Функция работает таким образом, что проверяет, содержатся ли все элементы, переданные после массива `arr` (то есть `2`, `4`, и `7` в первом вызове, и `6`, `4`, и `9` во втором) в этом массиве.

### 2. **Цикл `for`**
```js
for (let k = 1; k < arguments.length; k++) {
```
Этот цикл начинается с индекса `1`, так как на первом месте в `arguments` всегда находится массив `arr`, и он уже нам не нужен для проверки. Далее мы перебираем все остальные аргументы (которые мы ищем в массиве `arr`).

### 3. **Переменная `num`**
```js
let num = arguments[k];
```
В этой строке мы извлекаем каждый аргумент по очереди (начиная со второго аргумента) и сохраняем его в переменную `num`. Например, если вызов функции был `containsAll(x, 2, 4, 7)`, то на первой итерации `num` будет `2`, на второй — `4`, и так далее.

### 4. **Проверка `if (arr.indexOf(num) === -1)`**
```js
if (arr.indexOf(num) === -1) {
```
Функция `indexOf()` ищет элемент в массиве и возвращает его индекс, если он существует, и `-1`, если такого элемента в массиве нет.

- Если элемент из аргументов (`num`) не найден в массиве `arr`, то функция возвращает `false`, так как хотя бы одного элемента из аргументов не хватает в массиве.
- Если все элементы присутствуют, то проверка продолжается.

### 5. **Возврат значения**
```js
return false;
```
- Если хотя бы один элемент не найден в массиве, функция сразу завершает работу и возвращает `false`.

```js
return true;
```
- Если все элементы найдены, и цикл завершился без возврата `false`, то в конце функция вернёт `true`, что означает, что все аргументы присутствуют в массиве `arr`.

### 6. **Пример вызова**
```js
let x = [2, 4, 6, 7];
console.log(containsAll(x, 2, 4, 7)); // true
console.log(containsAll(x, 6, 4, 9)); // false
```

#### Первый вызов:
- В массиве `x = [2, 4, 6, 7]` ищутся значения `2`, `4`, и `7`.
- Все эти значения присутствуют в массиве `x`, поэтому функция вернёт `true`.

#### Второй вызов:
- В массиве `x = [2, 4, 6, 7]` ищутся значения `6`, `4`, и `9`.
- Значение `9` не содержится в массиве `x`, поэтому функция вернёт `false`.

### Краткое объяснение:
Функция `containsAll` проверяет, содержатся ли все переданные значения после первого аргумента в массиве. Если хотя бы одного элемента нет, она возвращает `false`, иначе — `true`.

---
Мы можем передать любое количество аргументов функции и получить доступ к ним с помощью объекта **arguments**.

Хотя это работает, ES6 предлагает более читаемый синтаксис для работы с переменным числом параметров с использованием **rest параметра**:
```js
function containsAll(arr, ...nums) {
    for (let num of nums) {
        if (arr.indexOf(num) === -1) {
            return false;
        }
    }
    return true;
}

let x = [2, 4, 6, 7];
console.log(containsAll(x, 2, 4, 7));
console.log(containsAll(x, 6, 4, 9));
```

Параметр **...nums** называется **параметром rest**. Он принимает все "лишние" аргументы, переданные в функцию. Три точки (**...**) называются оператором **Spread**.

> Только последний параметр функции может быть отмечен как параметр rest. Если нет дополнительных аргументов, параметр rest будет просто пустым массивом; параметр rest никогда не будет **undefined**.

### [Назад к оглавлению](#back)


<a name="pract_11"></a>
### Калькулятор суммы (практика)
 
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Rest & Spread
Вы создаете программу для вычисления суммы любого количества значений.

Дополните данную функцию так, чтобы она принимала в качестве параметров столько чисел, сколько необходимо, и возвращала их сумму.

Используйте rest parameter в качестве аргумента.
```js
//complete the function
function Add(){
    
}

console.log(Add(1,2,3));
console.log(Add(4,14,5,9,14));
console.log(Add(2,36));
```

### [Назад к оглавлению](#back)


### Решение GPT-4o:

Чтобы реализовать функцию, которая принимает любое количество чисел и возвращает их сумму, нам нужно использовать **rest parameter** (`...`). Это позволяет функции принимать неопределённое количество аргументов в виде массива. Давай дополним твою функцию.

1. **Rest parameter**: В синтаксисе JavaScript это обозначается как `...args`, где `args` будет массивом всех переданных аргументов.
2. **Цикл или метод `reduce()`**: Мы можем использовать цикл для суммирования значений или метод `reduce()`, который аккумулирует сумму.

Вот решение:

```js
//complete the function
function Add(...numbers) {
    // используем reduce для суммирования всех чисел
    return numbers.reduce((sum, current) => sum + current, 0);
}

console.log(Add(1, 2, 3));            // 6
console.log(Add(4, 14, 5, 9, 14));    // 46
console.log(Add(2, 36));              // 38
```

### Объяснение:

1. **Rest parameter `...numbers`**: Теперь все переданные аргументы будут собраны в массив `numbers`.
   - Например, если вызов: `Add(1, 2, 3)`, то `numbers` будет равен `[1, 2, 3]`.

2. **Метод `reduce()`**:
   - `numbers.reduce((sum, current) => sum + current, 0)` — это функция, которая аккумулирует сумму всех элементов массива.
   - `sum` — это накопленная сумма, которая инициализируется значением `0`.
   - `current` — это текущий элемент массива, который добавляется к сумме.

3. **Возврат результата**: Функция возвращает итоговую сумму всех переданных чисел.

### Пример работы:
- `Add(1, 2, 3)` вернёт `6`, так как `1 + 2 + 3 = 6`.
- `Add(4, 14, 5, 9, 14)` вернёт `46`.
- `Add(2, 36)` вернёт `38`.

Теперь твоя функция работает с любым количеством чисел и возвращает их сумму!

### [Назад к оглавлению](#back)


<a name="es6_rest_spread2"></a>
## Продолжение Rest & Spread

Результат выполнения следующего кода будет 12:
```js
function magic(...nums) {
  let sum = 0;
  nums.filter(n => n % 2 == 0).map(el => sum+= el);
  return sum;
}
console.log(magic(1, 2, 3, 4, 5, 6));
```

Объяснение:
1. Функция `magic` принимает любое количество чисел с помощью rest parameter `...nums`.
2. Она фильтрует чётные числа с помощью метода `filter`: из набора `(1, 2, 3, 4, 5, 6)` остаются только `2, 4, 6`.
3. Затем метод `map` добавляет эти числа к переменной `sum`. В итоге: `sum = 2 + 4 + 6 = 12`.
4. Функция возвращает значение `sum`, которое равно `12`.

### Оператор Spread 
Этот оператор похож на параметр Rest, но он имеет другое назначение, когда используется в объектах или массивах или вызовах функций (аргументы).

### Spread в вызовах функций 
 
Распространено передавать элементы массива в качестве аргументов функции. До ES6 мы использовали следующий метод (вывод 10):
```js
function myFunction(w, x, y, z) {
    console.log(w + x + y + z);
}
var args = [1, 2, 3];
myFunction.apply(null, args.concat(4));
```

ES6 предоставляет простой способ выполнения примера выше с помощью операторов распространения (вывод 10):
```js
const myFunction = (w, x, y, z) => {
    console.log(w + x + y + z);
};
let args = [1, 2, 3];
myFunction(...args, 4);
```

Например следующий код выведет объект даты `[object Date]` "1970-01-01T18:00:00.000Z" :
```js
var dateFields = [1970, 0, 1];  // 1 Jan 1970
var date = new Date(...dateFields);
console.log(date);
```

### Оператор расширения в литералах массива 
До ES6, мы использовали следующий синтаксис для добавления элемента в середину массива:
```js
var arr = ["One", "Two", "Five"];

arr.splice(2, 0, "Three");
arr.splice(3, 0, "Four");
console.log(arr);
```

Вы можете использовать такие методы, как **push**, **splice** и **concat**, например, для достижения этого в разных позициях массива. Однако в ES6 оператор расширения позволяет нам сделать это проще:
```js
let newArr = ['Three', 'Four']; 
let arr = ['One', 'Two', ...newArr, 'Five'];
console.log(arr);
```

### Spread в объектных литералах 
В объектах он копирует собственные перечисляемые свойства из предоставленного объекта в новый объект.
```js
const obj1 = { foo: 'bar', x: 42 };
const obj2 = { foo: 'baz', y: 5 };

const clonedObj = { ...obj1 }; // { foo: "bar", x: 42 }
const mergedObj = { ...obj1, ...obj2 }; // { foo: "baz", x: 42, y: 5 }
```

Однако, если вы попытаетесь объединить их, вы не получите ожидаемого результата:
```js
const obj1 = { foo: 'bar', x: 42 };
const obj2 = { foo: 'baz', y: 5 };
const merge = (...objects) => ({ ...objects });

let mergedObj = merge (obj1, obj2);
// { 0: { foo: 'bar', x: 42 }, 1: { foo: 'baz', y: 5 } }

let mergedObj2 = merge ({}, obj1, obj2);
// { 0: {}, 1: { foo: 'bar', x: 42 }, 2: { foo: 'baz', y: 5 } }
```

Поверхностное клонирование или объединение объектов возможно с помощью другого оператора под названием **Object.assign()**.

Результат выполнения следующего кода:

```javascript
let nums = [3, 4, 5];
let all = [1, 2, ...nums, 6];
console.log(all[3]);
```

будет 4 потому что:

1. **Spread-оператор (`...`)**: Когда мы используем `...nums`, массив `nums` разворачивается в отдельные элементы внутри массива `all`. Это означает, что массив `all` будет выглядеть так: `[1, 2, 3, 4, 5, 6]`.

2. **Доступ к элементам по индексу**: Массивы в JavaScript индексируются с 0:
   - `all[0]` — это `1`
   - `all[1]` — это `2`
   - `all[2]` — это `3`
   - **`all[3]`** — это `4`

Таким образом, значение по индексу `3` — это `4`, а не `3`, потому что на третьем индексе оказался второй элемент массива `nums` (после разворачивания массива `nums`).

### [Назад к оглавлению](#back)


<a name="es6_class"></a>
### ES6 Классы

В этом уроке мы объясним, как создать **class**, который можно использовать для создания нескольких объектов одной и той же структуры. 

**Class** использует ключевое слово **class** и содержит метод **constructor** для инициализации.
Например:
```js
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

Заявленный **класс** затем может быть использован для создания нескольких объектов с помощью ключевого слова **new**. Например:
```js
class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
  }
}

const square = new Rectangle(5, 5);
const poster = new Rectangle(2, 3); 

console.log(square.height); //5
```

> Объявления классов **не поднимаются**, в то время как объявления функций поднимаются. Если вы попытаетесь получить доступ к вашему классу до его объявления, будет возвращена **ReferenceError**.

Вы также можете определить класс с помощью **классового выражения**, где класс может быть именованным или безымянным.

**Именованный** класс выглядит так:
```js
var Square = class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
  }
};

const square = new Square(5, 5);
const poster = new Square(2, 3); 

console.log(square.height);
```

В выражении безымянного класса переменной просто присваивается определение класса:
```js
var Square = class {
    constructor(height, width) {
        this.height = height;
        this.width = width;
  }
};

const square = new Square(5, 5);
const poster = new Square(2, 3); 

console.log(square.height);
```

**Constructor** - это специальный метод, который используется для создания и инициализации объекта, созданного с помощью класса.

В каждом классе может быть только **один** конструктор.

Объявление класса **Point** с конструктором, инициализирующим его члены **x** и **y**.
```js
class Point {
  constructor(a, b) {
      this.x = a;
      this.y = b;
  }
  getX() { return this.x; }
  getY() { return this.y; }
}
```

### Методы классов в ES6 
ES6 вводит сокращенную запись, которая не требует ключевого слова `function` для **функции**, присвоенной имени метода. 

Один из типов методов класса - это **метод прототипа**, доступный для объектов класса.

Пример: 
```js
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  
  get area() {
    return this.calcArea();
  }

  calcArea() {
    return this.height * this.width;
  }
}

const square = new Rectangle(5, 5);

console.log(square.area); // 25
```

В приведенном выше коде, `area` - это **геттер**, `calcArea` - это **метод**.

Другой тип метода - это **статический метод**, который не может быть вызван через экземпляр класса. Статические методы часто используются для создания вспомогательных функций для приложения.

Например:
```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    return Math.hypot(dx, dy);
  }
}

const p1 = new Point(7, 2);
const p2 = new Point(3, 8);

console.log(Point.distance(p1, p2));  //7.211102550927979
```

Как вы можете видеть, статический метод **distance** вызывается напрямую с использованием имени класса, без объекта.

### [Назад к оглавлению](#back)


<a name="pract_12"></a>
### Средний балл экзамена (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Методы класса в ES6 
Вы создаете программу, чтобы студенты могли рассчитать средний балл за 3 экзамена.

Данная программа принимает в качестве входных данных оценки за 3 экзамена и объявляет класс **Exams**.

Добавьте **статический метод** `average()` в класс **Exams**, который будет принимать оценки в качестве параметров, рассчитывать и возвращать средний балл **округленный до ближайшего целого**, чтобы код в `main` работал правильно.
```js
Пример ввода:
74
80
68

Пример вывода:
74
```

> Вспомните функцию **Math.round()** для округления числа с плавающей точкой до ближайшего целого числа.

```js
function main() {
    var exam1 = parseInt(readLine(), 10);
    var exam2 = parseInt(readLine(), 10);
    var exam3 = parseInt(readLine(), 10);
    
    console.log(Exams.average(exam1,exam2,exam3));
    
}
class Exams{
    //your code goes here
    
}
```

### Решение GPT-4o

Для решения задачи нужно создать **статический метод** `average()` в классе `Exams`, который будет принимать три оценки, рассчитывать их среднее значение и округлять до ближайшего целого числа с помощью функции `Math.round()`.

### Решение:

```js
function main() {
    var exam1 = parseInt(readLine(), 10);
    var exam2 = parseInt(readLine(), 10);
    var exam3 = parseInt(readLine(), 10);
    
    console.log(Exams.average(exam1, exam2, exam3));
}

class Exams {
    // Статический метод для вычисления среднего балла
    static average(exam1, exam2, exam3) {
        // Считаем среднее значение
        let avg = (exam1 + exam2 + exam3) / 3;
        // Округляем до ближайшего целого и возвращаем
        return Math.round(avg);
    }
}
```

### Объяснение:
1. **Статический метод `average()`**:
   - Метод объявлен с использованием ключевого слова `static`, чтобы его можно было вызывать без создания экземпляра класса.
   - Он принимает три оценки (`exam1`, `exam2`, `exam3`) в качестве параметров.
   - Среднее значение рассчитывается с помощью формулы:  
     ```js
     (exam1 + exam2 + exam3) / 3;
     ```
   - Среднее значение округляется до ближайшего целого числа с помощью функции `Math.round()`.

2. **Результат работы программы**:
   - Например, если ввести оценки `74`, `80` и `68`, программа сначала вычислит среднее значение:  
     ```js
     (74 + 80 + 68) / 3 = 74
     ```
     Среднее округляется до `74`, и этот результат выводится на консоль.

### [Назад к оглавлению](#back)


<a name="es6_class2"></a>
### Продолжение Классы в ES6

Следующий код выведет - "Рекс лает."
```js
class Dog {
  constructor(name) {    
    this.name = name;
  }
  bark() {
    console.log(this.name + ' лает.');
  }
}
let d = new Dog('Рекс');
d.bark();
```

### Наследование в ES6 
Ключевое слово **extends** используется в объявлениях классов или выражениях классов для создания **потомка класса**. Потомок наследует свойства и методы родителя.

Например:
```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Dog extends Animal {
  speak() {
    console.log(this.name + ' barks.');
  }
}
let dog = new Dog('Rex');
dog.speak(); // Rex barks.
```

В приведенном выше коде, класс **Dog** является дочерним классом класса **Animal**, наследуя его свойства и методы.

> Если в подклассе присутствует конструктор, ему нужно сначала вызвать **super()** перед использованием **this**. Кроме того, ключевое слово **super** используется для вызова методов родительского класса.

Например, мы можем изменить программу выше следующим образом:
```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Dog extends Animal {
  speak() {
    super.speak(); // Super
    console.log(this.name + ' barks.');
  }
}

let dog = new Dog('Rex');
dog.speak();
// Rex makes a noise.
// Rex barks.
```

В приведенном выше коде метод **speak()** родителя вызывается с использованием ключевого слова **super**.

Следующий код объявляет класс **Student**, который наследует от класса **Human**:
```js
class Human {
  constructor(name) {
    this.name = name;
  }
}
class Student extends Human {
  constructor(name, age) {    
    super(name);
    this.age = age;
  }
}
```

### [Назад к оглавлению](#back)


<a name="map_&_set"></a>
## ES6 Map & Set
### ES6 Map 
Объект **Map** может быть использован для хранения **пар ключ/значение**. Ключом или значением в карте (Map) может быть что угодно (объекты и примитивные значения). 

Синтаксис **new Map([iterable])** создает объект Map, где **iterable** - это массив или любой другой итерируемый объект, элементы которого являются массивами (с парой ключ/значение каждый).

**Объект** похож на **Map**, но есть важные различия, которые делают использование Map предпочтительным в некоторых случаях:
1. Ключами могут быть любые типы, включая функции, объекты и любые примитивы.
2. Вы можете узнать размер **Map**.
3. Вы можете напрямую итерировать по **Map**.
4. Производительность **Map** лучше в сценариях, включающих частое добавление и удаление пар ключ/значение.

Свойство **size** возвращает количество пар ключ/значение в карте.

Например:
```js
let map = new Map([['k1', 'v1'], ['k2', 'v2']]);

console.log(map.size); // 2
```

### Методы
- **set(key, value)** Добавляет указанную пару ключ/значение в карту. Если указанный ключ уже существует, соответствующее ему значение заменяется на указанное значение.
- **get(key)** Получает значение, соответствующее указанному ключу в карте. Если указанный ключ не существует, возвращается undefined.
- **has(key)** Возвращает `true`, если указанный ключ существует в карте, и `false` в противном случае.
- **delete(key)** Удаляет пару ключ/значение с указанным ключом из карты и возвращает `true`. Возвращает `false`, если элемент не существует.
- **clear()** Удаляет все пары ключ/значение из карты.
- **keys()** Возвращает Итератор ключей в карте для каждого элемента.
- **values()** Возвращает Итератор значений в карте для каждого элемента.
- entries() Возвращает Итератор массива[key, value] в карте для каждого элемента.

Например:
```js
let map = new Map();
map.set('k1', 'v1').set('k2', 'v2');

console.log(map.get('k1')); // v1
console.log(map.has('k2')); // true

for (let kv of map.entries())
    console.log(kv[0] + " : " + kv[1]);  // "k1 : v1" "k2 : v2"
```

Приведенный выше пример демонстрирует некоторые методы **ES6 Map**.

**Map** поддерживает разные типы данных, т.е. `1` и `"1"` являются двумя разными ключами/значениями.

### [Назад к оглавлению](#back)


<a name="pract_13"></a>
### Карта сотрудников (практика)
ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### ES6 Map 
Пять сотрудников компании хранятся в Map в программе, которую вы получили. Их имена установлены в качестве ключей, а их должности - в качестве значений. Компания нанимает еще одного сотрудника. Программа должна принимать имя и должность в качестве входных данных и хранить их в существующей карте.

Дополните программу для выполнения этой операции и вывода на консоль списка сотрудников в формате, показанном в примере вывода.
```js
Пример ввода:
Bob
Developer

Пример вывода:
Richard : Developer
Maria : SEO Specialist
Tom : Product Manager
David : Accountant
Sophia : HR Manager
Bob : Developer
```

> Метод entries() возвращает Итератор массива [ключ, значение] в карте для каждого элемента.
>
>Не забудьте поставить пробелы до и после двоеточия (`:`) в выводе.
```js
function main() {
    var name = readLine();
    var position = readLine();
    let employees = new Map([
    ["Richard", "Developer"],
    ["Maria", "SEO Specialist"],
    ["Tom", "Product Manager"],
    ["David", "Accountant"],
    ["Sophia", "HR Manager"]
    ]);

    //add the new pair to the map
    employees.set(name, position); {
        this.name = name;
        this.position = position;
    }

    for (var i of employees.entries()){
        //your code for the output
         console.log(i[0] + " : " + i[1]);     
    } 
}
```

### [Назад к оглавлению](#back)


<a name="map_&_set2"></a>
### Продолжение Map & Set
Следующий код вернет значение один (`1`):
```js
const map = new Map();
map.set('one', 1);
map.set('2', 'two');
if (map.has('two')) {
  console.log('two');
} else {
  console.log(map.get('one'));
}
```

### ES6 Set 
Объект **Set** может быть использован для хранения **уникальных** значений (повторения не допускаются).

Значением в наборе может быть что угодно (объекты и примитивные значения). 

Синтаксис **new Set([iterable])** создает объект Set, где **iterable** - это массив или любой другой перечисляемый объект значений.

Свойство **size** возвращает количество **различных** значений в наборе.

Например:
```js
let set = new Set([1, 2, 4, 2, 59, 9, 4, 9, 1]);

console.log(set.size); // 5
```

### Методы
- **add(value)** Добавляет новый элемент с указанным значением в `Set`.
- **delete(value)** Удаляет указанное значение из набора.
- **has(value)** Возвращает `true`, если указанное значение существует в наборе, и `false` в противном случае.
- **clear()** Очищает набор.
- **values()** Возвращает итератор значений в наборе.

Например:
```js
let set = new Set();
set.add(5).add(9).add(59).add(9);

console.log(set.has(9));  //true

for (let v of set.values())
    console.log(v);  // 5 9 59
```

Приведенный выше пример демонстрирует некоторые методы **ES6 Set**.

**Set** поддерживает различные типы данных, т.е. `1` и `"1"` являются двумя разными значениями.

`NaN` и `undefined` также могут быть сохранены в **Set**.

Следующий код выводит  набор со значениями `1`, `2`, `3`:
```js
const set = new Set();
set.add(1).add(2).add(3);
for(let v of set.values())
  console.log(v);
```

### [Назад к оглавлению](#back)


<a name="es6_more"></a>
## Больше о ES6
### ES6 Promises 
**Promise** - это лучший способ асинхронного программирования по сравнению с обычным способом использования метода типа **setTimeout()**.

Рассмотрим пример:
```js
setTimeout(function() {
    console.log("Work 1");
    setTimeout(function() {
        console.log("Work 2");
    }, 1000);
}, 1000);
console.log("End");
```

Он выводит "End", "Work 1" и "Work 2" в этом порядке (работа выполняется асинхронно). Но если событий становится больше, код становится очень сложным.

ES6 приходит на помощь в таких ситуациях. **Promise** можно создать следующим образом:
```js
new Promise(function(resolve, reject) {
    // Work
    if (success)
        resolve(result);
    else
        reject(Error("failure"));
});
```

Здесь **resolve** - это метод для успешного выполнения, а **reject** - метод для ошибки.

Если метод возвращает промис, его вызовы должны использовать метод **then**, который принимает два метода в качестве ввода; один для успешного выполнения, другой для ошибки.

Например:
```js
function asyncFunc(work) {
    return new Promise(function(resolve, reject) {
        if (work === "")
            reject(Error("Nothing"));
        setTimeout(function() {
            resolve(work);
        }, 1000);
    });
}

asyncFunc("Work 1") // Task 1
.then(function(result) {
    console.log(result);
    return asyncFunc("Work 2"); // Task 2
}, function(error) {
    console.log(error);
})
.then(function(result) {
    console.log(result);
}, function(error) {
    console.log(error);
});
console.log("End");
```

Он также выводит "End", "Work 1" и "Work 2" (работа выполняется асинхронно). Однако, это явно более читаемо, чем в предыдущем примере, и в более сложных ситуациях с ним проще работать.

>> А по мне так что та, что эта - не читаема. Давайте подтягивать GPT-4o.

### [Назад к оглавлению](#back)


<a name="gpt_comment_3"></a>
### ES6 Promises: коментарий GPT-4o
Давай разберем конструкцию подробно по шагам:

### Код:

```js
function asyncFunc(work) {
    return new Promise(function(resolve, reject) {
        if (work === "") 
            reject(Error("Nothing"));  // Если параметр "work" пуст, вызываем reject с ошибкой.
        setTimeout(function() {
            resolve(work);  // Через 1 секунду выполняется resolve и возвращается значение "work".
        }, 1000);
    });
}

asyncFunc("Work 1")  // Task 1
.then(function(result) {
    console.log(result);  // Выведет результат "Work 1"
    return asyncFunc("Work 2");  // Task 2: вызовем asyncFunc со значением "Work 2".
}, function(error) {
    console.log(error);
})
.then(function(result) {
    console.log(result);  // Выведет результат "Work 2"
}, function(error) {
    console.log(error);
});

console.log("End");
```

### Пояснение по шагам:

1. **`asyncFunc(work)`**: Эта функция принимает параметр `work` и возвращает новый объект **Promise**. Внутри промиса определяется:
   - Если параметр `work` — пустая строка (`""`), вызывается `reject(Error("Nothing"))`, что завершает промис с ошибкой.
   - Если строка непустая, через 1 секунду вызывается `resolve(work)`, который успешно завершает промис и возвращает строку `work`.

2. **Порядок выполнения**:
   - Сначала вызывается `asyncFunc("Work 1")`. Поскольку `work` не пустой, сработает `setTimeout`, который через 1 секунду завершит промис успешно с результатом `"Work 1"`.
   
   - После выполнения `resolve("Work 1")` вызывается первый обработчик `.then`, который:
     - Логирует результат (`console.log(result)`), выводя `"Work 1"`.
     - Затем возвращает новый вызов `asyncFunc("Work 2")`, который создаёт ещё один промис, выполняющийся 1 секунду.
   
   - После второго промиса снова вызывается `.then`, который логирует результат `"Work 2"`, так как `asyncFunc("Work 2")` тоже завершится успешно через 1 секунду.

3. **Асинхронность**:
   - Важно понимать, что функции внутри `setTimeout` работают асинхронно, а значит, программа не останавливается и не ждёт, пока промисы выполнятся. 
   
   - Поэтому перед выполнением промисов сразу выводится строка `"End"` из вызова `console.log("End")`. Это происходит до того, как сработает первый `setTimeout` и начнёт выводить результаты.

4. **Итоговый порядок вывода**:
   1. `"End"` — выводится сразу, так как асинхронные операции ещё не завершились.
   2. `"Work 1"` — выводится через 1 секунду, когда первый промис завершился.
   3. `"Work 2"` — выводится через 2 секунды, после завершения второго промиса.

### Результат:
```
End
Work 1
Work 2
```

Таким образом, этот код демонстрирует работу промисов, цепочек `.then()` и асинхронного выполнения задач с использованием `setTimeout`.

### [Назад к оглавлению](#back)


<a name="es6_more2"></a>
##  Продолжение "Больше о ES6"
Итак, определение функции, которая возвращает объект Promise:
```js
function foo() {
  return new Promise((resolve, reject) => {
    let result = getSomeResult();
    if (result)
      resolve('Success');
    else
      reject('Something went wrong');
  });
}
```

### Итераторы и генераторы 
**Symbol.iterator** является итератором по умолчанию для объекта. Циклы **for...of** основаны на этом типе итератора.

В примере ниже мы увидим, как мы должны реализовать это и как используются **генераторные функции**. Пример:
```js
let myIterableObj = { 
  [Symbol.iterator] : function* () {
    yield 1; yield 2; yield 3;
  }
};
console.log([...myIterableObj]); // [ 1, 2, 3 ]
```

Сначала мы создаем объект и используем **Symbol.iterator** и **generator function** для его заполнения некоторыми значениями.

Во второй строке кода мы используем `*` с ключевым словом `function`. Это называется **generator function** (или **gen function**).

Например, вот простой случай, когда **gen functions** могут быть полезны:
```js
function* idMaker() {
  let index = 0;
  while (index < 5)
    yield index++;
}
var gen = idMaker();

console.log(gen.next().value);  // 0
console.log(gen.next().value);  // 1
console.log(gen.next().value);  // 2
console.log(gen.next().value);  // 3
console.log(gen.next().value);  // 4
console.log(gen.next().value);  // undefined
// Если добавить еще один console.log, то, как видим код сообщит о том, что значение не определено.
```

Мы можем выйти и заново войти в функции-генераторы позже. Их связи переменных (контекст) будут сохранены при повторном входе. Они являются очень мощным инструментом для асинхронного программирования, особенно при использовании с **Promises**. Они также могут быть полезны для создания циклов с особыми требованиями.

Мы можем вкладывать **функции-генераторы** друг в друга для создания более сложных структур и передавать им аргументы при вызове.

Пример ниже покажет полезный случай использования **функции-генератора** и **Symbol**.iterators вместе. Пример:
```js
const arr = ['0', '1', '4', 'a', '9', 'c', '16'];
const my_obj = {
  [Symbol.iterator]: function*() {
    for(let index of arr) {
      yield `${index}`;
    }
  }
};

const all = [...my_obj] /* Здесь вы можете заменить «[...my_obj]» на «arr». */
  .map(i => parseInt(i, 10))
  .map(Math.sqrt)
  .filter((i) => i < 5) /* вывод в консоль - 10. Если изменить значение с 5 на 4 - вывод в консоль будт - 6.*/
  .reduce((i, d) => i + d); /* Если закомментировать эту строку - возникнет ошибка Invalid or unexpected token  */

console.log(all);
```

Мы создаем объект из 7 элементов, используя **Symbol.iterator** и функцию генератор. Во второй части мы назначаем наш объект константе **all**. В конце мы выводим его значение. Без ста грамм - не разберешься. Будем звать стаграмма:

### [Назад к оглавлению](#back)


<a name="gpt_comment_5"></a>
### ES6 итераторы и генераторы: коментарий GPT-4o

Давай разберем этот код по шагам, чтобы было понятно, что происходит на каждом этапе:

### Код:

```js
const arr = ['0', '1', '4', 'a', '9', 'c', '16'];
const my_obj = {
  [Symbol.iterator]: function*() {
    for (let index of arr) {
      yield `${index}`;
    }
  }
};

const all = [...my_obj]  // Здесь вы можете заменить «[...my_obj]» на «arr».
  .map(i => parseInt(i, 10))
  .map(Math.sqrt)
  .filter((i) => i < 5) // Если изменить значение с 5 на 4 - вывод в консоль будет другой.
  .reduce((i, d) => i + d); // Если закомментировать эту строку - возникнет ошибка.

console.log(all);
```

### Пояснение по шагам:

1. **Массив `arr`**:
   - Массив содержит строки: `['0', '1', '4', 'a', '9', 'c', '16']`. Обратите внимание, что некоторые из них — числа в строковом виде, а другие — нечисловые значения (например, `'a'` и `'c'`).

2. **`my_obj` с итератором**:
   - Это объект с методом `[Symbol.iterator]`, который возвращает **генератор**. Этот генератор перебирает элементы массива `arr` и "выдает" (с помощью `yield`) каждое значение как строку (хотя элементы массива уже являются строками).
   - Благодаря этому итератору объект `my_obj` становится **итерируемым**, и его можно использовать в конструкциях, таких как цикл `for...of`, оператор **spread** (`...`) и другие.

3. **Spread-оператор `[...]`**:
   - Оператор **spread** разворачивает объект `my_obj` в массив. Это работает, потому что объект `my_obj` является итерируемым из-за символа `Symbol.iterator`. 
   - После этого `[...my_obj]` создаст массив с теми же элементами, что и массив `arr`: `['0', '1', '4', 'a', '9', 'c', '16']`.

4. **Метод `.map(i => parseInt(i, 10))`**:
   - `parseInt(i, 10)` пытается преобразовать каждый элемент массива в целое число (с основанием системы счисления 10).
     - `'0'` → `0`
     - `'1'` → `1`
     - `'4'` → `4`
     - `'a'` → `NaN` (не число, так как это буква)
     - `'9'` → `9`
     - `'c'` → `NaN`
     - `'16'` → `16`
   - Результатом этого будет массив: `[0, 1, 4, NaN, 9, NaN, 16]`.

5. **Метод `.map(Math.sqrt)`**:
   - Этот метод применяет функцию `Math.sqrt` (квадратный корень) ко всем элементам массива.
     - `Math.sqrt(0)` → `0`
     - `Math.sqrt(1)` → `1`
     - `Math.sqrt(4)` → `2`
     - `Math.sqrt(NaN)` → `NaN`
     - `Math.sqrt(9)` → `3`
     - `Math.sqrt(NaN)` → `NaN`
     - `Math.sqrt(16)` → `4`
   - Результат: `[0, 1, 2, NaN, 3, NaN, 4]`.

6. **Метод `.filter((i) => i < 5)`**:
   - Этот метод фильтрует все значения массива, оставляя только те, которые меньше 5:
     - `0`, `1`, `2`, `3`, и `4` подходят под условие, а `NaN` отфильтровываются, так как `NaN` не сравнивается с числами.
   - Результат: `[0, 1, 2, 3, 4]`.
   
   - Если изменить условие фильтрации на `i < 4`, то результат фильтрации будет: `[0, 1, 2, 3]`.

7. **Метод `.reduce((i, d) => i + d)`**:
   - Этот метод сводит массив к единственному значению, суммируя все элементы:
     - На первом шаге: `0 + 1 = 1`
     - На втором шаге: `1 + 2 = 3`
     - На третьем шаге: `3 + 3 = 6`
     - На четвертом шаге: `6 + 4 = 10`
   - Результат после всех шагов: `10`.

   Если закомментировать строку с `.reduce()`, то программа выдаст ошибку, так как результат фильтрации — массив, и программа не сможет его вывести корректно без окончательного вычисления.

8. **Вывод в консоль**:
   - Результатом выполнения программы будет: `10`.

### Резюме:
- Итератор в `my_obj` позволяет разворачивать массив через `Symbol.iterator`.
- Последовательно применяются методы: 
  - `map()` для преобразования значений,
  - `filter()` для отбора элементов,
  - `reduce()` для получения единого значения (суммы элементов).

### [Назад к оглавлению](#back)


<a name="es6_more3"></a>
##  Продолжение "Больше о ES6"

Еще раз обозначим - вы можете выйти и заново войти в функции-генераторы, и их привязки переменных будут сохранены при повторном входе.

### Модули 
Хорошей практикой является разделение связанного кода на модули. До **ES6** существовали некоторые библиотеки, которые делали это возможным (например, **RequireJS**, **CommonJS**). Теперь ES6 поддерживает эту функцию **нативно**.

**Особенности** использования модулей:

Первый аспект - **поддерживаемость**. Модуль независим от других модулей, что позволяет улучшать и расширять его без какой-либо зависимости от кода в других модулях.

Второй аспект - **пространства имен**. В предыдущих уроках мы говорили о переменных и области видимости. Как вы знаете, переменные объявляются глобально, поэтому часто возникает проблема загрязнения пространства имен, когда несвязанные переменные доступны во всем нашем коде. Модули решают эту проблему, создавая приватное пространство для переменных.

Еще один важный аспект - **возможность повторного использования**. Когда мы пишем код, который может быть использован в других проектах, модули позволяют легко повторно использовать код, не переписывая его в новом проекте.

Давайте посмотрим, как мы должны использовать модули в файлах JS.

Например:
```js
// lib/math.js
export let sum = (x, y) => { return x + y; }
export let pi = 3.14;

// app.js
import * as math from "lib/math"
console.log(`2p = + ${math.sum(math.pi, math.pi)}`)
```

Здесь мы экспортируем функцию **sum** и переменную **pi**, чтобы мы могли использовать их в разных файлах.

> ES6 официально поддерживает модули, однако, некоторые браузеры пока еще не поддерживают модули встроенными. Поэтому, нам следует использовать **сборщики (билдеры)**, такие как **Webpack** или **Browserify**, чтобы запускать наш код.

Еще пример для закрепления: у нас есть файл **util/calc.js**, со следующим экспортируемым содержанием:
```js
export const hit = (x, y, z) => {
  return x * y + z / 2;
}
export const degree = 50;
```

Тогда из любого другого файла можно обратиться к этому содержимому, и импортировать его в свой код:
```js
import * as calc from "util/calc";
calc.hit(1, 2, calc.degree);
```

### Встроенные методы 
ES6 также ввел новые встроенные методы для упрощения ряда задач. Здесь мы рассмотрим самые распространенные из них.
### Поиск элемента массива 
Старый способ поиска первого элемента массива по его значению и правилу был следующим:
```js
let res = [4, 5, 1, 8, 2, 0].filter(function (x) {
  return x > 3;
})[0];

console.log(res);
```

Новый синтаксис более чистый и надежный:
```js
let res =
[4, 5, 1, 8, 2, 0].find(x => x > 3);

console.log(res);
```

Вы также можете получить индекс элемента выше, используя метод **findIndex()**:
```js
let res =
[4, 5, 1, 8, 2, 0].findIndex(x => x > 3);

console.log(res);
```

### Повторение строк 
До ES6 следующий синтаксис был правильным способом повторения строки несколько раз:
```js
console.log(Array(3 + 1).join("foo"));
```

С новым синтаксисом, код становится:
```js
console.log("foo".repeat(3));
```

### Поиск строк 
До ES6 мы использовали только метод **indexOf()** для поиска позиции текста в строке. Например:
```js
console.log("SoloLearn".indexOf("Solo") === 0); // true
console.log("SoloLearn".indexOf("Solo") === (4 - "Solo".length)); // true
console.log("SoloLearn".indexOf("loLe") !== -1); // true
console.log("SoloLearn".indexOf("olo", 1) !== -1); // true
console.log("SoloLearn".indexOf("olo", 2) !== -1); // false
```

ES6 заменил это версией, которая имеет более чистый и упрощенный синтаксис:
```js
console.log("SoloLearn".startsWith("Solo", 0)); // true
console.log("SoloLearn".endsWith("Solo", 4)); // true
console.log("SoloLearn".includes("loLe")); // true
console.log("SoloLearn".includes("olo", 1)); // true
console.log("SoloLearn".includes("olo", 2)); // false
```

Всегда полезно рефакторить свой код с новым синтаксисом чтобы узнать что-то новое и сделать ваш код более понятным.

Выводом следующего кода - бдует "88":
```js
const arr = ['3', '5', '8'];
console.log(
  arr.find(x => x == 8).repeat(2)
);
```

### [Назад к оглавлению](#back)


<a name="qviz4"></a>
## JS Промежуточный Модуль 4 Викторина
1. Какая из перечисленных, не является одной из новых функций ES6?

- [ ] Шаблонные строки
- [ ] Модули
- [x] Хостинг
- [ ] Деструктуризация объектов

2. Заполните пропуски, чтобы объявить константу num и стрелочную функцию calc.
```js
const num = 5;
const calc = (x, y, z = num) => {
  return x + y + z;
}
```

3. Заполните пропуски, чтобы переменная arr3 выглядела следующим образом: [1, 2, 3, 4, 5, 6, 7, 8].
```js
const arr1 = [1, 2, 3]; 
const arr2 = [5, 6, 7, 8]; 
let arr3 = [...arr1, 4, ...arr2];
```

4. Какой результат выполнения следующего кода?
```js
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [...arr1, 6];
const func = (...rest) => {
  console.log(rest.length);
}
func(...arr1);
func(...arr2);
```

- [x] 5 6
- [ ] rest
- [ ] 1
- [ ] 6 5

5. Какой вывод этого кода?
```js
const square = num => num * num;
console.log(square(6) + 6);
```

Ответ: 42

6. Заполните пропуски, чтобы скопировать объект user в объект newUser, деструктурируя свойства name и age. Передайте значение 9999 для свойства id.
```js
сonst user = {
  name: 'David',
  age: 28,
  id: 1234
};
let newUser = Object.assign({},
  {name, age} = user,
  {id: 9999});
console.log(newUser);
```

7. Заполните пропуски, чтобы получить следующий вывод:
```js
zero = 0
one = 1
```
```js
let myMap = new Map();
myMap.set('zero', 0);
myMap.set('one', 1);
for (let [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
```

### [Назад к оглавлению](#back)


<a name="pract_4_f"></a>
## ПРАКТИЧЕСКОЕ УПРАЖНЕНИЕ
### Слова 
Вы создаете шифратор текста. Он должен принимать несколько слов и выводить их в объединенном виде, где каждое слово разделено знаком доллара $.

Например, для слов "hello", "how", "are", "you", вывод должен быть "\$hello\$how\$are\$you\$".

Данный код объявляет класс под названием Add, с конструктором, который принимает один параметр rest.

Дополните код, добавив метод print() в класс, который должен генерировать запрошенный вывод.

> Обратите внимание, что знак доллара ставится в начале и в конце вывода.

```js
class Add {
  constructor(...words) {
      this.words = words;
  }
  //your code goes here
  print() {
    words
  }
}

var x = new Add("hehe", "hoho", "haha", "hihi", "huhu");
var y = new Add("this", "is", "awesome");
var z = new Add("lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipiscing", "elit");
x.print();
y.print();
z.print();
```

### [Назад к оглавлению](#back)


<a name="pract_4_f_gpt"></a>
### Решение GPT-4o
Для решения задачи нужно добавить метод `print()` в класс `Add`, который будет объединять переданные в конструктор слова и добавлять знак доллара `$` в начале, между словами и в конце.

Вот корректное решение:

```js
class Add {
  constructor(...words) {
    this.words = words;
  }

  print() {
    // Объединяем слова с помощью $ и добавляем $ в начале и в конце
    console.log(`$${this.words.join('$')}$`);
  }
}

var x = new Add("hehe", "hoho", "haha", "hihi", "huhu");
var y = new Add("this", "is", "awesome");
var z = new Add("lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipiscing", "elit");

x.print(); // $hehe$hoho$haha$hihi$huhu$
y.print(); // $this$is$awesome$
z.print(); // $lorem$ipsum$dolor$sit$amet$consectetur$adipiscing$elit$
```

### Объяснение:
1. Конструктор принимает несколько слов, используя **rest-параметры** (`...words`) и сохраняет их в массив `this.words`.
2. В методе `print()`:
   - Мы используем метод массива `.join('$')` для объединения всех слов в строку, где слова разделяются знаком `$`.
   - Добавляем знак `$` в начале и конце строки.
3. `console.log()` выводит результат в требуемом формате.

Этот код выведет строки, где каждое слово разделено знаком `$`, а также этот символ добавлен в начале и конце строки.